"""
ROP gadget finding and management.
"""

import re
import subprocess
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple

from autopwn.core.binary import Binary
from autopwn.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class Gadget:
    """Represents a ROP gadget."""
    address: int
    instructions: str
    raw_bytes: bytes = b""

    # Analysis results
    regs_popped: List[str] = field(default_factory=list)
    regs_modified: List[str] = field(default_factory=list)
    stack_change: int = 0  # How many bytes popped
    is_syscall: bool = False
    is_ret: bool = True
    is_call: bool = False
    is_jmp: bool = False

    def __str__(self) -> str:
        return f"0x{self.address:x}: {self.instructions}"


class GadgetFinder:
    """
    ROP gadget finder using multiple backends.

    Supports:
    - pwntools ROP
    - ropper
    - ROPgadget
    - angrop
    """

    def __init__(self, binary: Binary):
        """
        Initialize gadget finder.

        Args:
            binary: Target binary
        """
        self.binary = binary
        self._gadgets: Dict[str, Gadget] = {}  # instructions -> Gadget
        self._gadgets_by_addr: Dict[int, Gadget] = {}

    def find_gadgets(self, use_cache: bool = True) -> List[Gadget]:
        """
        Find all ROP gadgets in binary.

        Args:
            use_cache: Whether to use cached results

        Returns:
            List of gadgets
        """
        if self._gadgets and use_cache:
            return list(self._gadgets.values())

        gadgets = []

        # Try different backends
        gadgets = self._find_with_pwntools()

        if not gadgets:
            gadgets = self._find_with_ropper()

        if not gadgets:
            gadgets = self._find_with_ropgadget()

        # Index gadgets
        for g in gadgets:
            self._gadgets[g.instructions] = g
            self._gadgets_by_addr[g.address] = g

        logger.info(f"Found {len(gadgets)} gadgets")
        return gadgets

    def _find_with_pwntools(self) -> List[Gadget]:
        """Find gadgets using pwntools."""
        gadgets = []

        try:
            from pwn import ROP, context

            context.binary = self.binary._elf
            rop = ROP(self.binary._elf)

            # Extract gadgets from ROP object
            for gadget in rop.gadgets.values():
                g = Gadget(
                    address=gadget.address,
                    instructions="; ".join(gadget.insns),
                    stack_change=gadget.move,
                    regs_popped=list(gadget.regs),
                )
                gadgets.append(g)

        except Exception as e:
            logger.debug(f"pwntools gadget finding failed: {e}")

        return gadgets

    def _find_with_ropper(self) -> List[Gadget]:
        """Find gadgets using ropper."""
        gadgets = []

        try:
            result = subprocess.run(
                ["ropper", "--file", str(self.binary.path), "--nocolor"],
                capture_output=True,
                text=True,
                timeout=120,
            )

            for line in result.stdout.split("\n"):
                # Parse ropper output: 0xaddress: instructions
                match = re.match(r"(0x[0-9a-f]+):\s+(.+)", line.strip())
                if match:
                    addr = int(match.group(1), 16)
                    insns = match.group(2)
                    gadgets.append(Gadget(address=addr, instructions=insns))

        except FileNotFoundError:
            logger.debug("ropper not found")
        except Exception as e:
            logger.debug(f"ropper failed: {e}")

        return gadgets

    def _find_with_ropgadget(self) -> List[Gadget]:
        """Find gadgets using ROPgadget."""
        gadgets = []

        try:
            result = subprocess.run(
                ["ROPgadget", "--binary", str(self.binary.path)],
                capture_output=True,
                text=True,
                timeout=120,
            )

            for line in result.stdout.split("\n"):
                match = re.match(r"(0x[0-9a-f]+)\s+:\s+(.+)", line.strip())
                if match:
                    addr = int(match.group(1), 16)
                    insns = match.group(2)
                    gadgets.append(Gadget(address=addr, instructions=insns))

        except FileNotFoundError:
            logger.debug("ROPgadget not found")
        except Exception as e:
            logger.debug(f"ROPgadget failed: {e}")

        return gadgets

    def find_gadget(
        self,
        instructions: List[str],
        exact: bool = False,
    ) -> Optional[Gadget]:
        """
        Find gadget with specific instructions.

        Args:
            instructions: Required instructions
            exact: Whether to match exactly

        Returns:
            Matching Gadget or None
        """
        if not self._gadgets:
            self.find_gadgets()

        # Try pwntools find_gadget for common cases
        try:
            from pwn import ROP, context
            context.binary = self.binary._elf
            rop = ROP(self.binary._elf)
            result = rop.find_gadget(instructions)
            if result:
                addr = result[0]
                return self._gadgets_by_addr.get(addr) or Gadget(
                    address=addr,
                    instructions="; ".join(instructions),
                )
        except Exception:
            pass

        # Manual search
        search_str = "; ".join(instructions).lower()

        for insn_str, gadget in self._gadgets.items():
            if exact:
                if insn_str.lower() == search_str:
                    return gadget
            else:
                if search_str in insn_str.lower():
                    return gadget

        return None

    def find_pop_reg(self, reg: str) -> Optional[Gadget]:
        """
        Find pop reg; ret gadget.

        Args:
            reg: Register name

        Returns:
            Gadget or None
        """
        return self.find_gadget([f"pop {reg}", "ret"])

    def find_mov_reg(self, dst: str, src: str) -> Optional[Gadget]:
        """
        Find mov dst, src gadget.

        Args:
            dst: Destination register
            src: Source register

        Returns:
            Gadget or None
        """
        return self.find_gadget([f"mov {dst}, {src}"])

    def find_syscall(self) -> Optional[Gadget]:
        """Find syscall gadget."""
        gadget = self.find_gadget(["syscall", "ret"])
        if not gadget:
            gadget = self.find_gadget(["syscall"])
        return gadget

    def find_int_80(self) -> Optional[Gadget]:
        """Find int 0x80 gadget."""
        return self.find_gadget(["int 0x80"])

    def find_ret(self) -> Optional[Gadget]:
        """Find simple ret gadget."""
        return self.find_gadget(["ret"])

    def find_leave_ret(self) -> Optional[Gadget]:
        """Find leave; ret gadget for stack pivot."""
        return self.find_gadget(["leave", "ret"])

    def find_pop_rsp(self) -> Optional[Gadget]:
        """Find pop rsp gadget for stack pivot."""
        return self.find_gadget(["pop rsp"])

    def find_xchg_rsp(self, reg: str) -> Optional[Gadget]:
        """Find xchg rsp, reg gadget."""
        return self.find_gadget([f"xchg {reg}, rsp"]) or \
               self.find_gadget([f"xchg rsp, {reg}"])

    def find_write_gadget(self) -> Optional[Gadget]:
        """Find mov [reg], reg gadget for write primitive."""
        patterns = [
            ["mov [rdi], rsi"],
            ["mov [rdi], rdx"],
            ["mov [rax], rdx"],
            ["mov qword ptr [rdi], rsi"],
        ]
        for pattern in patterns:
            g = self.find_gadget(pattern)
            if g:
                return g
        return None

    def find_add_gadget(self, reg: str) -> Optional[Gadget]:
        """Find add reg, value gadget."""
        return self.find_gadget([f"add {reg}"])

    def get_gadgets_for_regs(
        self,
        regs: List[str],
    ) -> Dict[str, Optional[Gadget]]:
        """
        Find pop gadgets for multiple registers.

        Args:
            regs: List of register names

        Returns:
            Dict of reg -> Gadget
        """
        result = {}
        for reg in regs:
            result[reg] = self.find_pop_reg(reg)
        return result

    def filter_by_bad_chars(
        self,
        gadgets: List[Gadget],
        bad_chars: List[int],
    ) -> List[Gadget]:
        """
        Filter gadgets containing bad characters.

        Args:
            gadgets: Gadgets to filter
            bad_chars: Bad byte values

        Returns:
            Filtered gadgets
        """
        bad_set = set(bad_chars)

        def contains_bad(addr: int) -> bool:
            addr_bytes = addr.to_bytes(8, 'little')
            return any(b in bad_set for b in addr_bytes)

        return [g for g in gadgets if not contains_bad(g.address)]

    def summary(self) -> str:
        """Get gadget summary."""
        if not self._gadgets:
            self.find_gadgets()

        # Count by type
        syscall = len([g for g in self._gadgets.values() if "syscall" in g.instructions])
        pop = len([g for g in self._gadgets.values() if "pop" in g.instructions])
        mov = len([g for g in self._gadgets.values() if "mov" in g.instructions])

        return f"""
Gadget Summary
==============
Total gadgets: {len(self._gadgets)}
Pop gadgets: {pop}
Mov gadgets: {mov}
Syscall gadgets: {syscall}
"""
