"""
Exploit Verification Module - Confirm exploitation success.

This module provides robust verification of exploitation:
1. Shell verification - create a file to prove shell access
2. Flag detection - look for flag patterns in output
3. Exploit script testing - run generated exploits to confirm they work

The gold standard is creating a 'pwned' file in the binary's directory.
"""

import os
import time
import subprocess
import tempfile
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from typing import List, Optional, Tuple, Dict, Any

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)

# Verification marker
PWNED_MARKER = "SUPWNGO_PWNED_SUCCESS"
PWNED_FILE = "pwned"


class VerificationLevel(Enum):
    """Level of exploitation verification achieved."""
    NONE = auto()           # No verification
    OUTPUT_MATCH = auto()   # Found success pattern in output
    FLAG_CAPTURED = auto()  # Captured a flag
    SHELL_ACCESS = auto()   # Confirmed shell access via file creation
    FULL_CONTROL = auto()   # Full shell with command execution verified


@dataclass
class VerificationResult:
    """Result of exploit verification."""
    level: VerificationLevel = VerificationLevel.NONE
    success: bool = False
    flag: Optional[str] = None
    output: str = ""
    shell_confirmed: bool = False
    pwned_file_created: bool = False
    notes: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "level": self.level.name,
            "success": self.success,
            "flag": self.flag,
            "shell_confirmed": self.shell_confirmed,
            "pwned_file_created": self.pwned_file_created,
            "notes": self.notes,
        }


class ExploitVerifier:
    """
    Comprehensive exploit verification.

    Verifies exploits using multiple methods:
    1. Output analysis - look for flag patterns
    2. Shell testing - try to create a file
    3. Script execution - run generated exploit and verify
    """

    # Flag patterns to look for
    FLAG_PATTERNS = [
        r'flag\{[^}]+\}',
        r'ctf\{[^}]+\}',
        r'htb\{[^}]+\}',
        r'picoctf\{[^}]+\}',
        r'FLAG\{[^}]+\}',
        r'CTF\{[^}]+\}',
        r'HTB\{[^}]+\}',
    ]

    # Success indicators (not flags, but signs of winning)
    SUCCESS_PATTERNS = [
        'congratulations', 'you win', 'correct', 'success',
        'access granted', 'welcome', 'here is your', 'here\'s your',
        'well done', 'good job', 'flag:', 'the flag is',
    ]

    def __init__(self, binary_path: str, timeout: float = 5.0):
        """Initialize verifier."""
        self.binary_path = str(Path(binary_path).resolve())
        self.binary_dir = str(Path(binary_path).resolve().parent)
        self.timeout = timeout
        self.pwned_path = os.path.join(self.binary_dir, PWNED_FILE)

    def verify_output(self, output: str) -> VerificationResult:
        """
        Verify exploitation from output alone.

        Args:
            output: Output from running the exploit

        Returns:
            VerificationResult with analysis
        """
        import re
        result = VerificationResult()
        output_lower = output.lower()

        # Look for flag patterns
        for pattern in self.FLAG_PATTERNS:
            match = re.search(pattern, output, re.IGNORECASE)
            if match:
                result.flag = match.group(0)
                result.level = VerificationLevel.FLAG_CAPTURED
                result.success = True
                result.notes.append(f"Captured flag: {result.flag}")
                return result

        # Look for success patterns
        for pattern in self.SUCCESS_PATTERNS:
            if pattern in output_lower:
                result.level = VerificationLevel.OUTPUT_MATCH
                result.success = True
                result.notes.append(f"Found success indicator: '{pattern}'")
                # Don't return yet - might find flag too

        result.output = output[:500]  # Store truncated output
        return result

    def verify_shell_access(self, proc) -> VerificationResult:
        """
        Verify shell access by creating a file.

        Args:
            proc: pwntools process/tube object

        Returns:
            VerificationResult with shell verification
        """
        result = VerificationResult()

        try:
            # Clean up any existing pwned file
            if os.path.exists(self.pwned_path):
                os.remove(self.pwned_path)

            # Try to create pwned file via shell
            cmd = f"echo '{PWNED_MARKER}' > {self.pwned_path}"
            proc.sendline(cmd.encode())
            time.sleep(0.3)

            # Also try to echo marker to stdout
            proc.sendline(f"echo {PWNED_MARKER}".encode())
            time.sleep(0.2)

            # Check for marker in output
            try:
                output = proc.recv(timeout=1.0)
                if PWNED_MARKER.encode() in output:
                    result.shell_confirmed = True
            except Exception:
                pass

            # Check if file was created
            if os.path.exists(self.pwned_path):
                try:
                    with open(self.pwned_path, 'r') as f:
                        content = f.read()
                    if PWNED_MARKER in content:
                        result.pwned_file_created = True
                        result.shell_confirmed = True
                        result.level = VerificationLevel.SHELL_ACCESS
                        result.success = True
                        result.notes.append(f"Created verification file: {self.pwned_path}")
                except Exception:
                    pass

            # Extra verification - run id command
            if result.shell_confirmed:
                try:
                    proc.sendline(b"id")
                    id_output = proc.recv(timeout=0.5)
                    if b"uid=" in id_output:
                        result.level = VerificationLevel.FULL_CONTROL
                        result.notes.append("Verified command execution with 'id'")
                except Exception:
                    pass

        except Exception as e:
            logger.debug(f"Shell verification failed: {e}")
            result.notes.append(f"Shell verification error: {str(e)}")

        return result

    def verify_payload(self, payload: bytes) -> VerificationResult:
        """
        Verify a payload works by running the binary.

        Args:
            payload: Exploit payload bytes

        Returns:
            VerificationResult
        """
        result = VerificationResult()

        try:
            # Run binary with payload
            proc_result = subprocess.run(
                [self.binary_path],
                input=payload,
                capture_output=True,
                timeout=self.timeout,
                cwd=self.binary_dir,
            )

            output = (proc_result.stdout + proc_result.stderr).decode('latin-1', errors='ignore')
            result = self.verify_output(output)

            if proc_result.returncode == 0 and not result.success:
                result.notes.append("Binary exited cleanly")

        except subprocess.TimeoutExpired:
            result.notes.append("Binary timed out - might have spawned shell")
            # Try with pwntools for shell verification
            result = self._verify_with_pwntools(payload)
        except Exception as e:
            result.notes.append(f"Payload test error: {str(e)}")

        return result

    def _verify_with_pwntools(self, payload: bytes) -> VerificationResult:
        """Use pwntools for more sophisticated verification."""
        result = VerificationResult()

        try:
            from pwn import process, context as pwn_context
            pwn_context.log_level = 'error'

            p = process([self.binary_path], cwd=self.binary_dir)
            p.sendline(payload)
            time.sleep(0.3)

            # Try shell verification
            shell_result = self.verify_shell_access(p)
            if shell_result.success:
                result = shell_result
            else:
                # Get any output
                try:
                    output = p.recv(timeout=1.0)
                    result = self.verify_output(output.decode('latin-1', errors='ignore'))
                except Exception:
                    pass

            p.close()

        except Exception as e:
            result.notes.append(f"pwntools verification failed: {str(e)}")

        return result

    def verify_exploit_script(self, script_path: str) -> VerificationResult:
        """
        Verify an exploit script works by running it.

        Args:
            script_path: Path to Python exploit script

        Returns:
            VerificationResult
        """
        result = VerificationResult()

        # Clean up existing pwned file
        if os.path.exists(self.pwned_path):
            os.remove(self.pwned_path)

        try:
            # Run the exploit script
            proc_result = subprocess.run(
                ['python3', script_path],
                capture_output=True,
                timeout=self.timeout * 2,
                cwd=self.binary_dir,
            )

            output = (proc_result.stdout + proc_result.stderr).decode('latin-1', errors='ignore')
            result = self.verify_output(output)

            # Check if pwned file was created
            if os.path.exists(self.pwned_path):
                result.pwned_file_created = True
                result.shell_confirmed = True
                result.level = VerificationLevel.SHELL_ACCESS
                result.success = True
                result.notes.append("Exploit script created verification file")

        except subprocess.TimeoutExpired:
            result.notes.append("Exploit script timed out")
        except Exception as e:
            result.notes.append(f"Script verification error: {str(e)}")

        return result

    def cleanup(self):
        """Clean up verification files."""
        if os.path.exists(self.pwned_path):
            os.remove(self.pwned_path)


def verify_exploit(
    binary_path: str,
    payload: Optional[bytes] = None,
    script_path: Optional[str] = None,
    timeout: float = 5.0,
) -> VerificationResult:
    """
    Convenience function to verify exploitation.

    Args:
        binary_path: Path to target binary
        payload: Raw exploit payload (optional)
        script_path: Path to exploit script (optional)
        timeout: Timeout for verification

    Returns:
        VerificationResult
    """
    verifier = ExploitVerifier(binary_path, timeout)

    if script_path:
        result = verifier.verify_exploit_script(script_path)
    elif payload:
        result = verifier.verify_payload(payload)
    else:
        result = VerificationResult()
        result.notes.append("No payload or script provided")

    return result


def create_verified_exploit_script(
    original_script: str,
    binary_path: str,
) -> str:
    """
    Wrap an exploit script with verification code.

    Adds code to:
    1. Create pwned file on shell access
    2. Print verification marker
    3. Capture and display flag

    Args:
        original_script: The original exploit script
        binary_path: Path to target binary

    Returns:
        Modified script with verification
    """
    verification_code = f'''
# === VERIFICATION CODE (added by supwngo) ===
import os
import time

PWNED_MARKER = "{PWNED_MARKER}"
PWNED_FILE = os.path.join(os.path.dirname(BINARY), "{PWNED_FILE}")

def verify_shell(io):
    """Verify shell access by creating verification file."""
    try:
        # Remove existing file
        if os.path.exists(PWNED_FILE):
            os.remove(PWNED_FILE)

        # Create verification file
        io.sendline(f"echo '{{PWNED_MARKER}}' > {{PWNED_FILE}}".encode())
        time.sleep(0.3)

        # Echo marker to stdout
        io.sendline(f"echo {{PWNED_MARKER}}".encode())

        # Try to receive marker
        try:
            output = io.recv(timeout=2.0)
            if PWNED_MARKER.encode() in output:
                log.success("Shell verified via stdout")
        except:
            pass

        # Check file creation
        time.sleep(0.3)
        if os.path.exists(PWNED_FILE):
            with open(PWNED_FILE, 'r') as f:
                if PWNED_MARKER in f.read():
                    log.success(f"Shell verified! Created: {{PWNED_FILE}}")
                    return True

    except Exception as e:
        log.warning(f"Shell verification failed: {{e}}")

    return False
# === END VERIFICATION CODE ===
'''

    # Insert verification code after imports
    lines = original_script.split('\n')
    import_end = 0
    for i, line in enumerate(lines):
        if line.startswith('from pwn import') or line.startswith('import '):
            import_end = i + 1

    # Insert verification code
    lines.insert(import_end, verification_code)

    # Add verification call before io.interactive()
    modified = '\n'.join(lines)
    modified = modified.replace(
        'io.interactive()',
        '''# Verify shell access
    verify_shell(io)

    io.interactive()'''
    )

    return modified
