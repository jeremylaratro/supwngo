"""
Exploit strategy suggester based on binary protections and analysis.

Analyzes binary characteristics and suggests exploit strategies based on
patterns learned from real CTF challenges:

- Crossbow: OOB write -> stack pivot via leave;ret -> mprotect + shellcode
- Laconic: Minimal binary + static -> SROP with /bin/sh string
- Void: Limited gadgets -> ret2dlresolve
- Abyss: No canary + strcpy -> simple stack BOF
- El Mundo: ret2win with win function

Key insights encoded:
1. No PIE + No canary = simple ROP via buffer overflow
2. Static binary + syscall gadgets = SROP is often simplest
3. NX + writable BSS = mprotect + shellcode approach
4. Has win function = ret2win
5. After mprotect(rdi, rsi, rdx), rax=0 and rdi unchanged - chain to read syscall
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import TYPE_CHECKING, List, Optional, Dict, Any

if TYPE_CHECKING:
    from supwngo.core.binary import Binary
    from supwngo.exploit.rop.gadgets import GadgetFinder

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class ExploitApproach(Enum):
    """Exploit approach categories."""
    RET2WIN = auto()             # Return to win function
    ROP_EXECVE = auto()          # Classic ROP to execve syscall
    ROP_SYSTEM = auto()          # ret2libc system()
    SROP = auto()                # Sigreturn-oriented programming
    MPROTECT_SHELLCODE = auto()  # mprotect + shellcode execution
    STACK_PIVOT = auto()         # OOB write + stack pivot
    FORMAT_STRING = auto()       # Format string exploitation
    RET2PLT = auto()             # Return to PLT entries
    RET2DLRESOLVE = auto()       # ret2dlresolve for no-libc scenarios
    ONE_GADGET = auto()          # libc one_gadget
    SHELLCODE = auto()           # Direct shellcode (NX disabled)
    HEAP_EXPLOIT = auto()        # Heap-based exploitation
    SECCOMP_BYPASS = auto()      # Bypass seccomp restrictions


@dataclass
class ExploitStrategy:
    """A suggested exploit strategy with details."""
    approach: ExploitApproach
    priority: int  # 1 = highest priority (most likely to work)
    description: str
    requirements: List[str] = field(default_factory=list)
    advantages: List[str] = field(default_factory=list)
    disadvantages: List[str] = field(default_factory=list)
    steps: List[str] = field(default_factory=list)
    gadgets_needed: List[str] = field(default_factory=list)
    notes: List[str] = field(default_factory=list)
    confidence: float = 0.5  # 0.0 to 1.0

    def __str__(self) -> str:
        lines = [
            f"[{self.priority}] {self.approach.name}: {self.description}",
            f"    Confidence: {self.confidence:.0%}",
            f"    Requirements: {', '.join(self.requirements) or 'None'}",
            f"    Advantages: {', '.join(self.advantages)}",
        ]
        if self.disadvantages:
            lines.append(f"    Disadvantages: {', '.join(self.disadvantages)}")
        if self.steps:
            lines.append("    Steps:")
            for i, step in enumerate(self.steps, 1):
                lines.append(f"      {i}. {step}")
        if self.notes:
            lines.append("    Notes:")
            for note in self.notes:
                lines.append(f"      - {note}")
        return "\n".join(lines)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "approach": self.approach.name,
            "priority": self.priority,
            "description": self.description,
            "confidence": self.confidence,
            "requirements": self.requirements,
            "advantages": self.advantages,
            "disadvantages": self.disadvantages,
            "steps": self.steps,
            "gadgets_needed": self.gadgets_needed,
            "notes": self.notes,
        }


@dataclass
class StrategyReport:
    """Complete strategy analysis report."""
    binary_path: str
    arch: str
    bits: int
    protections_summary: str
    strategies: List[ExploitStrategy] = field(default_factory=list)
    recommended: Optional[ExploitStrategy] = None
    notes: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)

    # Analysis details
    has_win_function: bool = False
    win_function_addr: int = 0
    has_binsh: bool = False
    binsh_addr: int = 0
    is_static: bool = False
    has_libc: bool = False

    def __str__(self) -> str:
        lines = [
            f"{'=' * 60}",
            f"EXPLOIT STRATEGY REPORT: {self.binary_path}",
            f"{'=' * 60}",
            f"Architecture: {self.arch} ({self.bits}-bit)",
            f"Protections: {self.protections_summary}",
            "",
        ]

        if self.warnings:
            lines.append("âš ï¸  WARNINGS:")
            for w in self.warnings:
                lines.append(f"    ! {w}")
            lines.append("")

        if self.recommended:
            lines.append("ðŸŽ¯ RECOMMENDED APPROACH:")
            lines.append(str(self.recommended))
            lines.append("")

        lines.append("ALL VIABLE STRATEGIES (by priority):")
        lines.append("-" * 40)
        for strat in sorted(self.strategies, key=lambda s: s.priority):
            lines.append(str(strat))
            lines.append("")

        if self.notes:
            lines.append("ðŸ“ ADDITIONAL NOTES:")
            for note in self.notes:
                lines.append(f"    - {note}")

        return "\n".join(lines)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "binary_path": self.binary_path,
            "arch": self.arch,
            "bits": self.bits,
            "protections_summary": self.protections_summary,
            "recommended": self.recommended.to_dict() if self.recommended else None,
            "strategies": [s.to_dict() for s in self.strategies],
            "notes": self.notes,
            "warnings": self.warnings,
            "has_win_function": self.has_win_function,
            "win_function_addr": self.win_function_addr,
            "has_binsh": self.has_binsh,
            "is_static": self.is_static,
        }


class StrategySuggester:
    """Suggest exploit strategies based on binary analysis."""

    # Common win function names
    WIN_FUNCTIONS = [
        "win", "flag", "shell", "get_flag", "print_flag", "read_flag",
        "give_shell", "spawn_shell", "backdoor", "secret", "winner",
        "cat_flag", "system_shell", "ez_win", "vuln_func",
    ]

    def __init__(
        self,
        binary: "Binary",
        gadget_finder: Optional["GadgetFinder"] = None,
    ):
        self.binary = binary
        self.gadget_finder = gadget_finder
        self._gadgets_analyzed = False

        # Cache protections
        self._is_static = getattr(binary.protections, 'static', False)
        # Alternative check via pwntools
        if not self._is_static and hasattr(binary, '_elf'):
            self._is_static = getattr(binary._elf, 'statically_linked', False)

        # Cached analysis results
        self._has_syscall = False
        self._has_syscall_ret = False
        self._has_sigreturn = False
        self._pop_gadgets: Dict[str, bool] = {}
        self._has_leave_ret = False

    def analyze(self) -> StrategyReport:
        """Analyze binary and generate strategy report."""
        report = StrategyReport(
            binary_path=str(self.binary.path),
            arch=self.binary.arch,
            bits=self.binary.bits,
            protections_summary=self._protection_summary(),
            is_static=self._is_static,
        )

        # Check for special conditions
        self._analyze_special_conditions(report)

        # Analyze gadgets if finder available
        if self.gadget_finder:
            self._analyze_gadgets()

        # Generate strategies based on protections and analysis
        strategies = []

        # === ret2win Strategy (highest priority if win function exists) ===
        if report.has_win_function:
            strategies.append(self._build_ret2win_strategy(report))

        # === Shellcode Strategy (if NX disabled) ===
        if self._check_shellcode_viable():
            strategies.append(self._build_shellcode_strategy())

        # === SROP Strategy ===
        if self._check_srop_viable():
            strategies.append(self._build_srop_strategy())

        # === ROP execve Strategy ===
        if self._check_rop_execve_viable():
            strategies.append(self._build_rop_execve_strategy(report))

        # === mprotect + shellcode Strategy ===
        if self._check_mprotect_viable():
            strategies.append(self._build_mprotect_strategy())

        # === ret2libc/system Strategy ===
        if self._check_ret2libc_viable():
            strategies.append(self._build_ret2libc_strategy())

        # === Stack Pivot Strategy ===
        if self._check_stack_pivot_viable():
            strategies.append(self._build_stack_pivot_strategy())

        # === ret2dlresolve Strategy ===
        if self._check_ret2dlresolve_viable():
            strategies.append(self._build_ret2dlresolve_strategy())

        # === ret2plt Strategy ===
        if self._check_ret2plt_viable():
            strategies.append(self._build_ret2plt_strategy())

        # === Format String Strategy ===
        if self._check_format_string_viable():
            strategies.append(self._build_format_string_strategy())

        # Sort by priority and set recommended
        strategies.sort(key=lambda s: (s.priority, -s.confidence))
        report.strategies = strategies

        if strategies:
            report.recommended = strategies[0]

        # Add warnings based on protections
        self._add_warnings(report)

        # Add general notes
        self._add_notes(report)

        return report

    def _protection_summary(self) -> str:
        """Generate short protection summary."""
        prots = self.binary.protections
        parts = []
        parts.append("Canary" if prots.canary else "No-Canary")
        parts.append("NX" if prots.nx else "No-NX")
        parts.append("PIE" if prots.pie else "No-PIE")
        parts.append(f"RELRO:{prots.relro}")
        return " | ".join(parts)

    def _analyze_special_conditions(self, report: StrategyReport):
        """Check for special conditions like win functions and /bin/sh."""
        # Check for win function
        for name in self.WIN_FUNCTIONS:
            if name in self.binary.symbols:
                report.has_win_function = True
                report.win_function_addr = self.binary.symbols[name].address if hasattr(self.binary.symbols[name], 'address') else self.binary.symbols[name]
                logger.info(f"Found win function: {name} @ 0x{report.win_function_addr:x}")
                break

        # Check for /bin/sh string using pwntools
        binsh = self._search_string("/bin/sh")
        if binsh:
            report.has_binsh = True
            report.binsh_addr = binsh
            logger.info(f"Found /bin/sh @ 0x{binsh:x}")

        # Check for libc
        report.has_libc = not self._is_static

    def _search_string(self, s: str) -> Optional[int]:
        """Search for a string in the binary."""
        try:
            # Use pwntools search if available
            if hasattr(self.binary, '_elf') and self.binary._elf:
                results = list(self.binary._elf.search(s.encode()))
                if results:
                    return results[0]
        except Exception as e:
            logger.debug(f"String search failed: {e}")

        # Fallback: search in raw binary data
        try:
            data = self.binary.path.read_bytes()
            idx = data.find(s.encode())
            if idx >= 0:
                # Try to convert file offset to virtual address
                for section in self.binary.sections.values():
                    if section.offset <= idx < section.offset + section.size:
                        return section.address + (idx - section.offset)
                # If no section match, return raw offset (might work for some cases)
                return idx
        except Exception:
            pass

        return None

    def _analyze_gadgets(self):
        """Analyze available gadgets."""
        if self._gadgets_analyzed or not self.gadget_finder:
            return

        self.gadget_finder.find_gadgets()

        # Check for syscall gadgets
        syscall = self.gadget_finder.find_syscall()
        self._has_syscall = syscall is not None
        self._has_syscall_ret = syscall is not None and "ret" in syscall.instructions

        # Check for sigreturn capability
        # Need syscall and way to set rax=15 (x64) or eax=119 (x86)
        if self._has_syscall:
            if self.binary.bits == 64:
                pop_rax = self.gadget_finder.find_pop_reg("rax")
                self._has_sigreturn = pop_rax is not None
            else:
                pop_eax = self.gadget_finder.find_pop_reg("eax")
                self._has_sigreturn = pop_eax is not None

        # Check for pop gadgets
        if self.binary.bits == 64:
            regs = ["rdi", "rsi", "rdx", "rax", "rcx", "r8", "r9"]
        else:
            regs = ["eax", "ebx", "ecx", "edx", "esi", "edi"]

        for reg in regs:
            gadget = self.gadget_finder.find_pop_reg(reg)
            self._pop_gadgets[reg] = gadget is not None

        # Check for stack pivot
        leave_ret = self.gadget_finder.find_leave_ret()
        self._has_leave_ret = leave_ret is not None

        self._gadgets_analyzed = True

    # === Strategy Viability Checks ===

    def _check_shellcode_viable(self) -> bool:
        """Check if direct shellcode is viable (NX disabled)."""
        return not self.binary.protections.nx

    def _check_srop_viable(self) -> bool:
        """Check if SROP is viable."""
        if not self._gadgets_analyzed:
            # Without gadget analysis, assume viable for static binaries
            return self._is_static
        return self._has_sigreturn and self._has_syscall

    def _check_rop_execve_viable(self) -> bool:
        """Check if ROP to execve is viable."""
        if not self._gadgets_analyzed:
            # For static binaries, assume highly viable
            # For dynamic binaries, still potentially viable (libc has gadgets)
            return True

        if self.binary.bits == 64:
            required = ["rdi", "rsi", "rdx", "rax"]
            have_all = all(self._pop_gadgets.get(r, False) for r in required)
            # For dynamic binaries, even without all gadgets, libc can provide them
            if not self._is_static:
                return True  # Libc has all gadgets we need
            return have_all and self._has_syscall
        else:
            required = ["eax", "ebx", "ecx", "edx"]
            have_all = all(self._pop_gadgets.get(r, False) for r in required)
            if not self._is_static:
                return True
            return have_all

    def _check_mprotect_viable(self) -> bool:
        """Check if mprotect + shellcode is viable."""
        if not self._gadgets_analyzed:
            return self._is_static and self.binary.protections.nx

        if self.binary.bits == 64:
            required = ["rdi", "rsi", "rdx"]
            have_regs = all(self._pop_gadgets.get(r, False) for r in required)
            return have_regs and self._has_syscall
        return False

    def _check_ret2libc_viable(self) -> bool:
        """Check if ret2libc is viable."""
        if self._is_static:
            return False
        if not self._gadgets_analyzed:
            return True
        if self.binary.bits == 64:
            return self._pop_gadgets.get("rdi", False)
        return True  # 32-bit uses stack

    def _check_stack_pivot_viable(self) -> bool:
        """Check if stack pivot is viable."""
        if not self._gadgets_analyzed:
            return True  # Assume potentially viable
        return self._has_leave_ret

    def _check_ret2dlresolve_viable(self) -> bool:
        """Check if ret2dlresolve is viable."""
        # Works when we have limited gadgets but need to call arbitrary functions
        if self._is_static:
            return False
        if self.binary.protections.relro == "full":
            return False
        return True

    def _check_ret2plt_viable(self) -> bool:
        """Check if ret2plt is viable."""
        if self._is_static:
            return False
        return True

    def _check_format_string_viable(self) -> bool:
        """Check if format string exploitation might be viable."""
        # Check if printf-like functions are imported
        fmt_funcs = ["printf", "fprintf", "sprintf", "snprintf", "syslog"]
        for func in fmt_funcs:
            if func in self.binary.imports:
                return True
        return False

    # === Strategy Builders ===

    def _build_ret2win_strategy(self, report: StrategyReport) -> ExploitStrategy:
        """Build ret2win strategy."""
        return ExploitStrategy(
            approach=ExploitApproach.RET2WIN,
            priority=1,
            confidence=0.95,
            description=f"Return to win function @ 0x{report.win_function_addr:x}",
            requirements=["Buffer overflow to control return address"],
            advantages=[
                "Simplest exploitation technique",
                "No ROP chain needed",
                "Single address overwrite",
            ],
            disadvantages=[
                "Only works if win function exists",
            ],
            steps=[
                "Find offset to return address (use cyclic pattern)",
                f"Overwrite return address with 0x{report.win_function_addr:x}",
                "Add 'ret' gadget before if stack alignment needed (64-bit)",
            ],
            notes=[
                "Check if win function needs arguments",
                "64-bit requires 16-byte stack alignment before calls",
            ],
        )

    def _build_shellcode_strategy(self) -> ExploitStrategy:
        """Build direct shellcode strategy."""
        notes = [
            "Use NOP sled if address is approximate",
            "Check for bad characters (null, newline, etc.)",
        ]
        steps = [
            "Find offset to return address",
            "Place shellcode in buffer or known location",
            "Overwrite return address with shellcode address",
        ]
        pivot_gadgets = []

        # Check for shellcode pivot gadgets (jmp rsp, jmp rsi, call rsp, etc.)
        if self.gadget_finder:
            pivots = self.gadget_finder.find_shellcode_pivots()
            if pivots:
                for name, gadget in pivots.items():
                    pivot_gadgets.append(f"{name} @ {hex(gadget.address)}")
                notes.append(f"Shellcode pivot gadgets found: {', '.join(pivot_gadgets)}")

                # If jmp rsi found, add specific note about RSI pointing to input
                if 'jmp rsi' in pivots:
                    notes.append("jmp rsi: After read() syscall, RSI points to input buffer!")
                    steps = [
                        "Find offset to return address",
                        "After read(), RSI points to input buffer",
                        f"Overwrite return address with jmp rsi ({hex(pivots['jmp rsi'].address)})",
                        "Shellcode at start of input will execute",
                    ]

                # If jmp rsp found
                if 'jmp rsp' in pivots:
                    notes.append("jmp rsp: Shellcode can follow return address on stack")
                    steps = [
                        "Find offset to return address",
                        f"Overwrite return address with jmp rsp ({hex(pivots['jmp rsp'].address)})",
                        "Place shellcode immediately after return address",
                    ]
        else:
            notes.append("Run with gadget finder to detect jmp rsp/rsi gadgets")

        # Higher confidence with pivot gadgets
        confidence = 0.95 if pivot_gadgets else (0.9 if not self.binary.protections.pie else 0.7)

        return ExploitStrategy(
            approach=ExploitApproach.SHELLCODE,
            priority=1 if not self.binary.protections.pie else 2,
            confidence=confidence,
            description="Direct shellcode execution (NX disabled)",
            requirements=["Buffer overflow", "Know shellcode address or pivot gadget"],
            advantages=[
                "Arbitrary code execution",
                "No ROP chain needed",
                "Flexible payload",
            ],
            disadvantages=[
                "Need to know buffer address (harder with ASLR/PIE)" if not pivot_gadgets else "Bad character restrictions may apply",
                "Bad character restrictions may apply",
            ] if not pivot_gadgets else ["Bad character restrictions may apply"],
            steps=steps,
            gadgets_needed=list(pivot_gadgets) if pivot_gadgets else [],
            notes=notes,
        )

    def _build_srop_strategy(self) -> ExploitStrategy:
        """Build SROP strategy."""
        priority = 1 if self._is_static else 2
        confidence = 0.85 if self._has_sigreturn else 0.6

        if self.binary.bits == 64:
            steps = [
                "Find/write '/bin/sh' string address",
                "Set rax = 15 (SYS_rt_sigreturn)",
                "Trigger syscall",
                "Sigreturn frame sets: rax=59, rdi=/bin/sh, rsi=0, rdx=0, rip=syscall",
            ]
            notes = [
                "SYS_rt_sigreturn = 15 on x86_64",
                "Sigreturn frame is 248 bytes",
                "Use pwntools: frame = SigreturnFrame()",
                "frame.rax = 59; frame.rdi = binsh_addr; frame.rsi = 0; frame.rdx = 0",
            ]
        else:
            steps = [
                "Find/write '/bin/sh' string address",
                "Set eax = 119 (SYS_sigreturn)",
                "Trigger int 0x80",
                "Sigreturn frame sets all registers for execve",
            ]
            notes = ["SYS_sigreturn = 119 on x86"]

        return ExploitStrategy(
            approach=ExploitApproach.SROP,
            priority=priority,
            confidence=confidence,
            description="Sigreturn-Oriented Programming - set all registers at once",
            requirements=["syscall gadget", "control of rax (or sigreturn gadget)"],
            advantages=[
                "Minimal gadget requirements",
                "Sets ALL registers in one syscall",
                "Perfect for minimal/static binaries",
            ],
            disadvantages=[
                "Requires ~248 bytes of controlled stack space",
                "Frame must be properly aligned",
            ],
            steps=steps,
            gadgets_needed=["pop rax (or way to set rax)", "syscall"],
            notes=notes,
        )

    def _build_rop_execve_strategy(self, report: StrategyReport) -> ExploitStrategy:
        """Build ROP execve strategy."""
        # Priority: 1 for static binaries (preferred), 2 with /bin/sh, 3 otherwise
        if self._is_static:
            priority = 1
        elif report.has_binsh:
            priority = 2
        else:
            # Even for dynamic binaries, ROP_EXECVE is viable if we have gadgets
            priority = 2 if not self.binary.protections.canary else 3
        confidence = 0.8 if self._check_rop_execve_viable() else 0.5

        if self.binary.bits == 64:
            steps = [
                "Find /bin/sh string (or write to BSS)",
                "pop rdi; ret -> /bin/sh address",
                "pop rsi; ret -> 0 (argv)",
                "pop rdx; ret -> 0 (envp)  [or pop rdx; pop r12; ret]",
                "pop rax; ret -> 59 (execve syscall number)",
                "syscall",
            ]
            gadgets_needed = ["pop rdi", "pop rsi", "pop rdx", "pop rax", "syscall"]
        else:
            steps = [
                "Find /bin/sh string",
                "pop ebx; ret -> /bin/sh address",
                "pop ecx; ret -> 0",
                "pop edx; ret -> 0",
                "pop eax; ret -> 11 (execve)",
                "int 0x80",
            ]
            gadgets_needed = ["pop ebx", "pop ecx", "pop edx", "pop eax", "int 0x80"]

        return ExploitStrategy(
            approach=ExploitApproach.ROP_EXECVE,
            priority=priority,
            confidence=confidence,
            description="ROP chain to execve('/bin/sh', NULL, NULL)",
            requirements=["All register-setting gadgets", "syscall/int80", "/bin/sh string"],
            advantages=[
                "Direct shell execution",
                "No libc dependency",
                "Works on static binaries",
            ],
            disadvantages=[
                "Requires multiple specific gadgets",
                "Chain size can be 40-64+ bytes",
            ],
            steps=steps,
            gadgets_needed=gadgets_needed,
            notes=[
                "If missing /bin/sh, write it to BSS with mov gadgets",
                "Look for multi-pop gadgets (e.g., pop rsi; pop r15; ret)",
            ],
        )

    def _build_mprotect_strategy(self) -> ExploitStrategy:
        """Build mprotect + shellcode strategy."""
        return ExploitStrategy(
            approach=ExploitApproach.MPROTECT_SHELLCODE,
            priority=2,
            confidence=0.75,
            description="mprotect() to make region executable, then shellcode",
            requirements=["Register gadgets for mprotect args", "syscall", "Writable address"],
            advantages=[
                "Arbitrary shellcode execution",
                "Can bypass seccomp with custom shellcode",
                "mprotect return value trick reduces chain size",
            ],
            disadvantages=[
                "Two-stage payload required",
                "Need to know writable address",
            ],
            steps=[
                "Find writable region (BSS, heap, or stack)",
                "Stage 1 ROP: mprotect(addr, 0x1000, 7)  # PROT_RWX",
                "Stage 2 ROP: read(0, addr, shellcode_size)",
                "Return to shellcode location",
                "Send shellcode over stdin",
            ],
            gadgets_needed=["pop rdi", "pop rsi", "pop rdx", "pop rax", "syscall"],
            notes=[
                "KEY: After mprotect returns, rax=0 (read syscall!) and rdi unchanged",
                "If rdi=0 was used for mprotect, it's already stdin for read!",
                "This trick saves gadgets - only need pop rsi + pop rdx after mprotect",
                "Used in crossbow challenge with 127-byte limit",
            ],
        )

    def _build_ret2libc_strategy(self) -> ExploitStrategy:
        """Build ret2libc strategy."""
        # ROP_SYSTEM priority should be balanced with ROP_EXECVE
        # Give priority 2 for easy cases (no PIE, no canary), 3 otherwise
        if not self.binary.protections.pie and not self.binary.protections.canary:
            priority = 2
        else:
            priority = 3

        if self.binary.bits == 64:
            steps = [
                "Leak libc address (puts@got via puts@plt)",
                "Calculate libc base from leak",
                "Find system() and '/bin/sh' offsets in libc",
                "Stage 2: ret + pop rdi + /bin/sh + system()",
            ]
            notes = [
                "64-bit requires 16-byte stack alignment",
                "Use 'ret' gadget before system() for alignment",
                "Return to main/vuln_func for stage 2",
            ]
        else:
            steps = [
                "Leak libc address",
                "Calculate libc base",
                "ROP: system + fake_ret + /bin/sh_addr",
            ]
            notes = ["32-bit uses stack for arguments"]

        return ExploitStrategy(
            approach=ExploitApproach.ROP_SYSTEM,
            priority=priority,
            confidence=0.7,
            description="ret2libc: system('/bin/sh')",
            requirements=["libc leak", "pop rdi (64-bit)", "Return to vulnerable function"],
            advantages=[
                "Works without syscall gadgets",
                "libc has '/bin/sh' built-in",
                "Well-documented technique",
            ],
            disadvantages=[
                "Requires libc address leak",
                "Need to identify libc version",
                "ASLR means leak is mandatory",
            ],
            steps=steps,
            gadgets_needed=["pop rdi", "ret"] if self.binary.bits == 64 else [],
            notes=notes,
        )

    def _build_stack_pivot_strategy(self) -> ExploitStrategy:
        """Build stack pivot strategy."""
        return ExploitStrategy(
            approach=ExploitApproach.STACK_PIVOT,
            priority=3,
            confidence=0.65,
            description="Pivot stack to controlled buffer for larger ROP chain",
            requirements=["Control of rbp/ebp", "leave;ret gadget", "Known writable address"],
            advantages=[
                "Enables larger ROP chains",
                "Useful when overflow is limited",
                "Works with OOB write vulnerabilities",
            ],
            disadvantages=[
                "Two-stage exploitation",
                "Need to know heap/BSS address",
            ],
            steps=[
                "Stage 1: Overflow to control saved RBP",
                "Set RBP to (target_buffer - 8)",
                "Return to leave;ret gadget",
                "leave: mov rsp, rbp; pop rbp -> pivots stack",
                "ret: begins executing ROP chain at new stack",
                "Place main ROP chain at target_buffer",
            ],
            gadgets_needed=["leave; ret"],
            notes=[
                "Used in crossbow: -2 index OOB write to saved rbp",
                "Heap pointer written to rbp, ROP chain on heap",
                "Can also use pop rsp gadget directly if available",
            ],
        )

    def _build_ret2dlresolve_strategy(self) -> ExploitStrategy:
        """Build ret2dlresolve strategy."""
        return ExploitStrategy(
            approach=ExploitApproach.RET2DLRESOLVE,
            priority=4,
            confidence=0.6,
            description="Forge dynamic linker structures to resolve arbitrary function",
            requirements=["Partial RELRO or less", "Writable memory for fake structures"],
            advantages=[
                "No libc leak needed",
                "Can call any libc function",
                "Works with minimal gadgets",
            ],
            disadvantages=[
                "Complex structure forgery",
                "Blocked by Full RELRO",
                "Requires understanding of ELF internals",
            ],
            steps=[
                "Find writable area (BSS)",
                "Craft fake Elf_Rel, Elf_Sym, and string table",
                "Push fake reloc_index",
                "Jump to PLT[0] (resolver)",
                "Resolver calls our forged 'system'",
            ],
            gadgets_needed=["pop rdi (for argument)", "leave;ret or pop rsp (for pivot)"],
            notes=[
                "Use pwntools: rop.ret2dlresolve_payload()",
                "Good for 'void' challenge with limited gadgets",
                "32-bit is easier than 64-bit due to structure sizes",
            ],
        )

    def _build_ret2plt_strategy(self) -> ExploitStrategy:
        """Build ret2plt strategy."""
        return ExploitStrategy(
            approach=ExploitApproach.RET2PLT,
            priority=4,
            confidence=0.6,
            description="Return to PLT entries to call imported functions",
            requirements=["PLT entries available", "Control of function arguments"],
            advantages=[
                "No libc leak needed for PLT calls",
                "Can use puts/printf for leaking",
                "Good first stage before ret2libc",
            ],
            disadvantages=[
                "Limited to imported functions",
                "Usually need second stage for shell",
            ],
            steps=[
                "Identify useful PLT entries (puts, printf, system)",
                "Leak GOT entry: puts@plt(puts@got)",
                "Calculate libc base from leak",
                "Return to main for second stage",
                "Stage 2: ret2libc with known addresses",
            ],
            gadgets_needed=["pop rdi (64-bit)"],
            notes=[
                "puts@plt + puts@got = reliable libc leak",
                "Check if system is in PLT (instant win!)",
            ],
        )

    def _build_format_string_strategy(self) -> ExploitStrategy:
        """Build format string strategy."""
        return ExploitStrategy(
            approach=ExploitApproach.FORMAT_STRING,
            priority=3,
            confidence=0.5,
            description="Exploit format string vulnerability for read/write primitives",
            requirements=["printf-like function with controlled format string"],
            advantages=[
                "Arbitrary read and write",
                "Can leak stack, libc, canary, PIE",
                "Can overwrite GOT entries",
            ],
            disadvantages=[
                "Complex payload crafting",
                "Multiple interactions often needed",
                "Full RELRO blocks GOT overwrite",
            ],
            steps=[
                "Find format string offset (AAAA%p%p%p...)",
                "Leak values: stack canary, libc, PIE base",
                "Craft write payload using %n",
                "Overwrite GOT entry or return address",
            ],
            notes=[
                "Use pwntools fmtstr_payload() for writes",
                "%<offset>$p for reading specific stack position",
                "%<offset>$n for writing to address on stack",
            ],
        )

    def _add_warnings(self, report: StrategyReport):
        """Add warnings based on protections."""
        prots = self.binary.protections

        if prots.canary:
            report.warnings.append(
                "Stack canary enabled - need canary leak or find function without canary"
            )
        if prots.pie:
            report.warnings.append(
                "PIE enabled - need address leak before ROP"
            )
        if prots.relro == "full":
            report.warnings.append(
                "Full RELRO - GOT overwrite not possible, ret2dlresolve blocked"
            )
        if prots.nx and self._is_static and not self._has_syscall:
            report.warnings.append(
                "Static binary with NX but no syscall gadget found - limited options"
            )

    def _add_notes(self, report: StrategyReport):
        """Add general notes based on analysis."""
        prots = self.binary.protections

        if not prots.pie:
            report.notes.append("No PIE: Binary addresses are fixed, no leak needed")
        if not prots.canary:
            report.notes.append("No canary: Buffer overflow exploitation is straightforward")
        if self._is_static:
            report.notes.append("Static binary: All code in binary, no external libc")
        if report.has_binsh:
            report.notes.append(f"Found '/bin/sh' string @ 0x{report.binsh_addr:x}")
        if report.has_win_function:
            report.notes.append(f"Found win function @ 0x{report.win_function_addr:x}")


def suggest_strategies(binary: "Binary", gadget_finder: Optional["GadgetFinder"] = None) -> StrategyReport:
    """Convenience function to suggest exploit strategies."""
    suggester = StrategySuggester(binary, gadget_finder)
    return suggester.analyze()
