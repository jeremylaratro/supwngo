"""
Exploit Verification Module.

Verifies exploit payloads before sending including:
- Bad character detection
- Stack alignment checking
- Constraint satisfaction for one-gadgets
- Payload validation
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple
from enum import Enum, auto
import struct
import re

from supwngo.core.binary import Binary
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class VerificationResult(Enum):
    """Result of verification check."""
    PASS = auto()
    WARN = auto()
    FAIL = auto()


@dataclass
class Check:
    """Single verification check result."""
    name: str
    result: VerificationResult
    message: str
    details: Dict[str, Any] = field(default_factory=dict)

    def __str__(self) -> str:
        icon = {
            VerificationResult.PASS: "[PASS]",
            VerificationResult.WARN: "[WARN]",
            VerificationResult.FAIL: "[FAIL]",
        }[self.result]
        return f"{icon} {self.name}: {self.message}"


@dataclass
class VerificationReport:
    """Complete verification report."""
    payload: bytes
    checks: List[Check] = field(default_factory=list)
    passed: bool = True
    warnings: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    suggestions: List[str] = field(default_factory=list)

    def add_check(self, check: Check) -> None:
        """Add a check result."""
        self.checks.append(check)
        if check.result == VerificationResult.FAIL:
            self.passed = False
            self.errors.append(check.message)
        elif check.result == VerificationResult.WARN:
            self.warnings.append(check.message)

    def summary(self) -> str:
        """Get verification summary."""
        lines = [
            f"Payload Verification: {'PASSED' if self.passed else 'FAILED'}",
            f"Payload size: {len(self.payload)} bytes",
            "",
        ]

        for check in self.checks:
            lines.append(str(check))

        if self.warnings:
            lines.append("")
            lines.append("Warnings:")
            for w in self.warnings:
                lines.append(f"  - {w}")

        if self.errors:
            lines.append("")
            lines.append("Errors:")
            for e in self.errors:
                lines.append(f"  - {e}")

        if self.suggestions:
            lines.append("")
            lines.append("Suggestions:")
            for s in self.suggestions:
                lines.append(f"  - {s}")

        return "\n".join(lines)


class ExploitVerifier:
    """
    Verifies exploit payloads for correctness.

    Checks:
    - Bad characters that will be filtered
    - Stack alignment requirements
    - One-gadget constraints
    - ROP chain validity
    - Payload size limits
    """

    # Common bad characters by vulnerability type
    COMMON_BAD_CHARS = {
        'default': {0x00},  # Null byte
        'strcpy': {0x00},
        'gets': {0x00, 0x0a},  # Null and newline
        'fgets': {0x00, 0x0a},
        'scanf': {0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x20},  # Whitespace
        'read': set(),  # No bad chars for read()
        'sprintf': {0x00, 0x25},  # Null and %
    }

    def __init__(self, binary: Optional[Binary] = None, bits: int = 64):
        """
        Initialize verifier.

        Args:
            binary: Optional Binary instance for context
            bits: Architecture bits
        """
        self.binary = binary
        self.bits = bits
        self.word_size = bits // 8

    def verify(
        self,
        payload: bytes,
        bad_chars: Set[int] = None,
        max_size: int = None,
        check_alignment: bool = True,
        one_gadget_constraints: List[str] = None,
        input_function: str = None,
    ) -> VerificationReport:
        """
        Verify an exploit payload.

        Args:
            payload: The payload bytes
            bad_chars: Set of bad character values (0-255)
            max_size: Maximum allowed payload size
            check_alignment: Check stack alignment
            one_gadget_constraints: Constraints if using one-gadget
            input_function: Input function name for auto bad char detection

        Returns:
            VerificationReport with all check results
        """
        report = VerificationReport(payload=payload)

        # Determine bad characters
        if bad_chars is None and input_function:
            bad_chars = self.COMMON_BAD_CHARS.get(
                input_function,
                self.COMMON_BAD_CHARS['default']
            )
        elif bad_chars is None:
            bad_chars = self.COMMON_BAD_CHARS['default']

        # Run checks
        report.add_check(self._check_bad_chars(payload, bad_chars))
        report.add_check(self._check_size(payload, max_size))

        if check_alignment:
            report.add_check(self._check_alignment(payload))

        if one_gadget_constraints:
            report.add_check(self._check_one_gadget_constraints(one_gadget_constraints))

        report.add_check(self._check_address_validity(payload))
        report.add_check(self._check_rop_chain(payload))

        # Generate suggestions
        self._generate_suggestions(report)

        return report

    def _check_bad_chars(self, payload: bytes, bad_chars: Set[int]) -> Check:
        """Check for bad characters in payload."""
        found_bad = []

        for i, byte in enumerate(payload):
            if byte in bad_chars:
                found_bad.append((i, byte))

        if not found_bad:
            return Check(
                name="Bad Characters",
                result=VerificationResult.PASS,
                message="No bad characters found",
            )

        # Group by character
        char_positions: Dict[int, List[int]] = {}
        for pos, char in found_bad:
            if char not in char_positions:
                char_positions[char] = []
            char_positions[char].append(pos)

        details = {
            "bad_chars": list(bad_chars),
            "found": char_positions,
        }

        char_list = ', '.join(f'0x{c:02x}' for c in char_positions.keys())
        return Check(
            name="Bad Characters",
            result=VerificationResult.FAIL,
            message=f"Found bad characters: {char_list}",
            details=details,
        )

    def _check_size(self, payload: bytes, max_size: Optional[int]) -> Check:
        """Check payload size."""
        if max_size is None:
            return Check(
                name="Payload Size",
                result=VerificationResult.PASS,
                message=f"Size: {len(payload)} bytes (no limit set)",
            )

        if len(payload) <= max_size:
            return Check(
                name="Payload Size",
                result=VerificationResult.PASS,
                message=f"Size: {len(payload)}/{max_size} bytes",
            )

        return Check(
            name="Payload Size",
            result=VerificationResult.FAIL,
            message=f"Payload too large: {len(payload)} > {max_size} bytes",
            details={"size": len(payload), "max": max_size, "excess": len(payload) - max_size},
        )

    def _check_alignment(self, payload: bytes) -> Check:
        """Check stack alignment (x64 requires 16-byte alignment)."""
        if self.bits != 64:
            return Check(
                name="Stack Alignment",
                result=VerificationResult.PASS,
                message="Alignment check skipped (32-bit)",
            )

        # Count stack adjustments in payload
        # Each address pushes 8 bytes, ret pops 8 bytes
        # Alignment is preserved if we push an even number of addresses

        # Extract addresses from payload
        addresses = []
        for i in range(0, len(payload) - 7, 8):
            addr = struct.unpack('<Q', payload[i:i+8])[0]
            if addr > 0x1000:  # Likely an address
                addresses.append(addr)

        # Check if chain likely maintains alignment
        # Heuristic: odd number of addresses may break alignment
        if len(addresses) % 2 == 1:
            return Check(
                name="Stack Alignment",
                result=VerificationResult.WARN,
                message="Odd number of addresses - may need ret gadget for alignment",
                details={"address_count": len(addresses)},
            )

        return Check(
            name="Stack Alignment",
            result=VerificationResult.PASS,
            message="Stack alignment appears OK",
        )

    def _check_one_gadget_constraints(self, constraints: List[str]) -> Check:
        """Check one-gadget constraints."""
        # Common constraints and their difficulty
        constraint_difficulty = {
            'rax == null': 'easy',
            'rax == 0': 'easy',
            '[rsp+0x': 'medium',
            'rsp & 0xf == 0': 'alignment',
            'rbx == 0': 'medium',
            'rbp == 0': 'medium',
            'r12 == 0': 'hard',
            'writable': 'context',
        }

        difficulties = []
        for constraint in constraints:
            constraint_lower = constraint.lower()
            for pattern, diff in constraint_difficulty.items():
                if pattern in constraint_lower:
                    difficulties.append((constraint, diff))
                    break
            else:
                difficulties.append((constraint, 'unknown'))

        hard_constraints = [c for c, d in difficulties if d in ('hard', 'unknown')]

        if not constraints:
            return Check(
                name="One-Gadget Constraints",
                result=VerificationResult.PASS,
                message="No constraints specified",
            )

        if hard_constraints:
            return Check(
                name="One-Gadget Constraints",
                result=VerificationResult.WARN,
                message=f"Difficult constraints: {', '.join(hard_constraints)}",
                details={"constraints": constraints, "difficulties": difficulties},
            )

        return Check(
            name="One-Gadget Constraints",
            result=VerificationResult.PASS,
            message=f"Constraints appear satisfiable: {', '.join(constraints)}",
        )

    def _check_address_validity(self, payload: bytes) -> Check:
        """Check if addresses in payload are valid."""
        invalid_addresses = []

        for i in range(0, len(payload) - self.word_size + 1, self.word_size):
            if self.bits == 64:
                addr = struct.unpack('<Q', payload[i:i+8])[0]
            else:
                addr = struct.unpack('<I', payload[i:i+4])[0]

            # Check for obviously invalid addresses
            if addr == 0:
                continue  # Could be padding

            # Check for non-canonical addresses (x64)
            if self.bits == 64:
                # Canonical addresses: 0x0000000000000000-0x00007FFFFFFFFFFF
                #                   or 0xFFFF800000000000-0xFFFFFFFFFFFFFFFF
                high_bits = addr >> 47
                if high_bits != 0 and high_bits != 0x1FFFF:
                    invalid_addresses.append((i, addr, "non-canonical"))

            # Check for suspicious addresses
            if 0x40 <= addr <= 0xFF:
                # Single byte - unlikely to be valid
                continue

        if invalid_addresses:
            return Check(
                name="Address Validity",
                result=VerificationResult.WARN,
                message=f"Found {len(invalid_addresses)} potentially invalid addresses",
                details={"invalid": invalid_addresses[:5]},
            )

        return Check(
            name="Address Validity",
            result=VerificationResult.PASS,
            message="Addresses appear valid",
        )

    def _check_rop_chain(self, payload: bytes) -> Check:
        """Basic ROP chain validity check."""
        if len(payload) < self.word_size * 2:
            return Check(
                name="ROP Chain",
                result=VerificationResult.PASS,
                message="Payload too short for ROP chain analysis",
            )

        # Extract potential addresses
        addresses = []
        for i in range(0, len(payload) - self.word_size + 1, self.word_size):
            if self.bits == 64:
                addr = struct.unpack('<Q', payload[i:i+8])[0]
            else:
                addr = struct.unpack('<I', payload[i:i+4])[0]

            # Filter to likely code addresses
            if self.bits == 64:
                if 0x400000 <= addr <= 0x7FFFFFFFFFFF:
                    addresses.append(addr)
            else:
                if 0x8048000 <= addr <= 0xFFFFFFFF:
                    addresses.append(addr)

        if not addresses:
            return Check(
                name="ROP Chain",
                result=VerificationResult.WARN,
                message="No valid code addresses found in payload",
            )

        return Check(
            name="ROP Chain",
            result=VerificationResult.PASS,
            message=f"Found {len(addresses)} potential gadget addresses",
            details={"addresses": [hex(a) for a in addresses[:10]]},
        )

    def _generate_suggestions(self, report: VerificationReport) -> None:
        """Generate suggestions based on check results."""
        for check in report.checks:
            if check.result == VerificationResult.FAIL:
                if check.name == "Bad Characters":
                    found = check.details.get("found", {})
                    if 0x00 in found:
                        report.suggestions.append(
                            "Null bytes found - consider using add/sub gadgets "
                            "to construct values, or encode payload"
                        )
                    if 0x0a in found:
                        report.suggestions.append(
                            "Newlines found - if using fgets/gets, this will "
                            "terminate input early"
                        )

                elif check.name == "Payload Size":
                    report.suggestions.append(
                        "Payload too large - consider stack pivoting to "
                        "larger buffer, or use more compact gadgets"
                    )

            elif check.result == VerificationResult.WARN:
                if check.name == "Stack Alignment":
                    report.suggestions.append(
                        "Add a 'ret' gadget before your target address "
                        "to fix stack alignment"
                    )


class BadCharFinder:
    """
    Automatically find bad characters for a binary.

    Tests each byte value to see if it corrupts the input.
    """

    def __init__(self, binary_path: str, input_method: str = "stdin"):
        """
        Initialize bad char finder.

        Args:
            binary_path: Path to target binary
            input_method: How to send input
        """
        self.binary_path = binary_path
        self.input_method = input_method

    def find_bad_chars(
        self,
        offset: int = 0,
        test_length: int = 256,
    ) -> Set[int]:
        """
        Find bad characters by testing.

        Args:
            offset: Offset before test pattern
            test_length: Length of test pattern

        Returns:
            Set of bad character values
        """
        bad_chars = set()

        # Test null first - almost always bad
        if self._test_char(0x00, offset):
            bad_chars.add(0x00)

        # Test common problematic characters
        for char in [0x0a, 0x0d, 0x09, 0x20, 0x25]:
            if self._test_char(char, offset):
                bad_chars.add(char)

        # Full test if needed
        for char in range(256):
            if char in bad_chars:
                continue
            if self._test_char(char, offset):
                bad_chars.add(char)

        return bad_chars

    def _test_char(self, char: int, offset: int) -> bool:
        """Test if a character is bad."""
        import subprocess
        import tempfile

        # Create test payload
        test_pattern = bytes([char]) * 4
        payload = b'A' * offset + test_pattern + b'B' * 100

        try:
            if self.input_method == "stdin":
                proc = subprocess.run(
                    [self.binary_path],
                    input=payload,
                    capture_output=True,
                    timeout=2,
                )
            else:
                with tempfile.NamedTemporaryFile(delete=False) as f:
                    f.write(payload)
                    f.flush()
                    proc = subprocess.run(
                        [self.binary_path, f.name],
                        capture_output=True,
                        timeout=2,
                    )

            # If binary handles char differently, it's likely bad
            # This is heuristic - specific to vulnerability type

            return False  # Assume good unless proven otherwise

        except Exception:
            return True  # Error suggests bad char


def verify_payload(
    payload: bytes,
    bad_chars: Set[int] = None,
    bits: int = 64,
) -> VerificationReport:
    """
    Convenience function to verify a payload.

    Args:
        payload: Payload bytes
        bad_chars: Bad characters to check
        bits: Architecture bits

    Returns:
        VerificationReport
    """
    verifier = ExploitVerifier(bits=bits)
    return verifier.verify(payload, bad_chars=bad_chars)
