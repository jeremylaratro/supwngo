"""
Exploit testing and verification framework.

Automatically tests generated exploits in isolated environments
to verify they work before deployment.
"""

import os
import shutil
import subprocess
import tempfile
import time
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Tuple

from supwngo.core.binary import Binary
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)

# Try to import docker
try:
    import docker
    DOCKER_AVAILABLE = True
except ImportError:
    DOCKER_AVAILABLE = False


class TestResult(Enum):
    """Result of exploit testing."""
    SUCCESS = auto()        # Got shell or flag
    PARTIAL = auto()        # Some progress but didn't complete
    CRASH = auto()          # Target crashed (might still be useful)
    TIMEOUT = auto()        # No response in time
    ERROR = auto()          # Test infrastructure error
    FAILED = auto()         # Exploit definitely didn't work


class TestEnvironment(Enum):
    """Environment for testing."""
    LOCAL = auto()          # Run locally
    DOCKER = auto()         # Run in Docker container
    QEMU = auto()           # Run in QEMU VM
    REMOTE = auto()         # Test against remote target


@dataclass
class ExploitTestResult:
    """Detailed result of exploit test."""
    result: TestResult
    duration: float                  # Time taken in seconds
    stdout: str = ""
    stderr: str = ""
    exit_code: Optional[int] = None
    shell_obtained: bool = False
    flag_captured: Optional[str] = None
    crash_info: Optional[Dict[str, Any]] = None
    error_message: str = ""

    def __str__(self) -> str:
        status = "SUCCESS" if self.result == TestResult.SUCCESS else self.result.name
        details = []
        if self.shell_obtained:
            details.append("shell obtained")
        if self.flag_captured:
            details.append(f"flag: {self.flag_captured}")
        if self.error_message:
            details.append(f"error: {self.error_message}")

        detail_str = f" ({', '.join(details)})" if details else ""
        return f"[{status}] {self.duration:.2f}s{detail_str}"


@dataclass
class TestConfig:
    """Configuration for exploit testing."""
    timeout: int = 30                      # Seconds
    environment: TestEnvironment = TestEnvironment.LOCAL
    docker_image: str = "ubuntu:20.04"     # For Docker testing
    libc_version: Optional[str] = None     # Specific libc version
    flag_pattern: str = r"(flag\{[^}]+\}|CTF\{[^}]+\})"  # Regex for flag
    success_indicators: List[str] = field(default_factory=lambda: [
        "flag{", "CTF{", "got shell", "id=0(root)", "uid=0"
    ])
    working_dir: Optional[str] = None      # Working directory for test
    env_vars: Dict[str, str] = field(default_factory=dict)


class ExploitTester:
    """
    Test exploits in isolated environments.

    Supports:
    - Local testing with timeout
    - Docker container testing (specific libc versions)
    - Remote target testing

    Example:
        tester = ExploitTester(binary)

        # Test locally
        result = tester.test_local(exploit_script)

        # Test in Docker with specific libc
        result = tester.test_docker(exploit_script, libc="2.31")

        # Test against remote
        result = tester.test_remote(exploit_script, "host", 1337)
    """

    def __init__(self, binary: Binary, config: Optional[TestConfig] = None):
        """
        Initialize tester.

        Args:
            binary: Target binary
            config: Test configuration
        """
        self.binary = binary
        self.config = config or TestConfig()

        # Initialize Docker client if available
        self._docker = None
        if DOCKER_AVAILABLE:
            try:
                self._docker = docker.from_env()
            except Exception as e:
                logger.debug(f"Docker not available: {e}")

    def test_local(
        self,
        exploit_script: str,
        timeout: Optional[int] = None
    ) -> ExploitTestResult:
        """
        Test exploit script locally.

        Args:
            exploit_script: Python exploit script content
            timeout: Optional timeout override

        Returns:
            Test result
        """
        timeout = timeout or self.config.timeout

        # Write script to temp file
        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix='.py',
            delete=False
        ) as f:
            f.write(exploit_script)
            script_path = f.name

        start_time = time.time()

        try:
            # Run exploit script
            result = subprocess.run(
                ['python3', script_path],
                capture_output=True,
                timeout=timeout,
                text=True,
                cwd=self.config.working_dir,
                env={**os.environ, **self.config.env_vars}
            )

            duration = time.time() - start_time

            # Analyze output
            stdout = result.stdout
            stderr = result.stderr

            # Check for success indicators
            test_result = TestResult.FAILED
            shell_obtained = False
            flag_captured = None

            combined_output = stdout + stderr

            for indicator in self.config.success_indicators:
                if indicator.lower() in combined_output.lower():
                    test_result = TestResult.SUCCESS
                    # Check for shell indicators (root access, shell prompt, etc.)
                    shell_patterns = ["shell", "uid=0", "id=0", "root"]
                    if any(p in indicator.lower() for p in shell_patterns):
                        shell_obtained = True
                    break

            # Check for flag
            import re
            flag_match = re.search(self.config.flag_pattern, combined_output)
            if flag_match:
                flag_captured = flag_match.group(1)
                test_result = TestResult.SUCCESS

            # Check exit code
            if result.returncode != 0 and test_result != TestResult.SUCCESS:
                if "segfault" in combined_output.lower() or "sigsegv" in combined_output.lower():
                    test_result = TestResult.CRASH

            return ExploitTestResult(
                result=test_result,
                duration=duration,
                stdout=stdout,
                stderr=stderr,
                exit_code=result.returncode,
                shell_obtained=shell_obtained,
                flag_captured=flag_captured
            )

        except subprocess.TimeoutExpired:
            return ExploitTestResult(
                result=TestResult.TIMEOUT,
                duration=timeout,
                error_message="Process timed out"
            )

        except Exception as e:
            return ExploitTestResult(
                result=TestResult.ERROR,
                duration=time.time() - start_time,
                error_message=str(e)
            )

        finally:
            # Cleanup
            try:
                os.unlink(script_path)
            except:
                pass

    def test_docker(
        self,
        exploit_script: str,
        libc_version: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> ExploitTestResult:
        """
        Test exploit in Docker container with specific libc.

        Args:
            exploit_script: Python exploit script content
            libc_version: Libc version (e.g., "2.27", "2.31", "2.35")
            timeout: Optional timeout override

        Returns:
            Test result
        """
        if not DOCKER_AVAILABLE or self._docker is None:
            return ExploitTestResult(
                result=TestResult.ERROR,
                duration=0,
                error_message="Docker not available"
            )

        timeout = timeout or self.config.timeout
        libc_version = libc_version or self.config.libc_version or "2.31"

        # Select appropriate Ubuntu version for libc
        ubuntu_versions = {
            "2.27": "18.04",
            "2.31": "20.04",
            "2.35": "22.04",
            "2.38": "24.04",
        }
        ubuntu_version = ubuntu_versions.get(libc_version, "20.04")

        start_time = time.time()

        try:
            # Create temp directory with files
            with tempfile.TemporaryDirectory() as tmpdir:
                # Copy binary
                binary_dest = os.path.join(tmpdir, "binary")
                shutil.copy(self.binary.path, binary_dest)
                os.chmod(binary_dest, 0o755)

                # Write exploit script
                script_path = os.path.join(tmpdir, "exploit.py")
                with open(script_path, 'w') as f:
                    # Modify script to use local binary path
                    modified_script = exploit_script.replace(
                        self.binary.path,
                        "/challenge/binary"
                    )
                    f.write(modified_script)

                # Create Dockerfile
                dockerfile = f"""
FROM ubuntu:{ubuntu_version}
RUN apt-get update && apt-get install -y python3 python3-pip
RUN pip3 install pwntools
COPY binary /challenge/binary
COPY exploit.py /exploit.py
RUN chmod +x /challenge/binary
CMD ["python3", "/exploit.py"]
"""
                dockerfile_path = os.path.join(tmpdir, "Dockerfile")
                with open(dockerfile_path, 'w') as f:
                    f.write(dockerfile)

                # Build image
                image_tag = f"supwngo-test:{int(time.time())}"
                self._docker.images.build(
                    path=tmpdir,
                    tag=image_tag,
                    rm=True
                )

                # Run container
                container = self._docker.containers.run(
                    image_tag,
                    detach=True,
                    remove=False
                )

                # Wait for completion
                try:
                    exit_code = container.wait(timeout=timeout)['StatusCode']
                    logs = container.logs().decode('utf-8')
                finally:
                    container.remove(force=True)

                # Cleanup image
                try:
                    self._docker.images.remove(image_tag, force=True)
                except:
                    pass

                duration = time.time() - start_time

                # Analyze output
                test_result = TestResult.FAILED
                shell_obtained = False
                flag_captured = None

                for indicator in self.config.success_indicators:
                    if indicator.lower() in logs.lower():
                        test_result = TestResult.SUCCESS
                        # Check for shell indicators (root access, shell prompt, etc.)
                        shell_patterns = ["shell", "uid=0", "id=0", "root"]
                        if any(p in indicator.lower() for p in shell_patterns):
                            shell_obtained = True
                        break

                import re
                flag_match = re.search(self.config.flag_pattern, logs)
                if flag_match:
                    flag_captured = flag_match.group(1)
                    test_result = TestResult.SUCCESS

                return ExploitTestResult(
                    result=test_result,
                    duration=duration,
                    stdout=logs,
                    exit_code=exit_code,
                    shell_obtained=shell_obtained,
                    flag_captured=flag_captured
                )

        except Exception as e:
            return ExploitTestResult(
                result=TestResult.ERROR,
                duration=time.time() - start_time,
                error_message=str(e)
            )

    def test_remote(
        self,
        exploit_script: str,
        host: str,
        port: int,
        timeout: Optional[int] = None
    ) -> ExploitTestResult:
        """
        Test exploit against remote target.

        Args:
            exploit_script: Python exploit script content
            host: Remote host
            port: Remote port
            timeout: Optional timeout override

        Returns:
            Test result
        """
        timeout = timeout or self.config.timeout

        # Modify script to use remote connection
        # Replace process() with remote()
        modified_script = self._convert_to_remote(exploit_script, host, port)

        # Test it
        return self.test_local(modified_script, timeout)

    def _convert_to_remote(
        self,
        script: str,
        host: str,
        port: int
    ) -> str:
        """Convert local exploit script to remote."""
        import re

        # Replace process() calls with remote()
        # Handle various patterns
        patterns = [
            (r'process\([\'"]([^\'"]+)[\'"]\)', f'remote("{host}", {port})'),
            (r'process\(([^)]+)\)', f'remote("{host}", {port})'),
            (r'p = process', f'p = remote("{host}", {port})  # was process'),
        ]

        modified = script
        for pattern, replacement in patterns:
            modified = re.sub(pattern, replacement, modified)

        return modified

    def verify_payload(
        self,
        payload: bytes,
        expected_crash: bool = True
    ) -> ExploitTestResult:
        """
        Verify a payload causes expected behavior.

        Args:
            payload: Raw payload bytes
            expected_crash: Whether crash is expected

        Returns:
            Test result
        """
        # Create minimal test script
        script = f"""
from pwn import *
import sys

context.log_level = 'error'

p = process('{self.binary.path}')
p.send({repr(payload)})

try:
    p.recv(timeout=2)
    p.interactive()
except:
    pass
finally:
    p.close()
"""
        return self.test_local(script, timeout=5)

    def batch_test(
        self,
        exploits: List[Tuple[str, str]],  # (name, script)
        environment: TestEnvironment = TestEnvironment.LOCAL
    ) -> Dict[str, ExploitTestResult]:
        """
        Test multiple exploits and return results.

        Args:
            exploits: List of (name, script) tuples
            environment: Test environment

        Returns:
            Dict mapping name to result
        """
        results = {}

        for name, script in exploits:
            logger.info(f"Testing exploit: {name}")

            if environment == TestEnvironment.LOCAL:
                result = self.test_local(script)
            elif environment == TestEnvironment.DOCKER:
                result = self.test_docker(script)
            else:
                result = ExploitTestResult(
                    result=TestResult.ERROR,
                    duration=0,
                    error_message=f"Unsupported environment: {environment}"
                )

            results[name] = result
            logger.info(f"  {name}: {result}")

        return results


class ExploitValidator:
    """
    Validate exploit payloads before sending.

    Checks for:
    - Bad characters
    - Correct alignment
    - Address validity
    - Payload length constraints
    """

    def __init__(self, binary: Binary):
        """
        Initialize validator.

        Args:
            binary: Target binary
        """
        self.binary = binary

    def validate_payload(
        self,
        payload: bytes,
        bad_chars: bytes = b"",
        max_length: Optional[int] = None,
        require_alignment: bool = False,
        alignment: int = 16
    ) -> Tuple[bool, List[str]]:
        """
        Validate a payload.

        Args:
            payload: Payload bytes
            bad_chars: Bytes that shouldn't appear
            max_length: Maximum allowed length
            require_alignment: Whether alignment is required
            alignment: Required alignment

        Returns:
            Tuple of (is_valid, list of issues)
        """
        issues = []

        # Check length
        if max_length and len(payload) > max_length:
            issues.append(f"Payload too long: {len(payload)} > {max_length}")

        # Check bad characters
        for i, byte in enumerate(payload):
            if byte in bad_chars:
                issues.append(f"Bad char 0x{byte:02x} at offset {i}")

        # Check alignment
        if require_alignment:
            # Check that addresses in payload are aligned
            # This is simplified - real implementation would parse payload structure
            pass

        # Check for null terminators in middle (if null is bad char)
        if b'\x00' in bad_chars:
            null_pos = payload.find(b'\x00')
            if null_pos != -1 and null_pos < len(payload) - 8:
                issues.append(f"Null byte at offset {null_pos} may truncate payload")

        return len(issues) == 0, issues

    def check_addresses(
        self,
        addresses: List[int],
        bad_chars: bytes = b""
    ) -> Tuple[bool, List[str]]:
        """
        Check if addresses are valid and don't contain bad chars.

        Args:
            addresses: List of addresses to check
            bad_chars: Bad characters to avoid

        Returns:
            Tuple of (all_valid, list of issues)
        """
        issues = []
        bits = self.binary.bits
        pack_func = lambda x: x.to_bytes(bits // 8, 'little')

        for addr in addresses:
            addr_bytes = pack_func(addr)

            # Check for bad chars
            for i, byte in enumerate(addr_bytes):
                if byte in bad_chars:
                    issues.append(
                        f"Address 0x{addr:x} contains bad char 0x{byte:02x} at byte {i}"
                    )

        return len(issues) == 0, issues


# Convenience functions

def test_exploit(
    binary: Binary,
    exploit_script: str,
    environment: str = "local",
    **kwargs
) -> ExploitTestResult:
    """
    Test an exploit script.

    Args:
        binary: Target binary
        exploit_script: Python exploit script
        environment: "local", "docker", or "remote"
        **kwargs: Additional arguments (host, port for remote; libc for docker)

    Returns:
        Test result
    """
    tester = ExploitTester(binary)

    if environment == "local":
        return tester.test_local(exploit_script)
    elif environment == "docker":
        return tester.test_docker(exploit_script, libc_version=kwargs.get("libc"))
    elif environment == "remote":
        return tester.test_remote(
            exploit_script,
            kwargs.get("host", "localhost"),
            kwargs.get("port", 1337)
        )
    else:
        return ExploitTestResult(
            result=TestResult.ERROR,
            duration=0,
            error_message=f"Unknown environment: {environment}"
        )
