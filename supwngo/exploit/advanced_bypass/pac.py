"""
ARM Pointer Authentication Code (PAC) bypass techniques.

PAC adds cryptographic signing to pointers on ARM64, preventing pointer forgery.
Key concepts:
- Each pointer can have a Pointer Authentication Code (PAC) in its upper bits
- PAC is computed from: pointer value, context/modifier, and a secret key
- Different keys for instructions (IA/IB) and data (DA/DB)
- Authentication fails if PAC doesn't match, causing exception

Bypass techniques:
- PAC signing gadgets (sign our own pointers)
- PAC forging via key leaks
- Signing oracles
- Pointer substitution with legitimately signed values
- PAC collision attacks
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Callable, Dict, List, Optional, Set, Tuple

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class PACKey(Enum):
    """PAC key types."""
    IA = auto()  # Instruction key A (code pointers)
    IB = auto()  # Instruction key B (code pointers)
    DA = auto()  # Data key A (data pointers)
    DB = auto()  # Data key B (data pointers)
    GA = auto()  # Generic key A


class PACInstruction(Enum):
    """PAC-related instructions."""
    # Signing
    PACIA = "pacia"    # Sign with IA key
    PACIB = "pacib"    # Sign with IB key
    PACDA = "pacda"    # Sign with DA key
    PACDB = "pacdb"    # Sign with DB key
    PACIZA = "paciza"  # Sign with IA, zero modifier
    PACIZB = "pacizb"  # Sign with IB, zero modifier
    PACDZA = "pacdza"  # Sign with DA, zero modifier
    PACDZB = "pacdzb"  # Sign with DB, zero modifier

    # Authentication
    AUTIA = "autia"    # Authenticate with IA key
    AUTIB = "autib"    # Authenticate with IB key
    AUTDA = "autda"    # Authenticate with DA key
    AUTDB = "autdb"    # Authenticate with DB key
    AUTIZA = "autiza"  # Authenticate with IA, zero modifier
    AUTIZB = "autizb"  # Authenticate with IB, zero modifier
    AUTDZA = "autdza"  # Authenticate with DA, zero modifier
    AUTDZB = "autdzb"  # Authenticate with DB, zero modifier

    # Combined operations
    RETAA = "retaa"    # Return with auth IA
    RETAB = "retab"    # Return with auth IB
    BRAA = "braa"      # Branch with auth IA
    BRAB = "brab"      # Branch with auth IB
    BLRAA = "blraa"    # Branch link with auth IA
    BLRAB = "blrab"    # Branch link with auth IB

    # Stripping
    XPACI = "xpaci"    # Strip PAC (instruction)
    XPACD = "xpacd"    # Strip PAC (data)


@dataclass
class PACInfo:
    """PAC protection analysis results."""
    detected: bool = False

    # Which keys are used
    uses_ia: bool = False
    uses_ib: bool = False
    uses_da: bool = False
    uses_db: bool = False

    # PAC-related instruction locations
    signing_gadgets: List['PACGadget'] = field(default_factory=list)
    auth_gadgets: List['PACGadget'] = field(default_factory=list)
    stripping_gadgets: List['PACGadget'] = field(default_factory=list)

    # Return address protection
    return_pac_enabled: bool = False

    # Function pointer protection
    function_ptr_pac: bool = False

    # Bypass opportunities
    bypass_opportunities: List[str] = field(default_factory=list)


@dataclass
class PACGadget:
    """A PAC-related gadget."""
    address: int
    instruction: PACInstruction
    key_type: PACKey
    uses_modifier: bool  # True if uses context/modifier
    following_instructions: List[str] = field(default_factory=list)

    # For signing gadgets: can we control the input?
    input_controllable: bool = False
    input_register: str = ""

    # For auth gadgets: what happens on failure?
    failure_behavior: str = ""  # "trap", "exception", "continue"

    def __str__(self) -> str:
        return (f"PACGadget({self.instruction.value} at {hex(self.address)}, "
                f"key={self.key_type.name})")


@dataclass
class SigningOracle:
    """Oracle that can sign arbitrary pointers."""
    gadget: PACGadget
    method: str
    requirements: List[str] = field(default_factory=list)
    description: str = ""


@dataclass
class PACBypassResult:
    """Result of PAC bypass attempt."""
    success: bool
    technique: str
    signed_ptr: Optional[int] = None
    key_type: Optional[PACKey] = None
    notes: str = ""


class PACAnalyzer:
    """
    Analyze binary for PAC protections and bypass opportunities.

    Example:
        analyzer = PACAnalyzer(binary)
        info = analyzer.analyze()

        if info.detected:
            print(f"PAC detected")
            print(f"Signing gadgets: {len(info.signing_gadgets)}")
            for gadget in info.signing_gadgets:
                print(f"  {gadget}")
    """

    # Map instruction mnemonics to enum values
    PAC_MNEMONICS = {
        # Signing
        'pacia': (PACInstruction.PACIA, PACKey.IA, True),
        'pacib': (PACInstruction.PACIB, PACKey.IB, True),
        'pacda': (PACInstruction.PACDA, PACKey.DA, True),
        'pacdb': (PACInstruction.PACDB, PACKey.DB, True),
        'paciza': (PACInstruction.PACIZA, PACKey.IA, False),
        'pacizb': (PACInstruction.PACIZB, PACKey.IB, False),
        'pacdza': (PACInstruction.PACDZA, PACKey.DA, False),
        'pacdzb': (PACInstruction.PACDZB, PACKey.DB, False),
        'pacia1716': (PACInstruction.PACIA, PACKey.IA, True),
        'pacib1716': (PACInstruction.PACIB, PACKey.IB, True),
        'paciasp': (PACInstruction.PACIA, PACKey.IA, True),  # SP as modifier
        'pacibsp': (PACInstruction.PACIB, PACKey.IB, True),

        # Authentication
        'autia': (PACInstruction.AUTIA, PACKey.IA, True),
        'autib': (PACInstruction.AUTIB, PACKey.IB, True),
        'autda': (PACInstruction.AUTDA, PACKey.DA, True),
        'autdb': (PACInstruction.AUTDB, PACKey.DB, True),
        'autiza': (PACInstruction.AUTIZA, PACKey.IA, False),
        'autizb': (PACInstruction.AUTIZB, PACKey.IB, False),
        'autdza': (PACInstruction.AUTDZA, PACKey.DA, False),
        'autdzb': (PACInstruction.AUTDZB, PACKey.DB, False),
        'autia1716': (PACInstruction.AUTIA, PACKey.IA, True),
        'autib1716': (PACInstruction.AUTIB, PACKey.IB, True),
        'autiasp': (PACInstruction.AUTIA, PACKey.IA, True),
        'autibsp': (PACInstruction.AUTIB, PACKey.IB, True),

        # Combined
        'retaa': (PACInstruction.RETAA, PACKey.IA, True),
        'retab': (PACInstruction.RETAB, PACKey.IB, True),
        'braa': (PACInstruction.BRAA, PACKey.IA, True),
        'brab': (PACInstruction.BRAB, PACKey.IB, True),
        'blraa': (PACInstruction.BLRAA, PACKey.IA, True),
        'blrab': (PACInstruction.BLRAB, PACKey.IB, True),

        # Stripping
        'xpaci': (PACInstruction.XPACI, PACKey.IA, False),
        'xpacd': (PACInstruction.XPACD, PACKey.DA, False),
    }

    def __init__(self, binary: Any):
        """
        Initialize PAC analyzer.

        Args:
            binary: Target binary (supwngo Binary object)
        """
        self.binary = binary
        self._elf = getattr(binary, 'elf', None)

    def analyze(self) -> PACInfo:
        """
        Perform comprehensive PAC analysis.

        Returns:
            PACInfo with complete analysis results
        """
        info = PACInfo()

        # Check if ARM64
        if not self._is_arm64():
            return info

        # Find PAC instructions
        pac_instructions = self._find_pac_instructions()

        info.detected = len(pac_instructions) > 0

        if not info.detected:
            logger.info("No PAC protection detected")
            return info

        logger.info(f"Detected PAC with {len(pac_instructions)} related instructions")

        # Categorize gadgets
        for addr, insn_name, following in pac_instructions:
            if insn_name not in self.PAC_MNEMONICS:
                continue

            pac_insn, key_type, uses_mod = self.PAC_MNEMONICS[insn_name]

            gadget = PACGadget(
                address=addr,
                instruction=pac_insn,
                key_type=key_type,
                uses_modifier=uses_mod,
                following_instructions=following
            )

            # Update key usage
            if key_type == PACKey.IA:
                info.uses_ia = True
            elif key_type == PACKey.IB:
                info.uses_ib = True
            elif key_type == PACKey.DA:
                info.uses_da = True
            elif key_type == PACKey.DB:
                info.uses_db = True

            # Categorize gadget
            if insn_name.startswith('pac'):
                info.signing_gadgets.append(gadget)
            elif insn_name.startswith('aut') or insn_name.startswith('ret') or insn_name.startswith('br'):
                info.auth_gadgets.append(gadget)
            elif insn_name.startswith('xpac'):
                info.stripping_gadgets.append(gadget)

        # Check return address protection
        info.return_pac_enabled = any(
            g.instruction in [PACInstruction.RETAA, PACInstruction.RETAB]
            for g in info.auth_gadgets
        )

        # Check function pointer protection
        info.function_ptr_pac = any(
            g.instruction in [PACInstruction.BRAA, PACInstruction.BRAB,
                             PACInstruction.BLRAA, PACInstruction.BLRAB]
            for g in info.auth_gadgets
        )

        # Identify bypass opportunities
        info.bypass_opportunities = self._identify_bypasses(info)

        return info

    def _is_arm64(self) -> bool:
        """Check if binary is ARM64."""
        if not self._elf:
            return False

        try:
            return self._elf.header.e_machine == 'EM_AARCH64'
        except Exception:
            return False

    def _find_pac_instructions(self) -> List[Tuple[int, str, List[str]]]:
        """Find all PAC-related instructions."""
        instructions = []

        if not self._elf:
            return instructions

        try:
            from capstone import Cs, CS_ARCH_ARM64, CS_MODE_ARM

            md = Cs(CS_ARCH_ARM64, CS_MODE_ARM)

            for section in self._elf.iter_sections():
                if not hasattr(section, 'name') or section.name != '.text':
                    continue

                data = section.data()
                section_addr = section['sh_addr']

                all_insns = list(md.disasm(data, section_addr))

                for i, insn in enumerate(all_insns):
                    if insn.mnemonic.lower() in self.PAC_MNEMONICS:
                        # Get following instructions
                        following = [
                            f"{all_insns[j].mnemonic} {all_insns[j].op_str}"
                            for j in range(i + 1, min(i + 6, len(all_insns)))
                        ]
                        instructions.append((insn.address, insn.mnemonic.lower(), following))

        except ImportError:
            logger.warning("Capstone not available for PAC analysis")
        except Exception as e:
            logger.debug(f"Error finding PAC instructions: {e}")

        return instructions

    def _identify_bypasses(self, info: PACInfo) -> List[str]:
        """Identify PAC bypass opportunities."""
        bypasses = []

        # Signing gadgets
        if info.signing_gadgets:
            bypasses.append(
                f"Signing gadgets available ({len(info.signing_gadgets)} found)"
            )

        # Stripping gadgets
        if info.stripping_gadgets:
            bypasses.append(
                f"PAC stripping gadgets ({len(info.stripping_gadgets)} found)"
            )

        # Zero modifier gadgets (easier to exploit)
        zero_mod_gadgets = [
            g for g in info.signing_gadgets if not g.uses_modifier
        ]
        if zero_mod_gadgets:
            bypasses.append(
                f"Zero-modifier signing gadgets ({len(zero_mod_gadgets)} found)"
            )

        # Pointer substitution
        bypasses.append("Pointer substitution with legitimately signed values")

        # Key reuse across contexts
        if info.uses_ia and info.uses_ib:
            bypasses.append("Multiple keys in use - potential key confusion")

        return bypasses


class PACBypass:
    """
    PAC bypass techniques and exploitation.

    Example:
        bypass = PACBypass(binary, pac_info)

        # Find signing oracle
        oracle = bypass.find_signing_oracle()

        if oracle:
            # Sign arbitrary pointer
            signed = bypass.sign_pointer(oracle, target_addr, modifier)

        # Find pointer substitution candidates
        candidates = bypass.find_substitution_candidates(target_addr)
    """

    # PAC bits location (top 16 bits, minus sign extension)
    PAC_MASK = 0x007F_FFFF_FFFF_FFFF  # Address portion
    PAC_SHIFT = 47  # PAC starts at bit 47

    def __init__(self, binary: Any, pac_info: Optional[PACInfo] = None):
        """
        Initialize PAC bypass.

        Args:
            binary: Target binary
            pac_info: Pre-computed PAC analysis (or will analyze)
        """
        self.binary = binary
        self.pac_info = pac_info or PACAnalyzer(binary).analyze()
        self._elf = getattr(binary, 'elf', None)

    @staticmethod
    def strip_pac(ptr: int) -> int:
        """
        Strip PAC from pointer (software implementation).

        Note: This only works for analyzing pointers, not for
        actually using stripped pointers on PAC-enabled systems.
        """
        # Sign-extend from bit 47
        if ptr & (1 << 47):
            return ptr | ~PACBypass.PAC_MASK
        else:
            return ptr & PACBypass.PAC_MASK

    @staticmethod
    def get_pac_bits(ptr: int) -> int:
        """Extract PAC bits from pointer."""
        return (ptr >> PACBypass.PAC_SHIFT) & 0xFFFF

    def find_signing_oracle(self) -> Optional[SigningOracle]:
        """
        Find a gadget that can sign arbitrary pointers.

        A signing oracle is a code sequence where we can control
        the input to a PAC signing instruction and retrieve the result.

        Returns:
            SigningOracle if found, None otherwise
        """
        for gadget in self.pac_info.signing_gadgets:
            # Check if input is controllable
            controllable, input_reg = self._check_input_controllability(gadget)

            if controllable:
                gadget.input_controllable = True
                gadget.input_register = input_reg

                return SigningOracle(
                    gadget=gadget,
                    method="direct_signing",
                    requirements=[
                        f"Control {input_reg} before reaching gadget",
                        "Ability to call or jump to gadget",
                        "Way to retrieve signed pointer"
                    ],
                    description=(
                        f"Signing gadget at {hex(gadget.address)} can sign "
                        f"arbitrary pointers using {gadget.key_type.name} key"
                    )
                )

        return None

    def _check_input_controllability(
        self,
        gadget: PACGadget
    ) -> Tuple[bool, str]:
        """Check if we can control input to signing gadget."""
        # PAC signing instructions typically use X17 or specified register
        # Check preceding instructions for controllability

        # Simplified: assume we can control if it's a standalone gadget
        # Real implementation would do dataflow analysis

        if gadget.instruction in [PACInstruction.PACIZA, PACInstruction.PACIZB,
                                  PACInstruction.PACDZA, PACInstruction.PACDZB]:
            # Zero modifier - easier to exploit
            return True, "x17"

        return True, "x17"  # Default assumption

    def find_substitution_candidates(
        self,
        target_type: str = "function"
    ) -> List[Tuple[int, str]]:
        """
        Find legitimately signed pointers that could be substituted.

        PAC can be bypassed by reusing already-signed pointers
        if they have the same modifier/context.

        Args:
            target_type: "function" or "data"

        Returns:
            List of (address, description) for candidates
        """
        candidates = []

        if target_type == "function":
            # Look for signed function pointers
            if hasattr(self.binary, 'plt'):
                for name, addr in self.binary.plt.items():
                    candidates.append((addr, f"PLT entry: {name}"))

            # Look for callback tables
            if hasattr(self.binary, 'got'):
                for name, addr in self.binary.got.items():
                    candidates.append((addr, f"GOT callback: {name}"))

        return candidates

    def build_signing_chain(
        self,
        oracle: SigningOracle,
        target_ptr: int,
        modifier: int = 0
    ) -> Optional[bytes]:
        """
        Build ROP/JOP chain to sign a pointer.

        Args:
            oracle: Signing oracle to use
            target_ptr: Pointer to sign
            modifier: Context/modifier value

        Returns:
            Chain bytes or None if not possible
        """
        if not oracle:
            return None

        # This is architecture-specific and complex
        # Return template for manual completion

        chain = bytearray()
        word_size = 8

        # Layout:
        # 1. Set up input register with target pointer
        # 2. Set up modifier register if needed
        # 3. Jump to signing gadget
        # 4. Retrieve signed result

        # Placeholder - real implementation needs gadget chain building
        chain.extend(b"SIGNING_CHAIN_PLACEHOLDER")

        return bytes(chain)

    def exploit_key_confusion(self) -> List[Dict[str, Any]]:
        """
        Find key confusion opportunities.

        If code uses multiple PAC keys inconsistently, we may be
        able to use a pointer signed with one key where another is expected.

        Returns:
            List of key confusion opportunities
        """
        opportunities = []

        if self.pac_info.uses_ia and self.pac_info.uses_ib:
            opportunities.append({
                "confusion": "IA vs IB",
                "description": (
                    "Both instruction keys used. Look for places where "
                    "IA-signed pointer might be accepted by IB check."
                ),
                "exploitation": "Substitute IA-signed ptr for IB, or vice versa"
            })

        if self.pac_info.uses_da and self.pac_info.uses_db:
            opportunities.append({
                "confusion": "DA vs DB",
                "description": (
                    "Both data keys used. Look for data pointer substitution."
                ),
                "exploitation": "Substitute DA-signed ptr for DB, or vice versa"
            })

        return opportunities

    def generate_pac_spray(
        self,
        base_ptr: int,
        count: int = 1000
    ) -> bytes:
        """
        Generate PAC brute force spray.

        Since PAC space is limited, spraying many pointers increases
        chance of collision.

        Args:
            base_ptr: Base pointer value
            count: Number of variants to generate

        Returns:
            Spray data with PAC variants
        """
        spray = bytearray()

        # Generate pointers with different PAC values
        for i in range(count):
            # Vary the PAC bits
            pac_value = i % 0x10000
            variant = (base_ptr & self.PAC_MASK) | (pac_value << self.PAC_SHIFT)
            spray.extend(variant.to_bytes(8, 'little'))

        return bytes(spray)

    def find_pac_forging_primitives(self) -> List[Dict[str, Any]]:
        """
        Find primitives useful for PAC forging.

        To forge PAC without oracle, we need:
        - Key leak
        - Modifier prediction
        - Signing algorithm details

        Returns:
            List of forging primitive opportunities
        """
        primitives = []

        # Check for key exposure
        primitives.append({
            "type": "key_leak",
            "method": "Memory disclosure",
            "description": (
                "PAC keys are stored in system registers. If we can read "
                "arbitrary kernel memory, we might leak keys."
            ),
            "difficulty": "high"
        })

        # Modifier prediction
        primitives.append({
            "type": "modifier_prediction",
            "method": "Context analysis",
            "description": (
                "PAC modifiers are often predictable (SP, return address, etc.). "
                "If modifier is constant or predictable, signed pointer can be reused."
            ),
            "difficulty": "medium"
        })

        # Timing attacks
        primitives.append({
            "type": "timing_oracle",
            "method": "Authentication timing",
            "description": (
                "PAC authentication might have timing differences that leak "
                "information about the expected PAC value."
            ),
            "difficulty": "high"
        })

        return primitives

    def generate_exploit_template(self) -> str:
        """Generate Python exploit template for PAC bypass."""
        template = '''#!/usr/bin/env python3
"""
PAC Bypass Exploit Template
Generated by supwngo

Return PAC: {return_pac}
Function Ptr PAC: {func_ptr_pac}
Keys Used: {keys}
"""

from pwn import *

# Binary info
binary = ELF("{binary_path}")
context.binary = binary
context.arch = "aarch64"

# PAC helper functions
PAC_MASK = 0x007F_FFFF_FFFF_FFFF

def strip_pac(ptr):
    """Strip PAC from pointer (software)."""
    if ptr & (1 << 47):
        return ptr | ~PAC_MASK
    else:
        return ptr & PAC_MASK

def get_pac_bits(ptr):
    """Extract PAC bits from pointer."""
    return (ptr >> 47) & 0xFFFF

{signing_gadgets}

def exploit():
    p = process(binary.path)

    # Strategy: {strategy}
    #
    # 1. If signing gadget available:
    #    - Control input register
    #    - Call signing gadget
    #    - Use signed pointer
    #
    # 2. If pointer substitution:
    #    - Find legitimately signed pointer
    #    - Replace target with it
    #
    # 3. If no bypass:
    #    - Try PAC brute force (impractical)
    #    - Look for key leak

    # Example: Using signing gadget
    # target_ptr = 0x41414141
    # signed_ptr = sign_pointer(target_ptr)  # Call signing gadget

    p.interactive()

if __name__ == "__main__":
    exploit()
'''
        # Build signing gadgets section
        signing_section = ""
        if self.pac_info.signing_gadgets:
            signing_section = "# Signing gadgets found:\\n"
            for g in self.pac_info.signing_gadgets[:5]:
                signing_section += f"# {hex(g.address)}: {g.instruction.value} ({g.key_type.name})\\n"

        keys = []
        if self.pac_info.uses_ia:
            keys.append("IA")
        if self.pac_info.uses_ib:
            keys.append("IB")
        if self.pac_info.uses_da:
            keys.append("DA")
        if self.pac_info.uses_db:
            keys.append("DB")

        strategy = "signing_gadget" if self.pac_info.signing_gadgets else "pointer_substitution"

        return template.format(
            return_pac="Yes" if self.pac_info.return_pac_enabled else "No",
            func_ptr_pac="Yes" if self.pac_info.function_ptr_pac else "No",
            keys=", ".join(keys) if keys else "None detected",
            binary_path=str(self.binary.path) if hasattr(self.binary, 'path') else "./binary",
            signing_gadgets=signing_section,
            strategy=strategy
        )

    def get_bypass_strategies(self) -> List[Dict[str, Any]]:
        """
        Get available PAC bypass strategies.

        Returns:
            List of strategy dictionaries
        """
        strategies = []

        # Signing oracle
        if self.pac_info.signing_gadgets:
            strategies.append({
                "name": "Signing Oracle",
                "technique": "signing_gadget",
                "requirements": [
                    "Control input to signing instruction",
                    "Ability to retrieve signed result"
                ],
                "success_rate": "High if gadget is reachable",
                "gadgets_found": len(self.pac_info.signing_gadgets)
            })

        # Pointer substitution
        strategies.append({
            "name": "Pointer Substitution",
            "technique": "substitution",
            "requirements": [
                "Legitimately signed pointer with same/similar modifier",
                "Context where substituted pointer is valid"
            ],
            "success_rate": "Medium - depends on code patterns"
        })

        # Stripping
        if self.pac_info.stripping_gadgets:
            strategies.append({
                "name": "PAC Stripping",
                "technique": "xpac_gadget",
                "requirements": [
                    "Control over stripping gadget",
                    "Use stripped pointer before re-signing"
                ],
                "success_rate": "Medium",
                "gadgets_found": len(self.pac_info.stripping_gadgets)
            })

        # Key confusion
        if self.pac_info.uses_ia and self.pac_info.uses_ib:
            strategies.append({
                "name": "Key Confusion",
                "technique": "key_confusion",
                "requirements": [
                    "Inconsistent key usage in binary",
                    "Pointer accepted with wrong key"
                ],
                "success_rate": "Low - rare vulnerability"
            })

        return strategies


# Convenience functions
def analyze_pac_protection(binary: Any) -> PACInfo:
    """
    Analyze binary for PAC protections.

    Args:
        binary: Target binary

    Returns:
        PAC analysis results
    """
    analyzer = PACAnalyzer(binary)
    return analyzer.analyze()


def find_pac_bypass(binary: Any) -> Optional[PACBypass]:
    """
    Find PAC bypass opportunities.

    Args:
        binary: Target binary

    Returns:
        PACBypass object if PAC detected, None otherwise
    """
    info = analyze_pac_protection(binary)
    if info.detected:
        return PACBypass(binary, info)
    return None
