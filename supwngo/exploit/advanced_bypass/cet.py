"""
Intel CET (Control-flow Enforcement Technology) bypass techniques.

CET consists of two mechanisms:
1. Shadow Stack (SS) - Protects return addresses
2. Indirect Branch Tracking (IBT) - Requires ENDBR64/32 at indirect targets

This module provides analysis and bypass techniques for CET-protected binaries.

Key bypass techniques:
- Signal handler manipulation
- Exception-based control flow
- JIT-compiled code exploitation
- Shadow stack desynchronization
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Callable, Dict, List, Optional, Set, Tuple

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class CETFeature(Enum):
    """CET features that may be enabled."""
    NONE = auto()
    SHADOW_STACK = auto()           # Shadow stack protection
    IBT = auto()                    # Indirect Branch Tracking
    SHADOW_STACK_AND_IBT = auto()   # Both enabled


@dataclass
class CETInfo:
    """CET protection analysis results."""
    detected: bool = False
    features: CETFeature = CETFeature.NONE

    # Shadow Stack info
    shadow_stack_enabled: bool = False
    shadow_stack_strict: bool = False  # Strict mode (no exceptions)

    # IBT info
    ibt_enabled: bool = False
    endbr_count: int = 0
    valid_ibt_targets: Set[int] = field(default_factory=set)

    # Signal handlers that might be exploitable
    signal_handlers: List[int] = field(default_factory=list)

    # JIT regions (if any)
    jit_regions: List[Tuple[int, int]] = field(default_factory=list)

    # Bypass opportunities
    bypass_opportunities: List[str] = field(default_factory=list)


@dataclass
class SignalBasedBypass:
    """
    Signal-based CET bypass information.

    Signal handlers can modify the shadow stack and return context,
    providing exploitation opportunities.
    """
    signal_number: int
    handler_address: int
    can_corrupt_shadow_stack: bool = False
    can_control_rip: bool = False
    exploitation_notes: str = ""


@dataclass
class IBTBypass:
    """IBT bypass via ENDBR gadgets."""
    address: int
    instruction: str
    gadget_type: str  # "endbr64", "endbr32"
    following_instructions: List[str] = field(default_factory=list)
    useful_for: str = ""  # What this gadget can be used for


@dataclass
class ShadowStackBypass:
    """Shadow stack bypass technique."""
    technique: str
    requirements: List[str] = field(default_factory=list)
    success_rate: str = "unknown"
    description: str = ""


@dataclass
class CETExploitStrategy:
    """Complete CET bypass exploitation strategy."""
    primary_technique: str
    bypasses: List[Any] = field(default_factory=list)
    payload_template: str = ""
    reliability: str = "low"
    notes: str = ""


class CETAnalyzer:
    """
    Analyze binary for CET protections and bypass opportunities.

    Example:
        analyzer = CETAnalyzer(binary)
        info = analyzer.analyze()

        if info.shadow_stack_enabled:
            print("Shadow stack detected!")
            for bypass in info.bypass_opportunities:
                print(f"  Potential bypass: {bypass}")
    """

    # ENDBR instruction opcodes
    ENDBR64_BYTES = bytes([0xf3, 0x0f, 0x1e, 0xfa])
    ENDBR32_BYTES = bytes([0xf3, 0x0f, 0x1e, 0xfb])

    # Signal numbers that might be useful
    USEFUL_SIGNALS = {
        1: "SIGHUP",
        2: "SIGINT",
        6: "SIGABRT",
        8: "SIGFPE",
        11: "SIGSEGV",
        14: "SIGALRM",
        15: "SIGTERM",
    }

    def __init__(self, binary: Any):
        """
        Initialize CET analyzer.

        Args:
            binary: Target binary (supwngo Binary object)
        """
        self.binary = binary
        self._elf = getattr(binary, 'elf', None)

    def analyze(self) -> CETInfo:
        """
        Perform comprehensive CET analysis.

        Returns:
            CETInfo with complete analysis results
        """
        info = CETInfo()

        # Detect CET features
        info.features = self._detect_cet_features()
        info.detected = info.features != CETFeature.NONE

        if info.features in [CETFeature.SHADOW_STACK, CETFeature.SHADOW_STACK_AND_IBT]:
            info.shadow_stack_enabled = True

        if info.features in [CETFeature.IBT, CETFeature.SHADOW_STACK_AND_IBT]:
            info.ibt_enabled = True

        if not info.detected:
            logger.info("No CET protection detected")
            return info

        logger.info(f"Detected CET features: {info.features.name}")

        # Find ENDBR instructions (valid IBT targets)
        if info.ibt_enabled:
            info.valid_ibt_targets, info.endbr_count = self._find_endbr_targets()
            logger.info(f"Found {info.endbr_count} ENDBR instructions")

        # Find signal handlers
        info.signal_handlers = self._find_signal_handlers()

        # Find JIT regions (if detectable)
        info.jit_regions = self._find_jit_regions()

        # Identify bypass opportunities
        info.bypass_opportunities = self._identify_bypasses(info)

        return info

    def _detect_cet_features(self) -> CETFeature:
        """Detect CET feature enablement."""
        if not self._elf:
            return CETFeature.NONE

        has_shadow_stack = False
        has_ibt = False

        # Check for GNU_PROPERTY_X86_FEATURE_1_AND note
        try:
            for section in self._elf.iter_sections():
                if hasattr(section, 'name') and section.name == '.note.gnu.property':
                    # Parse GNU property notes
                    data = section.data()
                    # Look for IBT/SHSTK flags
                    # GNU_PROPERTY_X86_FEATURE_1_IBT = 0x00000001
                    # GNU_PROPERTY_X86_FEATURE_1_SHSTK = 0x00000002
                    if b'\x01\x00\x00\x00' in data:
                        has_ibt = True
                    if b'\x02\x00\x00\x00' in data:
                        has_shadow_stack = True
                    if b'\x03\x00\x00\x00' in data:
                        has_ibt = True
                        has_shadow_stack = True
        except Exception as e:
            logger.debug(f"Error checking GNU property notes: {e}")

        # Also check for ENDBR instructions as indicator
        if not has_ibt:
            try:
                for section in self._elf.iter_sections():
                    if hasattr(section, 'name') and section.name == '.text':
                        data = section.data()
                        if self.ENDBR64_BYTES in data or self.ENDBR32_BYTES in data:
                            has_ibt = True
                        break
            except Exception:
                pass

        # Determine feature combination
        if has_shadow_stack and has_ibt:
            return CETFeature.SHADOW_STACK_AND_IBT
        elif has_shadow_stack:
            return CETFeature.SHADOW_STACK
        elif has_ibt:
            return CETFeature.IBT
        else:
            return CETFeature.NONE

    def _find_endbr_targets(self) -> Tuple[Set[int], int]:
        """Find all ENDBR instructions (valid IBT targets)."""
        targets = set()
        count = 0

        if not self._elf:
            return targets, count

        try:
            for section in self._elf.iter_sections():
                if not hasattr(section, 'name'):
                    continue
                if section.name not in ['.text', '.plt', '.plt.sec']:
                    continue

                data = section.data()
                section_addr = section['sh_addr']

                # Find ENDBR64
                i = 0
                while i < len(data) - 3:
                    if data[i:i+4] == self.ENDBR64_BYTES:
                        targets.add(section_addr + i)
                        count += 1
                        i += 4
                    elif data[i:i+4] == self.ENDBR32_BYTES:
                        targets.add(section_addr + i)
                        count += 1
                        i += 4
                    else:
                        i += 1

        except Exception as e:
            logger.debug(f"Error finding ENDBR targets: {e}")

        return targets, count

    def _find_signal_handlers(self) -> List[int]:
        """Find signal handler setup locations."""
        handlers = []

        if not self._elf:
            return handlers

        # Look for calls to signal/sigaction
        signal_funcs = ['signal', 'sigaction', '__libc_sigaction', 'bsd_signal']

        try:
            from capstone import Cs, CS_ARCH_X86, CS_MODE_64, CS_MODE_32

            mode = CS_MODE_64 if self.binary.bits == 64 else CS_MODE_32
            md = Cs(CS_ARCH_X86, mode)

            for section in self._elf.iter_sections():
                if not hasattr(section, 'name') or section.name != '.text':
                    continue

                data = section.data()
                section_addr = section['sh_addr']

                for insn in md.disasm(data, section_addr):
                    if insn.mnemonic == 'call':
                        # Check if calling a signal function
                        for func in signal_funcs:
                            if hasattr(self.binary, 'plt') and func in self.binary.plt:
                                plt_addr = self.binary.plt[func]
                                # Check if call target matches
                                try:
                                    call_target = int(insn.op_str, 16)
                                    if call_target == plt_addr:
                                        handlers.append(insn.address)
                                except ValueError:
                                    pass

        except Exception as e:
            logger.debug(f"Error finding signal handlers: {e}")

        return handlers

    def _find_jit_regions(self) -> List[Tuple[int, int]]:
        """Find JIT-compiled code regions."""
        regions = []

        # JIT detection is complex - look for RWX mappings
        # This is a simplified check

        if not self._elf:
            return regions

        try:
            for section in self._elf.iter_sections():
                if not hasattr(section, 'name'):
                    continue

                # Look for sections that might contain JIT code
                if 'jit' in section.name.lower():
                    regions.append((
                        section['sh_addr'],
                        section['sh_addr'] + section['sh_size']
                    ))

        except Exception:
            pass

        return regions

    def _identify_bypasses(self, info: CETInfo) -> List[str]:
        """Identify potential CET bypass opportunities."""
        bypasses = []

        if info.shadow_stack_enabled:
            # Signal handler based bypass
            if info.signal_handlers:
                bypasses.append(
                    f"Signal handler manipulation ({len(info.signal_handlers)} handlers found)"
                )

            # Exception-based bypass
            bypasses.append("Exception handler exploitation (check for try/catch)")

            # JIT-based bypass
            if info.jit_regions:
                bypasses.append(f"JIT region abuse ({len(info.jit_regions)} regions)")

            # Context switch desync
            bypasses.append("Shadow stack desynchronization via race condition")

        if info.ibt_enabled:
            # ENDBR gadgets
            bypasses.append(
                f"ENDBR gadget chain ({info.endbr_count} valid targets)"
            )

            # Partial overwrite to valid target
            bypasses.append("Partial overwrite to nearest ENDBR")

        return bypasses


class CETBypass:
    """
    CET bypass techniques and exploit generation.

    Example:
        bypass = CETBypass(binary, cet_info)

        # Find ENDBR gadgets
        gadgets = bypass.find_endbr_gadgets()

        # Generate signal-based bypass
        signal_bypass = bypass.signal_handler_bypass(SIGSEGV)
    """

    def __init__(self, binary: Any, cet_info: Optional[CETInfo] = None):
        """
        Initialize CET bypass.

        Args:
            binary: Target binary
            cet_info: Pre-computed CET analysis (or will analyze)
        """
        self.binary = binary
        self.cet_info = cet_info or CETAnalyzer(binary).analyze()
        self._elf = getattr(binary, 'elf', None)

    def find_endbr_gadgets(self, max_length: int = 20) -> List[IBTBypass]:
        """
        Find useful ENDBR gadgets.

        Args:
            max_length: Maximum instructions to analyze after ENDBR

        Returns:
            List of IBT bypass gadgets
        """
        gadgets = []

        if not self._elf:
            return gadgets

        try:
            from capstone import Cs, CS_ARCH_X86, CS_MODE_64, CS_MODE_32

            mode = CS_MODE_64 if self.binary.bits == 64 else CS_MODE_32
            md = Cs(CS_ARCH_X86, mode)

            for target in self.cet_info.valid_ibt_targets:
                # Read bytes at target
                gadget_bytes = self._read_bytes(target, 64)
                if not gadget_bytes:
                    continue

                # Disassemble
                instructions = list(md.disasm(gadget_bytes, target))
                if not instructions:
                    continue

                # Skip the ENDBR itself
                instructions = instructions[1:]

                # Analyze for useful gadgets
                gadget_info = self._analyze_endbr_gadget(target, instructions[:max_length])
                if gadget_info:
                    gadgets.append(gadget_info)

        except Exception as e:
            logger.debug(f"Error finding ENDBR gadgets: {e}")

        logger.info(f"Found {len(gadgets)} useful ENDBR gadgets")
        return gadgets

    def _read_bytes(self, addr: int, size: int) -> Optional[bytes]:
        """Read bytes from binary at address."""
        if not self._elf:
            return None

        try:
            for section in self._elf.iter_sections():
                if not hasattr(section, 'name') or section.name != '.text':
                    continue

                section_start = section['sh_addr']
                section_end = section_start + section['sh_size']

                if section_start <= addr < section_end:
                    offset = addr - section_start
                    data = section.data()
                    return data[offset:offset+size]

        except Exception:
            pass

        return None

    def _analyze_endbr_gadget(
        self,
        addr: int,
        instructions: List[Any]
    ) -> Optional[IBTBypass]:
        """Analyze instructions after ENDBR for useful gadgets."""
        if not instructions:
            return None

        following = [f"{i.mnemonic} {i.op_str}" for i in instructions[:5]]

        gadget = IBTBypass(
            address=addr,
            instruction="endbr64" if self.binary.bits == 64 else "endbr32",
            gadget_type="endbr64" if self.binary.bits == 64 else "endbr32",
            following_instructions=following
        )

        # Categorize the gadget
        for insn in instructions:
            # Stack pivot
            if insn.mnemonic in ['leave', 'mov'] and 'rsp' in insn.op_str:
                gadget.useful_for = "stack_pivot"
                return gadget

            # Pop register
            if insn.mnemonic == 'pop':
                gadget.useful_for = f"pop_{insn.op_str}"
                return gadget

            # Call/jmp
            if insn.mnemonic in ['call', 'jmp']:
                gadget.useful_for = "control_transfer"
                return gadget

            # Syscall
            if insn.mnemonic == 'syscall':
                gadget.useful_for = "syscall"
                return gadget

            # Ret
            if insn.mnemonic == 'ret':
                gadget.useful_for = "ret"
                return gadget

        return gadget if gadget.useful_for else None

    def signal_handler_bypass(
        self,
        signal_num: int = 11  # SIGSEGV
    ) -> SignalBasedBypass:
        """
        Generate signal-based shadow stack bypass.

        Signal handlers can modify the shadow stack context,
        potentially allowing control of return addresses.

        Args:
            signal_num: Signal number to use

        Returns:
            SignalBasedBypass with exploitation info
        """
        bypass = SignalBasedBypass(
            signal_number=signal_num,
            handler_address=0  # Would need to find actual handler
        )

        # Check if signal handlers were found
        if self.cet_info.signal_handlers:
            bypass.handler_address = self.cet_info.signal_handlers[0]
            bypass.can_corrupt_shadow_stack = True
            bypass.exploitation_notes = (
                "Signal handler found. The sigreturn mechanism can be used to "
                "restore a corrupted shadow stack context. Set up fake sigframe "
                "with controlled RSP shadow stack pointer."
            )
        else:
            bypass.exploitation_notes = (
                "No explicit signal handlers found. Consider installing a signal "
                "handler via format string or other write primitive, then trigger "
                "the signal to gain control."
            )

        return bypass

    def shadow_stack_techniques(self) -> List[ShadowStackBypass]:
        """
        List available shadow stack bypass techniques.

        Returns:
            List of potential shadow stack bypass techniques
        """
        techniques = []

        # Signal-based
        techniques.append(ShadowStackBypass(
            technique="Signal Handler Manipulation",
            requirements=[
                "Ability to register signal handler",
                "Or existing signal handler with controllable context"
            ],
            success_rate="high",
            description=(
                "Signal handlers restore context from the signal frame, including "
                "the shadow stack pointer. By corrupting the signal frame, we can "
                "point the shadow stack to attacker-controlled memory."
            )
        ))

        # Exception-based
        techniques.append(ShadowStackBypass(
            technique="C++ Exception Handler",
            requirements=[
                "C++ binary with exception handling",
                "Control over exception object or handler"
            ],
            success_rate="medium",
            description=(
                "C++ exception unwinding modifies the shadow stack. By corrupting "
                "exception handling data structures, we can influence the shadow "
                "stack state after exception handling."
            )
        ))

        # Race condition
        techniques.append(ShadowStackBypass(
            technique="Shadow Stack Desynchronization",
            requirements=[
                "Multi-threaded application",
                "Control over thread timing"
            ],
            success_rate="low",
            description=(
                "Race condition during context switch can cause shadow stack "
                "mismatch. Requires precise timing control but can bypass "
                "protection completely."
            )
        ))

        # JIT-based
        if self.cet_info.jit_regions:
            techniques.append(ShadowStackBypass(
                technique="JIT Code Exploitation",
                requirements=[
                    "JIT compiler present",
                    "Control over JIT input"
                ],
                success_rate="medium",
                description=(
                    "JIT-compiled code may not properly maintain shadow stack. "
                    "Corrupt JIT code or its data to bypass CET within JIT region."
                )
            ))

        return techniques

    def generate_strategy(self) -> CETExploitStrategy:
        """
        Generate a complete CET exploitation strategy.

        Returns:
            CETExploitStrategy with recommended approach
        """
        strategy = CETExploitStrategy(primary_technique="")

        if not self.cet_info.detected:
            strategy.primary_technique = "none_needed"
            strategy.reliability = "high"
            strategy.notes = "No CET protection detected. Standard exploitation applies."
            return strategy

        # Determine best approach
        if self.cet_info.shadow_stack_enabled:
            if self.cet_info.signal_handlers:
                strategy.primary_technique = "signal_handler"
                strategy.reliability = "high"
                strategy.bypasses.append(self.signal_handler_bypass())
            else:
                strategy.primary_technique = "exception_handler"
                strategy.reliability = "medium"
        else:
            strategy.primary_technique = "endbr_gadget_chain"
            strategy.reliability = "high"
            strategy.bypasses.extend(self.find_endbr_gadgets()[:10])

        # Generate payload template
        strategy.payload_template = self._generate_exploit_template(strategy)

        return strategy

    def _generate_exploit_template(self, strategy: CETExploitStrategy) -> str:
        """Generate exploit template for strategy."""
        template = '''#!/usr/bin/env python3
"""
CET Bypass Exploit Template
Generated by supwngo

CET Features: {features}
Strategy: {strategy}
"""

from pwn import *

# Binary info
binary = ELF("{binary_path}")
context.binary = binary

def exploit():
    p = process(binary.path)

    # Strategy: {strategy}
    #
{strategy_notes}

    p.interactive()

if __name__ == "__main__":
    exploit()
'''
        strategy_notes = ""
        if strategy.primary_technique == "signal_handler":
            strategy_notes = """    # Signal-based Shadow Stack Bypass:
    # 1. Set up fake signal frame with controlled RSP shadow stack
    # 2. Trigger signal (e.g., SIGSEGV via null ptr dereference)
    # 3. sigreturn will restore our fake context
    # 4. Shadow stack now points to our controlled memory"""
        elif strategy.primary_technique == "endbr_gadget_chain":
            strategy_notes = """    # ENDBR Gadget Chain:
    # 1. Find useful ENDBR gadgets (pop, syscall, etc.)
    # 2. Chain ENDBR gadgets for arbitrary execution
    # 3. Each gadget starts with ENDBR, satisfying IBT"""

        return template.format(
            features=self.cet_info.features.name,
            strategy=strategy.primary_technique,
            binary_path=str(self.binary.path) if hasattr(self.binary, 'path') else "./binary",
            strategy_notes=strategy_notes
        )


# Convenience function
def analyze_cet_protection(binary: Any) -> CETInfo:
    """
    Analyze binary for CET protections.

    Args:
        binary: Target binary

    Returns:
        CET analysis results
    """
    analyzer = CETAnalyzer(binary)
    return analyzer.analyze()
