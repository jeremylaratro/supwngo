"""
Automatic buffer overflow offset discovery.

Provides multiple methods for finding the exact offset to overwrite
the return address in buffer overflow vulnerabilities:
- GDB-based analysis (most accurate)
- Core dump analysis
- Binary search with crash detection
- De Bruijn cyclic pattern generation and finding
"""

import os
import re
import signal
import struct
import subprocess
import tempfile
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional, Dict, List, Callable

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class OffsetResult:
    """Result of offset discovery."""
    offset: Optional[int] = None
    crash_address: Optional[int] = None
    pattern_found: str = ""
    method: str = ""
    register_values: Dict[str, int] = field(default_factory=dict)
    stack_data: bytes = b""
    success: bool = False
    error: str = ""

    # Additional info
    canary_offset: Optional[int] = None
    rbp_offset: Optional[int] = None

    def __str__(self) -> str:
        if self.success:
            result = f"Offset: {self.offset} (0x{self.offset:x}) - {self.method}"
            if self.rbp_offset:
                result += f"\nRBP offset: {self.rbp_offset}"
            if self.canary_offset:
                result += f"\nCanary offset: {self.canary_offset}"
            return result
        return f"Failed: {self.error}"

    def to_dict(self) -> dict:
        return {
            "offset": self.offset,
            "crash_address": hex(self.crash_address) if self.crash_address else None,
            "method": self.method,
            "success": self.success,
            "error": self.error,
            "rbp_offset": self.rbp_offset,
            "canary_offset": self.canary_offset,
            "register_values": {k: hex(v) for k, v in self.register_values.items()},
        }


class PatternGenerator:
    """Generate and find de Bruijn sequences for offset discovery."""

    def __init__(self):
        # Default alphabet matching pwntools
        self.alphabet = "abcdefghijklmnopqrstuvwxyz"

    def generate(self, length: int, n: int = 4) -> bytes:
        """
        Generate cyclic pattern of given length.

        Uses de Bruijn sequence - every n-character substring is unique.
        Compatible with pwntools cyclic().

        Args:
            length: Pattern length
            n: Subsequence length (4 for patterns up to ~26^4 = 456976)

        Returns:
            Cyclic pattern as bytes
        """
        try:
            from pwn import cyclic
            return cyclic(length)
        except ImportError:
            return self._generate_debruijn(length, n)

    def find(self, data: bytes | int, n: int = 4) -> int:
        """
        Find offset of data in cyclic pattern.

        Args:
            data: Bytes or integer to find
            n: Subsequence length

        Returns:
            Offset in pattern, or -1 if not found
        """
        try:
            from pwn import cyclic_find
            return cyclic_find(data)
        except ImportError:
            return self._find_in_debruijn(data, n)

    def _generate_debruijn(self, length: int, n: int = 4) -> bytes:
        """Generate de Bruijn sequence without pwntools."""
        k = len(self.alphabet)
        a = [0] * k * n
        sequence = []

        def db(t, p):
            if t > n:
                if n % p == 0:
                    sequence.extend(a[1:p + 1])
            else:
                a[t] = a[t - p]
                db(t + 1, p)
                for j in range(a[t - p] + 1, k):
                    a[t] = j
                    db(t + 1, t)

        db(1, 1)

        result = bytes([ord(self.alphabet[i % k]) for i in sequence])

        # Extend if needed
        while len(result) < length:
            result = result + result

        return result[:length]

    def _find_in_debruijn(self, data: bytes | int, n: int = 4) -> int:
        """Find offset without pwntools."""
        if isinstance(data, int):
            # Convert integer to bytes (little endian)
            byte_len = 8 if data > 0xFFFFFFFF else 4
            data = data.to_bytes(byte_len, 'little').rstrip(b'\x00')
            if len(data) < n:
                data = data.ljust(n, b'\x00')

        # Generate pattern long enough
        pattern = self._generate_debruijn(max(20000, len(data) * 1000), n)

        # Try to find the exact sequence
        idx = pattern.find(data[:n])
        if idx != -1:
            return idx

        # Try reversed for big endian
        idx = pattern.find(data[:n][::-1])
        if idx != -1:
            return idx

        return -1


class OffsetFinder:
    """Automatic offset discovery using multiple methods."""

    def __init__(self, binary_path: str | Path, bits: int = 64):
        """
        Initialize offset finder.

        Args:
            binary_path: Path to target binary
            bits: Binary architecture (32 or 64)
        """
        self.binary_path = Path(binary_path)
        self.bits = bits
        self.word_size = bits // 8
        self.pattern_gen = PatternGenerator()
        self._gdb_available = self._check_gdb()

    def _check_gdb(self) -> bool:
        """Check if GDB is available."""
        try:
            result = subprocess.run(
                ["gdb", "--version"],
                capture_output=True,
                timeout=5,
            )
            return result.returncode == 0
        except Exception:
            return False

    def find_offset(
        self,
        max_length: int = 2048,
        input_method: str = "stdin",
        args: List[str] = None,
    ) -> OffsetResult:
        """
        Find buffer overflow offset using best available method.

        Args:
            max_length: Maximum pattern length to try
            input_method: "stdin", "argv", or "file"
            args: Additional arguments for the binary

        Returns:
            OffsetResult with discovered offset
        """
        args = args or []

        # Try GDB method first (most accurate)
        if self._gdb_available:
            logger.info("Attempting offset discovery with GDB...")
            result = self._find_with_gdb(max_length, input_method, args)
            if result.success:
                return result
            logger.debug(f"GDB method failed: {result.error}")

        # Try core dump method
        logger.info("Attempting offset discovery with core dumps...")
        result = self._find_with_coredump(max_length, input_method, args)
        if result.success:
            return result
        logger.debug(f"Core dump method failed: {result.error}")

        # Try binary search method
        logger.info("Attempting offset discovery with binary search...")
        result = self._find_with_binary_search(max_length, input_method, args)
        if result.success:
            return result

        return OffsetResult(
            success=False,
            error="Could not determine offset with any method",
        )

    def _find_with_gdb(
        self,
        max_length: int,
        input_method: str,
        args: List[str],
    ) -> OffsetResult:
        """Find offset using GDB."""
        pattern = self.pattern_gen.generate(max_length)

        # Create temporary files
        with tempfile.NamedTemporaryFile(mode='wb', delete=False, suffix='.pattern') as f:
            f.write(pattern)
            pattern_path = f.name

        # Build GDB script
        gdb_script = """
set pagination off
set confirm off
set disassembly-flavor intel
handle SIGSEGV stop print nopass
handle SIGBUS stop print nopass
handle SIGILL stop print nopass
handle SIGABRT stop print nopass
"""

        if input_method == "stdin":
            gdb_script += f"run {' '.join(args)} < {pattern_path}\n"
        elif input_method == "argv":
            gdb_script += f'run "$(cat {pattern_path})" {" ".join(args)}\n'
        else:
            gdb_script += f"run {pattern_path} {' '.join(args)}\n"

        gdb_script += """
info registers
x/16gx $rsp
bt
quit
"""

        with tempfile.NamedTemporaryFile(mode='w', suffix='.gdb', delete=False) as f:
            f.write(gdb_script)
            script_path = f.name

        try:
            result = subprocess.run(
                ["gdb", "-q", "-x", script_path, str(self.binary_path)],
                capture_output=True,
                text=True,
                timeout=30,
            )

            output = result.stdout + result.stderr

            # Check if crash occurred
            if "SIGSEGV" not in output and "SIGBUS" not in output and "SIGABRT" not in output:
                return OffsetResult(success=False, error="No crash detected with pattern")

            # Parse register values
            registers = self._parse_gdb_registers(output)

            # Try to find offset from RIP/EIP (instruction pointer)
            for reg in ['rip', 'eip', 'pc']:
                if reg in registers:
                    value = registers[reg]
                    offset = self.pattern_gen.find(value)
                    if offset >= 0:
                        return OffsetResult(
                            offset=offset,
                            crash_address=value,
                            method=f"GDB - {reg.upper()} overwrite",
                            register_values=registers,
                            success=True,
                            rbp_offset=offset - self.word_size if offset >= self.word_size else None,
                        )

            # Try stack pointer - value at RSP might be our pattern
            stack_values = self._parse_stack_from_gdb(output)
            for i, value in enumerate(stack_values):
                offset = self.pattern_gen.find(value)
                if offset >= 0:
                    return OffsetResult(
                        offset=offset,
                        crash_address=value,
                        method=f"GDB - stack value at RSP+{i*self.word_size}",
                        register_values=registers,
                        success=True,
                    )

            # Try RBP if it was overwritten
            if 'rbp' in registers:
                offset = self.pattern_gen.find(registers['rbp'])
                if offset >= 0:
                    return OffsetResult(
                        offset=offset + self.word_size,  # RIP is after RBP
                        crash_address=registers['rbp'],
                        method="GDB - RBP overwrite (RIP = RBP offset + 8)",
                        register_values=registers,
                        success=True,
                        rbp_offset=offset,
                    )

            return OffsetResult(
                success=False,
                error="Pattern not found in crash registers",
                register_values=registers,
            )

        except subprocess.TimeoutExpired:
            return OffsetResult(success=False, error="GDB timeout - binary may hang")
        except Exception as e:
            return OffsetResult(success=False, error=f"GDB error: {e}")
        finally:
            try:
                os.unlink(pattern_path)
                os.unlink(script_path)
            except Exception:
                pass

    def _parse_gdb_registers(self, output: str) -> Dict[str, int]:
        """Parse register values from GDB output."""
        registers = {}

        # Match patterns like: rax            0x4141414141414141   4702111234474983745
        patterns = [
            r'(r[a-z0-9]+)\s+0x([0-9a-f]+)',  # 64-bit registers
            r'(e[a-z]+)\s+0x([0-9a-f]+)',      # 32-bit registers
            r'(rip|eip|pc)\s+0x([0-9a-f]+)',   # Instruction pointer
        ]

        for pattern in patterns:
            for match in re.finditer(pattern, output, re.IGNORECASE):
                reg_name = match.group(1).lower()
                try:
                    reg_value = int(match.group(2), 16)
                    registers[reg_name] = reg_value
                except ValueError:
                    continue

        return registers

    def _parse_stack_from_gdb(self, output: str) -> List[int]:
        """Parse stack values from GDB x/16gx $rsp output."""
        values = []

        # Match lines like: 0x7fffffffe000:	0x6161616261616161	0x6161616461616163
        for match in re.finditer(r'0x[0-9a-f]+:\s+(0x[0-9a-f]+)', output, re.IGNORECASE):
            try:
                values.append(int(match.group(1), 16))
            except ValueError:
                continue

        return values

    def _find_with_coredump(
        self,
        max_length: int,
        input_method: str,
        args: List[str],
    ) -> OffsetResult:
        """Find offset using core dump analysis."""
        pattern = self.pattern_gen.generate(max_length)

        with tempfile.TemporaryDirectory() as tmpdir:
            # Try to enable core dumps
            core_pattern_file = Path("/proc/sys/kernel/core_pattern")

            try:
                if input_method == "stdin":
                    proc = subprocess.run(
                        [str(self.binary_path)] + args,
                        input=pattern,
                        capture_output=True,
                        timeout=10,
                        cwd=tmpdir,
                    )
                elif input_method == "argv":
                    proc = subprocess.run(
                        [str(self.binary_path), pattern.decode('latin-1')] + args,
                        capture_output=True,
                        timeout=10,
                        cwd=tmpdir,
                    )
                else:
                    pattern_file = Path(tmpdir) / "pattern.txt"
                    pattern_file.write_bytes(pattern)
                    proc = subprocess.run(
                        [str(self.binary_path), str(pattern_file)] + args,
                        capture_output=True,
                        timeout=10,
                        cwd=tmpdir,
                    )

                # Check for segfault
                if proc.returncode not in [-11, -6, -4, 139, 134, 132]:
                    return OffsetResult(success=False, error=f"No crash (exit code: {proc.returncode})")

                # Look for core dump
                core_files = list(Path(tmpdir).glob("core*"))
                if not core_files:
                    core_files = list(Path(".").glob("core*"))
                if not core_files:
                    core_files = list(Path("/tmp").glob("core*"))

                if core_files and self._gdb_available:
                    return self._analyze_core(core_files[0], pattern)

                return OffsetResult(success=False, error="No core dump found")

            except subprocess.TimeoutExpired:
                return OffsetResult(success=False, error="Process timeout")
            except Exception as e:
                return OffsetResult(success=False, error=f"Error: {e}")

    def _analyze_core(self, core_path: Path, pattern: bytes) -> OffsetResult:
        """Analyze core dump with GDB."""
        gdb_script = """
set pagination off
info registers
bt
quit
"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.gdb', delete=False) as f:
            f.write(gdb_script)
            script_path = f.name

        try:
            result = subprocess.run(
                ["gdb", "-q", "-x", script_path, str(self.binary_path), str(core_path)],
                capture_output=True,
                text=True,
                timeout=10,
            )

            registers = self._parse_gdb_registers(result.stdout)

            for reg in ['rip', 'eip', 'pc', 'rbp', 'ebp']:
                if reg in registers:
                    offset = self.pattern_gen.find(registers[reg])
                    if offset >= 0:
                        # Adjust for RIP vs RBP
                        if reg in ['rbp', 'ebp']:
                            offset += self.word_size
                        return OffsetResult(
                            offset=offset,
                            crash_address=registers[reg],
                            method=f"Core dump - {reg.upper()}",
                            register_values=registers,
                            success=True,
                        )

            return OffsetResult(
                success=False,
                error="Pattern not found in core",
                register_values=registers,
            )
        finally:
            os.unlink(script_path)

    def _find_with_binary_search(
        self,
        max_length: int,
        input_method: str,
        args: List[str],
    ) -> OffsetResult:
        """Find approximate offset using binary search."""

        def test_crash(length: int) -> bool:
            payload = b"A" * length
            try:
                if input_method == "stdin":
                    proc = subprocess.run(
                        [str(self.binary_path)] + args,
                        input=payload,
                        capture_output=True,
                        timeout=5,
                    )
                else:
                    proc = subprocess.run(
                        [str(self.binary_path), payload.decode('latin-1')] + args,
                        capture_output=True,
                        timeout=5,
                    )
                return proc.returncode in [-11, -6, -4, 139, 134, 132]
            except Exception:
                return False

        # Binary search for crash threshold
        low, high = 0, max_length
        crash_at = None

        while low < high:
            mid = (low + high) // 2
            if test_crash(mid):
                crash_at = mid
                high = mid
            else:
                low = mid + 1

        if crash_at is None:
            return OffsetResult(success=False, error="No crash detected at any length")

        # Refine with pattern around crash point
        start = max(0, crash_at - 100)
        pattern = self.pattern_gen.generate(200)

        for offset_guess in range(start, crash_at + 50, self.word_size):
            test_payload = b"A" * offset_guess + pattern[:self.word_size * 2]

            if input_method == "stdin":
                proc = subprocess.run(
                    [str(self.binary_path)] + args,
                    input=test_payload,
                    capture_output=True,
                    timeout=5,
                )
            else:
                proc = subprocess.run(
                    [str(self.binary_path), test_payload.decode('latin-1')] + args,
                    capture_output=True,
                    timeout=5,
                )

            if proc.returncode in [-11, -6, -4, 139, 134, 132]:
                return OffsetResult(
                    offset=offset_guess,
                    method="Binary search (approximate)",
                    success=True,
                )

        return OffsetResult(
            offset=crash_at,
            method="Binary search (crash threshold)",
            success=True,
        )

    # === Convenience Methods ===

    def find_ret_offset(self, max_length: int = 2048) -> Optional[int]:
        """Find offset to return address."""
        result = self.find_offset(max_length)
        return result.offset if result.success else None

    def find_canary_offset(self, ret_offset: int) -> int:
        """
        Calculate canary offset from return address offset.

        On x64: stack layout is [buffer][canary][saved_rbp][return_addr]
        Canary is typically at ret_offset - 16
        """
        return ret_offset - (2 * self.word_size)

    def find_rbp_offset(self, ret_offset: int) -> int:
        """Calculate saved RBP offset from return address offset."""
        return ret_offset - self.word_size


# === Convenience Functions ===

def cyclic(length: int) -> bytes:
    """Generate cyclic pattern (compatible with pwntools)."""
    return PatternGenerator().generate(length)


def cyclic_find(data: bytes | int) -> int:
    """Find offset in cyclic pattern (compatible with pwntools)."""
    return PatternGenerator().find(data)


def find_offset(
    binary_path: str | Path,
    max_length: int = 2048,
    input_method: str = "stdin",
    bits: int = 64,
) -> Optional[int]:
    """Convenience function to find buffer overflow offset."""
    finder = OffsetFinder(binary_path, bits)
    result = finder.find_offset(max_length, input_method)
    return result.offset if result.success else None
