"""
ROP Gadget Quality Scoring Module.

Provides comprehensive gadget quality analysis including:
- Side effect analysis
- Register clobber tracking
- Stack adjustment scoring
- Reliability scoring
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple
from enum import Enum, auto
import re

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class GadgetQuality(Enum):
    """Gadget quality levels."""
    EXCELLENT = auto()  # Clean, minimal side effects
    GOOD = auto()       # Usable with minor considerations
    FAIR = auto()       # Usable but has issues
    POOR = auto()       # Last resort
    UNUSABLE = auto()   # Should not be used


@dataclass
class GadgetScore:
    """Detailed scoring for a ROP gadget."""
    address: int
    instructions: str
    quality: GadgetQuality
    total_score: float  # 0.0 to 1.0

    # Component scores
    side_effect_score: float = 1.0
    clobber_score: float = 1.0
    alignment_score: float = 1.0
    stack_adjustment_score: float = 1.0
    reliability_score: float = 1.0

    # Analysis details
    clobbered_registers: Set[str] = field(default_factory=set)
    preserved_registers: Set[str] = field(default_factory=set)
    stack_adjustment: int = 0  # Bytes added/removed from stack
    has_memory_access: bool = False
    has_conditional: bool = False
    has_call: bool = False
    constraints: List[str] = field(default_factory=list)
    notes: List[str] = field(default_factory=list)

    def __str__(self) -> str:
        return (f"[{self.quality.name}] 0x{self.address:x} "
                f"(score={self.total_score:.2f}): {self.instructions}")


@dataclass
class GadgetChainScore:
    """Scoring for a complete ROP chain."""
    gadgets: List[GadgetScore]
    total_score: float
    chain_quality: GadgetQuality

    stack_requirements: int  # Total stack bytes needed
    clobbered_at_end: Set[str]  # Registers clobbered by chain
    preserved_at_end: Set[str]  # Registers preserved through chain

    warnings: List[str] = field(default_factory=list)
    optimization_suggestions: List[str] = field(default_factory=list)


class GadgetScorer:
    """
    Scores ROP gadgets for quality and reliability.

    Analyzes gadgets to determine:
    - Which registers are clobbered vs preserved
    - Memory access patterns
    - Stack alignment effects
    - Overall usability for chaining
    """

    # Registers by architecture
    X64_REGS = {'rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi', 'rbp', 'rsp',
                'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15'}
    X64_CALLEE_SAVED = {'rbx', 'rbp', 'r12', 'r13', 'r14', 'r15'}
    X64_CALLER_SAVED = {'rax', 'rcx', 'rdx', 'rsi', 'rdi', 'r8', 'r9', 'r10', 'r11'}

    X86_REGS = {'eax', 'ebx', 'ecx', 'edx', 'esi', 'edi', 'ebp', 'esp'}
    X86_CALLEE_SAVED = {'ebx', 'ebp', 'esi', 'edi'}

    # Bad instructions that make gadgets unreliable
    BAD_INSTRUCTIONS = {
        'int', 'syscall', 'sysenter', 'in', 'out',
        'hlt', 'ud2', 'cli', 'sti',
    }

    # Instructions that affect control flow unpredictably
    CONTROL_FLOW = {
        'jmp', 'je', 'jne', 'jz', 'jnz', 'ja', 'jb', 'jg', 'jl',
        'jae', 'jbe', 'jge', 'jle', 'jo', 'jno', 'js', 'jns',
        'loop', 'loope', 'loopne', 'call',
    }

    def __init__(self, bits: int = 64):
        """
        Initialize gadget scorer.

        Args:
            bits: Architecture bits (32 or 64)
        """
        self.bits = bits
        self.regs = self.X64_REGS if bits == 64 else self.X86_REGS
        self.callee_saved = self.X64_CALLEE_SAVED if bits == 64 else self.X86_CALLEE_SAVED
        self.word_size = bits // 8

    def score_gadget(self, address: int, instructions: str) -> GadgetScore:
        """
        Score a single gadget.

        Args:
            address: Gadget address
            instructions: Disassembled instructions (semicolon separated)

        Returns:
            GadgetScore with detailed analysis
        """
        insn_list = [i.strip().lower() for i in instructions.split(';') if i.strip()]

        score = GadgetScore(
            address=address,
            instructions=instructions,
            quality=GadgetQuality.EXCELLENT,
            total_score=1.0,
        )

        # Analyze each instruction
        for insn in insn_list:
            self._analyze_instruction(insn, score)

        # Calculate component scores
        score.side_effect_score = self._calc_side_effect_score(score)
        score.clobber_score = self._calc_clobber_score(score)
        score.alignment_score = self._calc_alignment_score(score)
        score.stack_adjustment_score = self._calc_stack_adjustment_score(score)
        score.reliability_score = self._calc_reliability_score(score, insn_list)

        # Calculate total score
        score.total_score = (
            score.side_effect_score * 0.25 +
            score.clobber_score * 0.20 +
            score.alignment_score * 0.15 +
            score.stack_adjustment_score * 0.15 +
            score.reliability_score * 0.25
        )

        # Determine quality level
        score.quality = self._determine_quality(score)

        return score

    def _analyze_instruction(self, insn: str, score: GadgetScore) -> None:
        """Analyze a single instruction and update score."""
        parts = insn.split()
        if not parts:
            return

        mnem = parts[0]
        operands = ' '.join(parts[1:]).split(',') if len(parts) > 1 else []
        operands = [op.strip() for op in operands]

        # Check for bad instructions
        if mnem in self.BAD_INSTRUCTIONS:
            score.notes.append(f"Bad instruction: {mnem}")
            score.reliability_score = 0.0

        # Check for control flow
        if mnem in self.CONTROL_FLOW:
            score.has_conditional = True
            if mnem == 'call':
                score.has_call = True
                score.notes.append("Contains CALL - may have side effects")

        # Check for memory access
        if '[' in insn:
            score.has_memory_access = True

        # Track register usage
        self._track_register_usage(mnem, operands, score)

        # Track stack adjustment
        self._track_stack_adjustment(mnem, operands, score)

    def _track_register_usage(self, mnem: str, operands: List[str], score: GadgetScore) -> None:
        """Track which registers are read/written."""
        if not operands:
            return

        # Instructions that write to first operand
        write_first = {
            'mov', 'movzx', 'movsx', 'lea', 'pop', 'xor', 'and', 'or',
            'add', 'sub', 'inc', 'dec', 'neg', 'not', 'shl', 'shr',
            'sal', 'sar', 'rol', 'ror', 'imul', 'mul', 'div', 'idiv',
        }

        # xchg modifies both
        if mnem == 'xchg' and len(operands) >= 2:
            for op in operands[:2]:
                reg = self._extract_register(op)
                if reg:
                    score.clobbered_registers.add(reg)

        elif mnem in write_first:
            dst = operands[0] if operands else ''
            dst_reg = self._extract_register(dst)
            if dst_reg:
                score.clobbered_registers.add(dst_reg)

                # Special case: xor reg, reg clears the register
                if mnem == 'xor' and len(operands) >= 2:
                    if operands[0] == operands[1]:
                        score.notes.append(f"xor {dst_reg}, {dst_reg} clears register")

        # pop clobbers the register and adjusts stack
        if mnem == 'pop':
            reg = self._extract_register(operands[0]) if operands else None
            if reg:
                score.clobbered_registers.add(reg)
            score.stack_adjustment += self.word_size

        # push adjusts stack
        if mnem == 'push':
            score.stack_adjustment -= self.word_size

    def _track_stack_adjustment(self, mnem: str, operands: List[str], score: GadgetScore) -> None:
        """Track how the gadget affects the stack pointer."""
        if mnem == 'add' and operands and 'sp' in operands[0].lower():
            # add rsp, N
            try:
                val = self._parse_immediate(operands[1]) if len(operands) > 1 else 0
                score.stack_adjustment += val
            except:
                pass

        elif mnem == 'sub' and operands and 'sp' in operands[0].lower():
            # sub rsp, N
            try:
                val = self._parse_immediate(operands[1]) if len(operands) > 1 else 0
                score.stack_adjustment -= val
            except:
                pass

        elif mnem == 'ret':
            # ret N pops extra bytes
            if operands:
                try:
                    val = self._parse_immediate(operands[0])
                    score.stack_adjustment += val
                except:
                    pass

    def _extract_register(self, operand: str) -> Optional[str]:
        """Extract register name from operand."""
        operand = operand.lower().strip()

        # Direct register
        for reg in self.regs:
            if operand == reg:
                return reg

        # Check for register in memory operand like [rax]
        if '[' in operand:
            inner = operand.split('[')[1].split(']')[0]
            for reg in self.regs:
                if reg in inner:
                    return None  # Memory access, not direct register

        return None

    def _parse_immediate(self, value: str) -> int:
        """Parse immediate value."""
        value = value.strip().lower()
        if value.startswith('0x'):
            return int(value, 16)
        return int(value)

    def _calc_side_effect_score(self, score: GadgetScore) -> float:
        """Calculate side effect score."""
        s = 1.0

        if score.has_memory_access:
            s -= 0.2
            score.notes.append("Has memory access")

        if score.has_call:
            s -= 0.4
            score.notes.append("Has CALL instruction")

        if score.has_conditional:
            s -= 0.3
            score.notes.append("Has conditional instruction")

        return max(0.0, s)

    def _calc_clobber_score(self, score: GadgetScore) -> float:
        """Calculate register clobber score."""
        if not score.clobbered_registers:
            return 1.0

        # Clobbering callee-saved registers is worse
        callee_clobbered = score.clobbered_registers & self.callee_saved
        caller_clobbered = score.clobbered_registers - self.callee_saved

        penalty = len(callee_clobbered) * 0.15 + len(caller_clobbered) * 0.05
        return max(0.0, 1.0 - penalty)

    def _calc_alignment_score(self, score: GadgetScore) -> float:
        """Calculate stack alignment score."""
        # Stack should remain 16-byte aligned on x64
        if self.bits == 64:
            if score.stack_adjustment % 16 != 0 and score.stack_adjustment != self.word_size:
                return 0.7
        return 1.0

    def _calc_stack_adjustment_score(self, score: GadgetScore) -> float:
        """Calculate stack adjustment score."""
        adj = abs(score.stack_adjustment)

        # Minimal adjustment is best
        if adj == 0:
            return 1.0
        if adj <= self.word_size:
            return 0.9
        if adj <= self.word_size * 2:
            return 0.8
        if adj <= self.word_size * 4:
            return 0.6

        return 0.4

    def _calc_reliability_score(self, score: GadgetScore, insn_list: List[str]) -> float:
        """Calculate reliability score."""
        s = 1.0

        # Longer gadgets are less reliable
        if len(insn_list) > 5:
            s -= 0.2
        elif len(insn_list) > 3:
            s -= 0.1

        # Check for problematic patterns
        instructions_str = ' '.join(insn_list)

        if 'leave' in instructions_str:
            # leave modifies rbp and rsp
            s -= 0.1
            score.constraints.append("Requires valid RBP")

        if any(bad in instructions_str for bad in ['div', 'idiv']):
            s -= 0.3
            score.constraints.append("Division - may fault")

        return max(0.0, s)

    def _determine_quality(self, score: GadgetScore) -> GadgetQuality:
        """Determine overall quality level."""
        if score.total_score >= 0.9:
            return GadgetQuality.EXCELLENT
        if score.total_score >= 0.7:
            return GadgetQuality.GOOD
        if score.total_score >= 0.5:
            return GadgetQuality.FAIR
        if score.total_score >= 0.3:
            return GadgetQuality.POOR
        return GadgetQuality.UNUSABLE

    def score_chain(self, gadgets: List[Tuple[int, str]]) -> GadgetChainScore:
        """
        Score a complete ROP chain.

        Args:
            gadgets: List of (address, instructions) tuples

        Returns:
            GadgetChainScore with chain analysis
        """
        scored_gadgets = [self.score_gadget(addr, insn) for addr, insn in gadgets]

        if not scored_gadgets:
            return GadgetChainScore(
                gadgets=[],
                total_score=0.0,
                chain_quality=GadgetQuality.UNUSABLE,
                stack_requirements=0,
                clobbered_at_end=set(),
                preserved_at_end=set(),
            )

        # Calculate cumulative effects
        total_stack = sum(g.stack_adjustment for g in scored_gadgets)
        all_clobbered = set()
        for g in scored_gadgets:
            all_clobbered.update(g.clobbered_registers)

        # Average score with penalty for chain length
        avg_score = sum(g.total_score for g in scored_gadgets) / len(scored_gadgets)
        length_penalty = min(0.2, len(scored_gadgets) * 0.02)
        total_score = avg_score - length_penalty

        # Determine chain quality
        if total_score >= 0.8:
            quality = GadgetQuality.EXCELLENT
        elif total_score >= 0.6:
            quality = GadgetQuality.GOOD
        elif total_score >= 0.4:
            quality = GadgetQuality.FAIR
        else:
            quality = GadgetQuality.POOR

        # Generate warnings and suggestions
        warnings = []
        suggestions = []

        if any(g.has_call for g in scored_gadgets):
            warnings.append("Chain contains CALL instructions")

        if any(g.quality == GadgetQuality.POOR for g in scored_gadgets):
            suggestions.append("Consider replacing POOR quality gadgets")

        poor_gadgets = [g for g in scored_gadgets if g.quality in (GadgetQuality.POOR, GadgetQuality.UNUSABLE)]
        if poor_gadgets:
            for g in poor_gadgets[:3]:
                suggestions.append(f"Replace gadget at 0x{g.address:x}")

        return GadgetChainScore(
            gadgets=scored_gadgets,
            total_score=total_score,
            chain_quality=quality,
            stack_requirements=abs(total_stack),
            clobbered_at_end=all_clobbered,
            preserved_at_end=self.regs - all_clobbered,
            warnings=warnings,
            optimization_suggestions=suggestions,
        )

    def compare_gadgets(self, gadgets: List[Tuple[int, str]]) -> List[GadgetScore]:
        """
        Score and rank multiple gadgets for the same purpose.

        Args:
            gadgets: List of (address, instructions) tuples

        Returns:
            Sorted list of GadgetScore (best first)
        """
        scored = [self.score_gadget(addr, insn) for addr, insn in gadgets]
        return sorted(scored, key=lambda g: -g.total_score)

    def find_best_alternative(
        self,
        desired_effect: str,
        candidates: List[Tuple[int, str]],
    ) -> Optional[GadgetScore]:
        """
        Find the best gadget for a desired effect.

        Args:
            desired_effect: Description like "pop rdi" or "mov rax, 0"
            candidates: List of candidate gadgets

        Returns:
            Best scoring gadget or None
        """
        desired_lower = desired_effect.lower()
        matching = []

        for addr, insn in candidates:
            insn_lower = insn.lower()
            # Check if gadget achieves desired effect
            if desired_lower in insn_lower:
                matching.append((addr, insn))

        if not matching:
            return None

        ranked = self.compare_gadgets(matching)
        return ranked[0] if ranked else None


class ChainOptimizer:
    """
    Optimizes ROP chains for reliability and size.

    Can:
    - Replace poor gadgets with better alternatives
    - Minimize stack usage
    - Improve chain reliability
    """

    def __init__(self, scorer: GadgetScorer, all_gadgets: List[Tuple[int, str]]):
        """
        Initialize chain optimizer.

        Args:
            scorer: GadgetScorer instance
            all_gadgets: All available gadgets
        """
        self.scorer = scorer
        self.all_gadgets = all_gadgets
        self._gadget_index = self._build_index()

    def _build_index(self) -> Dict[str, List[Tuple[int, str]]]:
        """Build index of gadgets by effect."""
        index: Dict[str, List[Tuple[int, str]]] = {}

        for addr, insn in self.all_gadgets:
            # Index by first instruction
            parts = insn.lower().split(';')
            if parts:
                first = parts[0].strip()
                if first not in index:
                    index[first] = []
                index[first].append((addr, insn))

                # Also index by register operations
                for reg in self.scorer.regs:
                    if f'pop {reg}' in insn.lower():
                        key = f'pop_{reg}'
                        if key not in index:
                            index[key] = []
                        index[key].append((addr, insn))

        return index

    def optimize_chain(
        self,
        chain: List[Tuple[int, str]],
        preserve_regs: Set[str] = None,
    ) -> List[Tuple[int, str]]:
        """
        Optimize a ROP chain.

        Args:
            chain: Current chain
            preserve_regs: Registers that must be preserved

        Returns:
            Optimized chain
        """
        preserve_regs = preserve_regs or set()
        optimized = []

        for addr, insn in chain:
            score = self.scorer.score_gadget(addr, insn)

            if score.quality in (GadgetQuality.POOR, GadgetQuality.UNUSABLE):
                # Try to find better alternative
                better = self._find_better_gadget(insn, score, preserve_regs)
                if better:
                    optimized.append((better.address, better.instructions))
                    logger.info(f"Replaced 0x{addr:x} with 0x{better.address:x}")
                else:
                    optimized.append((addr, insn))
            else:
                optimized.append((addr, insn))

        return optimized

    def _find_better_gadget(
        self,
        original_insn: str,
        original_score: GadgetScore,
        preserve_regs: Set[str],
    ) -> Optional[GadgetScore]:
        """Find a better gadget with same effect."""
        # Determine primary effect
        parts = original_insn.lower().split(';')
        if not parts:
            return None

        primary = parts[0].strip()

        # Look for alternatives
        candidates = self._gadget_index.get(primary, [])

        best = None
        best_score = original_score.total_score

        for addr, insn in candidates:
            if addr == original_score.address:
                continue

            score = self.scorer.score_gadget(addr, insn)

            # Check it doesn't clobber preserved registers
            if score.clobbered_registers & preserve_regs:
                continue

            if score.total_score > best_score:
                best = score
                best_score = score.total_score

        return best
