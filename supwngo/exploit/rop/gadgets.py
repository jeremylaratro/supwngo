"""
ROP gadget finding and management.
"""

import re
import subprocess
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple

from supwngo.core.binary import Binary
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class GadgetType(Enum):
    """Classification of ROP gadget types."""
    UNKNOWN = auto()

    # Stack manipulation
    POP_REG = auto()          # pop reg; ret
    PUSH_REG = auto()         # push reg; ret
    MOV_REG = auto()          # mov dst, src; ret
    XCHG_REG = auto()         # xchg reg1, reg2; ret

    # Arithmetic
    ADD_REG = auto()          # add dst, src; ret
    SUB_REG = auto()          # sub dst, src; ret
    INC_REG = auto()          # inc reg; ret
    DEC_REG = auto()          # dec reg; ret
    XOR_REG = auto()          # xor reg, reg; ret (zero register)
    NEG_REG = auto()          # neg reg; ret

    # Memory operations
    MOV_MEM_REG = auto()      # mov [reg], reg; ret (write primitive)
    MOV_REG_MEM = auto()      # mov reg, [reg]; ret (read primitive)
    LEA_REG = auto()          # lea reg, [mem]; ret

    # Control flow
    RET = auto()              # ret
    LEAVE_RET = auto()        # leave; ret (stack pivot)
    SYSCALL = auto()          # syscall; ret
    SYSCALL_NO_RET = auto()   # syscall (no ret)
    INT_80 = auto()           # int 0x80; ret

    # Jump/Call to register (ret2reg)
    JMP_REG = auto()          # jmp reg (shellcode pivot)
    CALL_REG = auto()         # call reg (shellcode pivot)

    # Stack pivot specific
    POP_RSP = auto()          # pop rsp; ret
    XCHG_RSP = auto()         # xchg rsp, reg; ret
    ADD_RSP = auto()          # add rsp, imm; ret
    SUB_RSP = auto()          # sub rsp, imm; ret
    MOV_RSP = auto()          # mov rsp, reg; ret


@dataclass
class Gadget:
    """Represents a ROP gadget."""
    address: int
    instructions: str
    raw_bytes: bytes = b""

    # Gadget classification
    gadget_type: GadgetType = GadgetType.UNKNOWN

    # Analysis results
    regs_popped: List[str] = field(default_factory=list)
    regs_modified: List[str] = field(default_factory=list)
    stack_change: int = 0  # How many bytes popped
    is_syscall: bool = False
    is_ret: bool = True
    is_call: bool = False
    is_jmp: bool = False

    # For ret2reg gadgets
    target_reg: Optional[str] = None  # Register jumped/called to

    def __str__(self) -> str:
        return f"0x{self.address:x}: {self.instructions}"

    def is_ret2reg(self) -> bool:
        """Check if this is a ret2reg gadget (jmp/call reg)."""
        return self.gadget_type in (GadgetType.JMP_REG, GadgetType.CALL_REG)

    def is_stack_pivot(self) -> bool:
        """Check if this gadget can be used for stack pivoting."""
        return self.gadget_type in (
            GadgetType.LEAVE_RET,
            GadgetType.POP_RSP,
            GadgetType.XCHG_RSP,
            GadgetType.ADD_RSP,
            GadgetType.SUB_RSP,
            GadgetType.MOV_RSP,
        )

    def is_write_primitive(self) -> bool:
        """Check if this gadget provides a write primitive."""
        return self.gadget_type == GadgetType.MOV_MEM_REG

    def is_read_primitive(self) -> bool:
        """Check if this gadget provides a read primitive."""
        return self.gadget_type == GadgetType.MOV_REG_MEM


class GadgetFinder:
    """
    ROP gadget finder using multiple backends.

    Supports:
    - pwntools ROP
    - ropper
    - ROPgadget
    - angrop
    """

    def __init__(self, binary: Binary):
        """
        Initialize gadget finder.

        Args:
            binary: Target binary
        """
        self.binary = binary
        self._gadgets: Dict[str, Gadget] = {}  # instructions -> Gadget
        self._gadgets_by_addr: Dict[int, Gadget] = {}

    def find_gadgets(self, use_cache: bool = True) -> List[Gadget]:
        """
        Find all ROP gadgets in binary.

        Args:
            use_cache: Whether to use cached results

        Returns:
            List of gadgets
        """
        if self._gadgets and use_cache:
            return list(self._gadgets.values())

        gadgets = []

        # Try different backends
        gadgets = self._find_with_pwntools()

        if not gadgets:
            gadgets = self._find_with_ropper()

        if not gadgets:
            gadgets = self._find_with_ropgadget()

        # Index gadgets
        for g in gadgets:
            self._gadgets[g.instructions] = g
            self._gadgets_by_addr[g.address] = g

        logger.info(f"Found {len(gadgets)} gadgets")
        return gadgets

    def _find_with_pwntools(self) -> List[Gadget]:
        """Find gadgets using pwntools."""
        gadgets = []

        try:
            from pwn import ROP, context

            context.binary = self.binary._elf
            rop = ROP(self.binary._elf)

            # Extract gadgets from ROP object
            for gadget in rop.gadgets.values():
                g = Gadget(
                    address=gadget.address,
                    instructions="; ".join(gadget.insns),
                    stack_change=gadget.move,
                    regs_popped=list(gadget.regs),
                )
                gadgets.append(g)

        except Exception as e:
            logger.debug(f"pwntools gadget finding failed: {e}")

        return gadgets

    def _find_with_ropper(self) -> List[Gadget]:
        """Find gadgets using ropper."""
        gadgets = []

        try:
            result = subprocess.run(
                ["ropper", "--file", str(self.binary.path), "--nocolor"],
                capture_output=True,
                text=True,
                timeout=120,
            )

            for line in result.stdout.split("\n"):
                # Parse ropper output: 0xaddress: instructions
                match = re.match(r"(0x[0-9a-f]+):\s+(.+)", line.strip())
                if match:
                    addr = int(match.group(1), 16)
                    insns = match.group(2)
                    gadgets.append(Gadget(address=addr, instructions=insns))

        except FileNotFoundError:
            logger.debug("ropper not found")
        except Exception as e:
            logger.debug(f"ropper failed: {e}")

        return gadgets

    def _find_with_ropgadget(self) -> List[Gadget]:
        """Find gadgets using ROPgadget."""
        gadgets = []

        try:
            result = subprocess.run(
                ["ROPgadget", "--binary", str(self.binary.path)],
                capture_output=True,
                text=True,
                timeout=120,
            )

            for line in result.stdout.split("\n"):
                match = re.match(r"(0x[0-9a-f]+)\s+:\s+(.+)", line.strip())
                if match:
                    addr = int(match.group(1), 16)
                    insns = match.group(2)
                    gadgets.append(Gadget(address=addr, instructions=insns))

        except FileNotFoundError:
            logger.debug("ROPgadget not found")
        except Exception as e:
            logger.debug(f"ROPgadget failed: {e}")

        return gadgets

    def find_gadget(
        self,
        instructions: List[str],
        exact: bool = False,
    ) -> Optional[Gadget]:
        """
        Find gadget with specific instructions.

        Args:
            instructions: Required instructions
            exact: Whether to match exactly

        Returns:
            Matching Gadget or None
        """
        if not self._gadgets:
            self.find_gadgets()

        # Try pwntools find_gadget for common cases
        try:
            from pwn import ROP, context
            context.binary = self.binary._elf
            rop = ROP(self.binary._elf)
            result = rop.find_gadget(instructions)
            if result:
                addr = result[0]
                return self._gadgets_by_addr.get(addr) or Gadget(
                    address=addr,
                    instructions="; ".join(instructions),
                )
        except Exception:
            pass

        # Manual search
        search_str = "; ".join(instructions).lower()

        for insn_str, gadget in self._gadgets.items():
            if exact:
                if insn_str.lower() == search_str:
                    return gadget
            else:
                if search_str in insn_str.lower():
                    return gadget

        return None

    def find_pop_reg(self, reg: str) -> Optional[Gadget]:
        """
        Find pop reg; ret gadget.

        Args:
            reg: Register name

        Returns:
            Gadget or None
        """
        return self.find_gadget([f"pop {reg}", "ret"])

    def find_mov_reg(self, dst: str, src: str) -> Optional[Gadget]:
        """
        Find mov dst, src gadget.

        Args:
            dst: Destination register
            src: Source register

        Returns:
            Gadget or None
        """
        return self.find_gadget([f"mov {dst}, {src}"])

    def find_syscall(self) -> Optional[Gadget]:
        """Find syscall gadget."""
        gadget = self.find_gadget(["syscall", "ret"])
        if not gadget:
            gadget = self.find_gadget(["syscall"])
        return gadget

    def find_int_80(self) -> Optional[Gadget]:
        """Find int 0x80 gadget."""
        return self.find_gadget(["int 0x80"])

    def find_ret(self) -> Optional[Gadget]:
        """Find simple ret gadget."""
        return self.find_gadget(["ret"])

    def find_leave_ret(self) -> Optional[Gadget]:
        """Find leave; ret gadget for stack pivot."""
        return self.find_gadget(["leave", "ret"])

    def find_jmp_reg(self, reg: str = None) -> Optional[Gadget]:
        """
        Find jmp reg gadget for shellcode execution (ret2reg).

        These gadgets don't end in ret, so they're not found by standard
        ROP gadget finders. We search the binary directly.

        Args:
            reg: Specific register (e.g., 'rsp', 'rsi') or None for any

        Returns:
            Gadget or None
        """
        try:
            from pwn import asm

            # Determine architecture
            arch = getattr(self.binary, 'arch', 'amd64')
            bits = getattr(self.binary, 'bits', 64)

            # Search for specific or all common registers
            if reg:
                regs = [reg]
            elif bits == 64:
                regs = ['rsp', 'rsi', 'rdi', 'rax', 'rbx', 'rcx', 'rdx',
                        'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15']
            else:
                regs = ['esp', 'esi', 'edi', 'eax', 'ebx', 'ecx', 'edx']

            for r in regs:
                try:
                    jmp_bytes = asm(f'jmp {r}', arch=arch)
                    results = list(self.binary._elf.search(jmp_bytes))
                    if results:
                        addr = results[0]
                        g = Gadget(
                            address=addr,
                            instructions=f"jmp {r}",
                            raw_bytes=jmp_bytes,
                            gadget_type=GadgetType.JMP_REG,
                            target_reg=r,
                            is_ret=False,
                            is_jmp=True,
                        )
                        return g
                except Exception:
                    pass
        except Exception as e:
            logger.debug(f"jmp reg search failed: {e}")

        return None

    def find_call_reg(self, reg: str = None) -> Optional[Gadget]:
        """
        Find call reg gadget for shellcode execution (ret2reg).

        Args:
            reg: Specific register or None for any

        Returns:
            Gadget or None
        """
        try:
            from pwn import asm

            # Determine architecture
            arch = getattr(self.binary, 'arch', 'amd64')
            bits = getattr(self.binary, 'bits', 64)

            if reg:
                regs = [reg]
            elif bits == 64:
                regs = ['rsp', 'rsi', 'rdi', 'rax', 'rbx', 'rcx', 'rdx',
                        'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15']
            else:
                regs = ['esp', 'esi', 'edi', 'eax', 'ebx', 'ecx', 'edx']

            for r in regs:
                try:
                    call_bytes = asm(f'call {r}', arch=arch)
                    results = list(self.binary._elf.search(call_bytes))
                    if results:
                        addr = results[0]
                        g = Gadget(
                            address=addr,
                            instructions=f"call {r}",
                            raw_bytes=call_bytes,
                            gadget_type=GadgetType.CALL_REG,
                            target_reg=r,
                            is_ret=False,
                            is_call=True,
                        )
                        return g
                except Exception:
                    pass
        except Exception as e:
            logger.debug(f"call reg search failed: {e}")

        return None

    def find_all_ret2reg(self) -> Dict[str, List[Gadget]]:
        """
        Find all ret2reg gadgets (jmp reg and call reg).

        These gadgets are essential when:
        - NX is disabled and shellcode can be executed
        - A register points to the buffer containing shellcode
        - Traditional ROP is not needed/possible

        Returns:
            Dict with 'jmp' and 'call' keys mapping to lists of gadgets
        """
        result = {'jmp': [], 'call': []}

        bits = getattr(self.binary, 'bits', 64)
        if bits == 64:
            regs = ['rsp', 'rsi', 'rdi', 'rax', 'rbx', 'rcx', 'rdx',
                    'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15']
        else:
            regs = ['esp', 'esi', 'edi', 'eax', 'ebx', 'ecx', 'edx']

        for reg in regs:
            jmp_g = self.find_jmp_reg(reg)
            if jmp_g:
                result['jmp'].append(jmp_g)

            call_g = self.find_call_reg(reg)
            if call_g:
                result['call'].append(call_g)

        logger.info(f"Found {len(result['jmp'])} jmp reg and {len(result['call'])} call reg gadgets")
        return result

    def find_ret2reg_for_register(self, reg: str) -> Optional[Gadget]:
        """
        Find a ret2reg gadget for a specific register.

        Useful when you know which register contains the buffer address.

        Args:
            reg: Target register (e.g., 'rsi', 'rax')

        Returns:
            Best matching Gadget (prefers jmp over call) or None
        """
        # Prefer jmp reg over call reg (simpler control flow)
        jmp = self.find_jmp_reg(reg)
        if jmp:
            return jmp

        call = self.find_call_reg(reg)
        if call:
            return call

        return None

    def get_ret2reg_gadget_for_buffer(
        self,
        buffer_reg: str,
        avoid_regs: Optional[List[str]] = None,
    ) -> Optional[Gadget]:
        """
        Find ret2reg gadget when buffer address is in a specific register.

        Args:
            buffer_reg: Register containing buffer address
            avoid_regs: Registers to avoid (may be clobbered)

        Returns:
            Suitable Gadget or None
        """
        avoid_regs = avoid_regs or []

        # First try direct match
        gadget = self.find_ret2reg_for_register(buffer_reg)
        if gadget:
            return gadget

        # If buffer is in a non-standard register, we might need to
        # find a mov gadget first to move it to a register with jmp/call
        logger.debug(f"No direct ret2reg for {buffer_reg}, checking alternatives")

        return None

    def find_shellcode_pivots(self) -> Dict[str, Gadget]:
        """
        Find all gadgets useful for jumping to shellcode.

        When NX is disabled, these gadgets allow execution of shellcode
        placed in registers or on the stack.

        Returns:
            Dict mapping gadget type to Gadget (e.g., 'jmp rsi': Gadget)
        """
        pivots = {}

        # Find jmp reg gadgets
        for reg in ['rsp', 'rsi', 'rdi', 'rax', 'rbx', 'rcx', 'rdx']:
            g = self.find_jmp_reg(reg)
            if g:
                pivots[f'jmp {reg}'] = g

        # Find call reg gadgets
        for reg in ['rsp', 'rsi', 'rdi', 'rax', 'rbx', 'rcx', 'rdx']:
            g = self.find_call_reg(reg)
            if g:
                pivots[f'call {reg}'] = g

        # Find push reg; ret (can pivot to shellcode on stack)
        for reg in ['rsp', 'rsi', 'rdi', 'rax']:
            g = self.find_gadget([f'push {reg}', 'ret'])
            if g:
                pivots[f'push {reg}; ret'] = g

        return pivots

    def find_pop_rsp(self) -> Optional[Gadget]:
        """Find pop rsp gadget for stack pivot."""
        return self.find_gadget(["pop rsp"])

    def find_xchg_rsp(self, reg: str) -> Optional[Gadget]:
        """Find xchg rsp, reg gadget."""
        return self.find_gadget([f"xchg {reg}, rsp"]) or \
               self.find_gadget([f"xchg rsp, {reg}"])

    def find_write_gadget(self) -> Optional[Gadget]:
        """Find mov [reg], reg gadget for write primitive."""
        patterns = [
            ["mov [rdi], rsi"],
            ["mov [rdi], rdx"],
            ["mov [rax], rdx"],
            ["mov qword ptr [rdi], rsi"],
        ]
        for pattern in patterns:
            g = self.find_gadget(pattern)
            if g:
                return g
        return None

    def find_add_gadget(self, reg: str) -> Optional[Gadget]:
        """Find add reg, value gadget."""
        return self.find_gadget([f"add {reg}"])

    def get_gadgets_for_regs(
        self,
        regs: List[str],
    ) -> Dict[str, Optional[Gadget]]:
        """
        Find pop gadgets for multiple registers.

        Args:
            regs: List of register names

        Returns:
            Dict of reg -> Gadget
        """
        result = {}
        for reg in regs:
            result[reg] = self.find_pop_reg(reg)
        return result

    def filter_by_bad_chars(
        self,
        gadgets: List[Gadget],
        bad_chars: List[int],
    ) -> List[Gadget]:
        """
        Filter gadgets containing bad characters.

        Args:
            gadgets: Gadgets to filter
            bad_chars: Bad byte values

        Returns:
            Filtered gadgets
        """
        bad_set = set(bad_chars)

        def contains_bad(addr: int) -> bool:
            addr_bytes = addr.to_bytes(8, 'little')
            return any(b in bad_set for b in addr_bytes)

        return [g for g in gadgets if not contains_bad(g.address)]

    def summary(self) -> str:
        """Get gadget summary."""
        if not self._gadgets:
            self.find_gadgets()

        # Count by type
        syscall = len([g for g in self._gadgets.values() if "syscall" in g.instructions])
        pop = len([g for g in self._gadgets.values() if "pop" in g.instructions])
        mov = len([g for g in self._gadgets.values() if "mov" in g.instructions])

        return f"""
Gadget Summary
==============
Total gadgets: {len(self._gadgets)}
Pop gadgets: {pop}
Mov gadgets: {mov}
Syscall gadgets: {syscall}
"""
