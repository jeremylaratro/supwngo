"""
Z3 SMT-based ROP chain solver.

Uses constraint solving to automatically find optimal ROP gadget chains
that satisfy complex requirements (register values, memory writes, etc.)
while respecting constraints (bad characters, alignment, chain length).
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union

try:
    from z3 import (
        And, BitVec, BitVecVal, Concat, Extract, If, Implies, Int, IntVal,
        Not, Or, Optimize, Solver, UDiv, ULT, URem, sat, unsat, simplify
    )
    Z3_AVAILABLE = True
except ImportError:
    Z3_AVAILABLE = False

from supwngo.exploit.rop.gadgets import Gadget, GadgetType
from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class SolverGoal(Enum):
    """Types of goals the solver can achieve."""
    CALL_FUNCTION = auto()      # Call function with arguments
    WRITE_MEMORY = auto()       # Write value to address
    READ_MEMORY = auto()        # Read from address into register
    SET_REGISTERS = auto()      # Set specific register values
    SYSCALL = auto()            # Perform syscall with args
    STACK_PIVOT = auto()        # Pivot stack to controlled buffer
    SHELLCODE_EXEC = auto()     # Jump to shellcode


@dataclass
class GadgetEffect:
    """
    Describes the effect of executing a gadget.

    This models what a gadget does to the CPU state.
    """
    address: int
    instructions: str

    # Register effects
    sets_reg: Dict[str, Union[int, str]] = field(default_factory=dict)
    # e.g., {"rdi": "stack[0]", "rsi": 0x1234}

    reads_stack: int = 0        # Number of values popped from stack
    stack_delta: int = 8        # Net RSP change (includes ret)

    # Registers clobbered (set to unknown values)
    clobbers: Set[str] = field(default_factory=set)

    # Registers preserved
    preserves: Set[str] = field(default_factory=set)

    # Memory effects
    writes_mem: Optional[Tuple[str, str]] = None  # (addr_reg, val_reg)
    reads_mem: Optional[Tuple[str, str]] = None   # (dst_reg, addr_reg)

    # Control flow
    is_syscall: bool = False
    is_call: bool = False
    call_target: Optional[str] = None  # Register for call/jmp

    def __hash__(self):
        return hash(self.address)


@dataclass
class ChainConstraints:
    """Constraints for ROP chain generation."""
    bad_chars: bytes = b""              # Bytes that cannot appear in chain
    max_chain_length: int = 50          # Maximum number of gadgets
    require_alignment: bool = True       # Require 16-byte stack alignment
    alignment_at_call: int = 16         # Required alignment when calling
    preserve_regs: Set[str] = field(default_factory=set)  # Don't clobber these


@dataclass
class SolvedChain:
    """Result of successful chain solving."""
    gadgets: List[Tuple[int, str]]      # (address, description)
    stack_values: List[int]              # Values to place on stack
    total_length: int                    # Total bytes
    description: str = ""

    def build(self, bits: int = 64) -> bytes:
        """Build the actual payload bytes."""
        pack = p64 if bits == 64 else p32
        payload = b""

        stack_idx = 0
        for addr, desc in self.gadgets:
            payload += pack(addr)
            # Add any stack values this gadget pops
            # This is simplified - real implementation tracks per-gadget

        for val in self.stack_values:
            payload += pack(val)

        return payload

    def dump(self) -> str:
        """Pretty print the chain."""
        lines = [f"ROP Chain ({len(self.gadgets)} gadgets, {self.total_length} bytes)"]
        lines.append("=" * 60)

        for i, (addr, desc) in enumerate(self.gadgets):
            lines.append(f"  [{i:2d}] 0x{addr:016x}: {desc}")

        if self.stack_values:
            lines.append("\nStack values:")
            for i, val in enumerate(self.stack_values):
                lines.append(f"  [{i:2d}] 0x{val:016x}")

        return "\n".join(lines)


class Z3ROPSolver:
    """
    SMT-based ROP chain solver.

    Uses Z3 to find gadget chains that achieve specified goals
    while satisfying all constraints.

    Example:
        solver = Z3ROPSolver(gadgets, arch='amd64')

        # Find chain to call system("/bin/sh")
        chain = solver.solve_call(
            target=libc.sym['system'],
            args=[binsh_addr],
            bad_chars=b'\\x00'
        )
    """

    # Register names per architecture
    REGS_64 = ['rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi', 'rbp', 'rsp',
               'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15']
    REGS_32 = ['eax', 'ebx', 'ecx', 'edx', 'esi', 'edi', 'ebp', 'esp']

    # Argument registers (System V AMD64 ABI)
    ARG_REGS_64 = ['rdi', 'rsi', 'rdx', 'rcx', 'r8', 'r9']
    ARG_REGS_32 = ['ecx', 'edx']  # cdecl uses stack, but some use regs

    # Syscall number register
    SYSCALL_REG_64 = 'rax'
    SYSCALL_REG_32 = 'eax'

    def __init__(
        self,
        gadgets: List[Gadget],
        arch: str = 'amd64',
        bits: int = 64
    ):
        """
        Initialize solver.

        Args:
            gadgets: List of available gadgets
            arch: Architecture ('amd64', 'i386', 'arm', 'aarch64')
            bits: Bit width (64 or 32)
        """
        if not Z3_AVAILABLE:
            raise ImportError("z3-solver is required. Install with: pip install z3-solver")

        self.gadgets = gadgets
        self.arch = arch
        self.bits = bits

        # Select registers for architecture (must be set before analyzing gadgets)
        self.regs = self.REGS_64 if bits == 64 else self.REGS_32
        self.arg_regs = self.ARG_REGS_64 if bits == 64 else self.ARG_REGS_32

        # Build gadget effects database
        self.effects = self._analyze_gadgets()

        logger.debug(f"Z3ROPSolver initialized with {len(gadgets)} gadgets")

    def _analyze_gadgets(self) -> Dict[int, GadgetEffect]:
        """Analyze gadgets to determine their effects."""
        effects = {}

        for gadget in self.gadgets:
            effect = self._analyze_single_gadget(gadget)
            if effect:
                effects[gadget.address] = effect

        logger.debug(f"Analyzed {len(effects)} gadget effects")
        return effects

    def _analyze_single_gadget(self, gadget: Gadget) -> Optional[GadgetEffect]:
        """Analyze a single gadget's effect on CPU state."""
        instr = gadget.instructions.lower().strip()
        effect = GadgetEffect(
            address=gadget.address,
            instructions=gadget.instructions
        )

        # Parse common gadget patterns
        parts = [p.strip() for p in instr.replace(';', '\n').split('\n') if p.strip()]

        stack_pops = 0
        for part in parts:
            part = part.strip()
            if not part or part == 'ret':
                continue

            # pop reg
            if part.startswith('pop '):
                reg = part[4:].strip()
                effect.sets_reg[reg] = f"stack[{stack_pops}]"
                stack_pops += 1

            # mov dst, src
            elif part.startswith('mov '):
                match = self._parse_mov(part)
                if match:
                    dst, src = match
                    if src in self.regs:
                        effect.sets_reg[dst] = src
                    elif src.isdigit() or src.startswith('0x'):
                        effect.sets_reg[dst] = int(src, 0)

            # xor reg, reg (zero)
            elif part.startswith('xor '):
                regs = part[4:].split(',')
                if len(regs) == 2 and regs[0].strip() == regs[1].strip():
                    effect.sets_reg[regs[0].strip()] = 0

            # Memory write: mov [reg], reg
            elif '[' in part and part.startswith('mov '):
                if self._is_mem_write(part):
                    addr_reg, val_reg = self._parse_mem_write(part)
                    if addr_reg and val_reg:
                        effect.writes_mem = (addr_reg, val_reg)

            # syscall
            elif part in ('syscall', 'int 0x80'):
                effect.is_syscall = True

            # call/jmp reg
            elif part.startswith('call ') or part.startswith('jmp '):
                target = part.split()[1]
                if target in self.regs:
                    effect.is_call = True
                    effect.call_target = target

        effect.reads_stack = stack_pops
        effect.stack_delta = (stack_pops * (self.bits // 8)) + (self.bits // 8)  # +ret

        # Determine clobbered registers
        effect.clobbers = set(effect.sets_reg.keys())

        return effect

    def _parse_mov(self, instr: str) -> Optional[Tuple[str, str]]:
        """Parse mov instruction to get dst, src."""
        try:
            parts = instr[4:].split(',')
            if len(parts) == 2:
                return parts[0].strip(), parts[1].strip()
        except:
            pass
        return None

    def _is_mem_write(self, instr: str) -> bool:
        """Check if instruction writes to memory."""
        return '[' in instr.split(',')[0] if ',' in instr else False

    def _parse_mem_write(self, instr: str) -> Tuple[Optional[str], Optional[str]]:
        """Parse memory write: mov [addr_reg], val_reg."""
        try:
            parts = instr[4:].split(',')
            addr_part = parts[0].strip()
            val_part = parts[1].strip()

            # Extract register from [reg] or [reg+offset]
            import re
            match = re.search(r'\[(\w+)', addr_part)
            if match:
                addr_reg = match.group(1)
                return addr_reg, val_part
        except:
            pass
        return None, None

    def solve_call(
        self,
        target: int,
        args: List[int],
        constraints: Optional[ChainConstraints] = None
    ) -> Optional[SolvedChain]:
        """
        Find gadget chain to call function with arguments.

        Args:
            target: Address of function to call
            args: List of argument values
            constraints: Optional constraints

        Returns:
            SolvedChain if solution found, None otherwise
        """
        if constraints is None:
            constraints = ChainConstraints()

        logger.info(f"Solving for call to 0x{target:x} with {len(args)} args")

        # Strategy: Find gadgets to set argument registers, then jump/call target

        chain_gadgets = []
        chain_stack = []

        # Step 1: Set up arguments in registers
        for i, arg in enumerate(args):
            if i >= len(self.arg_regs):
                logger.warning(f"Too many arguments ({len(args)}), only {len(self.arg_regs)} regs available")
                break

            reg = self.arg_regs[i]
            gadget, stack_vals = self._find_gadget_to_set_reg(reg, arg, constraints)

            if gadget is None:
                logger.error(f"Cannot find gadget to set {reg} = 0x{arg:x}")
                return None

            chain_gadgets.append((gadget.address, gadget.instructions))
            chain_stack.extend(stack_vals)

        # Step 2: Add target address (will be executed via ret)
        chain_gadgets.append((target, f"call target @ 0x{target:x}"))

        # Verify no bad characters
        if constraints.bad_chars:
            pack = p64 if self.bits == 64 else p32
            for addr, _ in chain_gadgets:
                if any(b in pack(addr) for b in constraints.bad_chars):
                    logger.warning(f"Gadget 0x{addr:x} contains bad characters")
                    # Could try to find alternative here

        return SolvedChain(
            gadgets=chain_gadgets,
            stack_values=chain_stack,
            total_length=len(chain_gadgets) * (self.bits // 8) + len(chain_stack) * (self.bits // 8),
            description=f"Call 0x{target:x}({', '.join(f'0x{a:x}' for a in args)})"
        )

    def _find_gadget_to_set_reg(
        self,
        reg: str,
        value: int,
        constraints: ChainConstraints
    ) -> Tuple[Optional[GadgetEffect], List[int]]:
        """Find gadget(s) to set register to specific value."""

        # Strategy 1: Direct pop
        for addr, effect in self.effects.items():
            if reg in effect.sets_reg:
                stack_ref = effect.sets_reg[reg]
                if isinstance(stack_ref, str) and stack_ref.startswith('stack['):
                    # This gadget pops the value from stack
                    idx = int(stack_ref[6:-1])
                    stack_vals = [0] * (idx + 1)
                    stack_vals[idx] = value

                    # Check bad chars
                    if not self._has_bad_chars(addr, constraints.bad_chars):
                        return effect, stack_vals

        # Strategy 2: xor reg, reg (for zero)
        if value == 0:
            for addr, effect in self.effects.items():
                if reg in effect.sets_reg and effect.sets_reg[reg] == 0:
                    if not self._has_bad_chars(addr, constraints.bad_chars):
                        return effect, []

        # Strategy 3: mov reg, other_reg (if we can set other_reg)
        # This would require recursion - simplified for now

        return None, []

    def _has_bad_chars(self, addr: int, bad_chars: bytes) -> bool:
        """Check if address contains bad characters."""
        if not bad_chars:
            return False
        pack = p64 if self.bits == 64 else p32
        addr_bytes = pack(addr)
        return any(b in addr_bytes for b in bad_chars)

    def solve_write(
        self,
        what: int,
        where: int,
        constraints: Optional[ChainConstraints] = None
    ) -> Optional[SolvedChain]:
        """
        Find gadget chain to write value to address.

        Args:
            what: Value to write
            where: Address to write to
            constraints: Optional constraints

        Returns:
            SolvedChain if solution found
        """
        if constraints is None:
            constraints = ChainConstraints()

        logger.info(f"Solving for write: *0x{where:x} = 0x{what:x}")

        # Find write gadgets: mov [reg1], reg2
        write_gadgets = []
        for addr, effect in self.effects.items():
            if effect.writes_mem:
                write_gadgets.append(effect)

        if not write_gadgets:
            logger.error("No write gadgets found")
            return None

        # Try each write gadget
        for write_effect in write_gadgets:
            addr_reg, val_reg = write_effect.writes_mem

            chain_gadgets = []
            chain_stack = []

            # Set up address register
            addr_gadget, addr_stack = self._find_gadget_to_set_reg(
                addr_reg, where, constraints
            )
            if addr_gadget is None:
                continue

            chain_gadgets.append((addr_gadget.address, addr_gadget.instructions))
            chain_stack.extend(addr_stack)

            # Set up value register
            val_gadget, val_stack = self._find_gadget_to_set_reg(
                val_reg, what, constraints
            )
            if val_gadget is None:
                continue

            chain_gadgets.append((val_gadget.address, val_gadget.instructions))
            chain_stack.extend(val_stack)

            # Add write gadget
            chain_gadgets.append((write_effect.address, write_effect.instructions))

            return SolvedChain(
                gadgets=chain_gadgets,
                stack_values=chain_stack,
                total_length=len(chain_gadgets) * (self.bits // 8) + len(chain_stack) * (self.bits // 8),
                description=f"Write 0x{what:x} to 0x{where:x}"
            )

        return None

    def solve_syscall(
        self,
        syscall_num: int,
        args: List[int],
        constraints: Optional[ChainConstraints] = None
    ) -> Optional[SolvedChain]:
        """
        Find gadget chain to perform syscall.

        Args:
            syscall_num: Syscall number (e.g., 59 for execve on x86-64)
            args: Syscall arguments
            constraints: Optional constraints

        Returns:
            SolvedChain if solution found
        """
        if constraints is None:
            constraints = ChainConstraints()

        logger.info(f"Solving for syscall {syscall_num} with {len(args)} args")

        chain_gadgets = []
        chain_stack = []

        # Set syscall number in rax/eax
        syscall_reg = self.SYSCALL_REG_64 if self.bits == 64 else self.SYSCALL_REG_32
        rax_gadget, rax_stack = self._find_gadget_to_set_reg(
            syscall_reg, syscall_num, constraints
        )
        if rax_gadget is None:
            logger.error(f"Cannot set {syscall_reg} to syscall number")
            return None

        chain_gadgets.append((rax_gadget.address, rax_gadget.instructions))
        chain_stack.extend(rax_stack)

        # Set arguments
        for i, arg in enumerate(args):
            if i >= len(self.arg_regs):
                break

            reg = self.arg_regs[i]
            gadget, stack_vals = self._find_gadget_to_set_reg(reg, arg, constraints)

            if gadget is None:
                logger.error(f"Cannot set {reg} for arg {i}")
                return None

            chain_gadgets.append((gadget.address, gadget.instructions))
            chain_stack.extend(stack_vals)

        # Find syscall gadget
        syscall_effect = None
        for addr, effect in self.effects.items():
            if effect.is_syscall:
                if not self._has_bad_chars(addr, constraints.bad_chars):
                    syscall_effect = effect
                    break

        if syscall_effect is None:
            logger.error("No syscall gadget found")
            return None

        chain_gadgets.append((syscall_effect.address, syscall_effect.instructions))

        return SolvedChain(
            gadgets=chain_gadgets,
            stack_values=chain_stack,
            total_length=len(chain_gadgets) * (self.bits // 8) + len(chain_stack) * (self.bits // 8),
            description=f"syscall({syscall_num}, {', '.join(f'0x{a:x}' for a in args)})"
        )

    def solve_execve(
        self,
        binsh_addr: int,
        constraints: Optional[ChainConstraints] = None
    ) -> Optional[SolvedChain]:
        """
        Convenience method to solve for execve("/bin/sh", NULL, NULL).

        Args:
            binsh_addr: Address of "/bin/sh" string
            constraints: Optional constraints

        Returns:
            SolvedChain for execve
        """
        # x86-64: execve is syscall 59
        # Args: rdi = filename, rsi = argv, rdx = envp
        if self.bits == 64:
            return self.solve_syscall(59, [binsh_addr, 0, 0], constraints)
        else:
            # x86: execve is syscall 11
            return self.solve_syscall(11, [binsh_addr, 0, 0], constraints)

    def solve_mprotect(
        self,
        addr: int,
        size: int,
        prot: int = 7,  # RWX
        constraints: Optional[ChainConstraints] = None
    ) -> Optional[SolvedChain]:
        """
        Solve for mprotect to make memory executable.

        Args:
            addr: Page-aligned address
            size: Size (usually page size)
            prot: Protection flags (7 = RWX)
            constraints: Optional constraints

        Returns:
            SolvedChain for mprotect
        """
        # x86-64: mprotect is syscall 10
        if self.bits == 64:
            return self.solve_syscall(10, [addr, size, prot], constraints)
        else:
            # x86: mprotect is syscall 125
            return self.solve_syscall(125, [addr, size, prot], constraints)

    def find_pop_gadgets(self) -> Dict[str, GadgetEffect]:
        """Find all pop gadgets for each register."""
        pop_gadgets = {}

        for addr, effect in self.effects.items():
            for reg, source in effect.sets_reg.items():
                if isinstance(source, str) and source.startswith('stack['):
                    if reg not in pop_gadgets:
                        pop_gadgets[reg] = effect
                    else:
                        # Prefer shorter gadgets (less clobbering)
                        if len(effect.clobbers) < len(pop_gadgets[reg].clobbers):
                            pop_gadgets[reg] = effect

        return pop_gadgets

    def find_write_gadgets(self) -> List[GadgetEffect]:
        """Find all memory write gadgets."""
        return [e for e in self.effects.values() if e.writes_mem]

    def find_syscall_gadgets(self) -> List[GadgetEffect]:
        """Find all syscall gadgets."""
        return [e for e in self.effects.values() if e.is_syscall]

    def get_solver_stats(self) -> Dict[str, Any]:
        """Get statistics about available gadgets."""
        pop_gadgets = self.find_pop_gadgets()
        write_gadgets = self.find_write_gadgets()
        syscall_gadgets = self.find_syscall_gadgets()

        return {
            "total_gadgets": len(self.gadgets),
            "analyzed_effects": len(self.effects),
            "pop_gadgets": {reg: f"0x{g.address:x}" for reg, g in pop_gadgets.items()},
            "write_gadgets": len(write_gadgets),
            "syscall_gadgets": len(syscall_gadgets),
            "can_set_args": all(r in pop_gadgets for r in self.arg_regs[:3]),
            "can_syscall": len(syscall_gadgets) > 0,
        }


# Convenience function
def solve_rop_chain(
    gadgets: List[Gadget],
    goal: SolverGoal,
    target: Optional[int] = None,
    args: Optional[List[int]] = None,
    what: Optional[int] = None,
    where: Optional[int] = None,
    arch: str = 'amd64',
    bad_chars: bytes = b""
) -> Optional[SolvedChain]:
    """
    Convenience function to solve for ROP chain.

    Args:
        gadgets: Available gadgets
        goal: What to achieve
        target: Target address (for CALL_FUNCTION)
        args: Arguments (for CALL_FUNCTION, SYSCALL)
        what: Value to write (for WRITE_MEMORY)
        where: Address to write to (for WRITE_MEMORY)
        arch: Architecture
        bad_chars: Bad characters to avoid

    Returns:
        SolvedChain if solution found
    """
    solver = Z3ROPSolver(gadgets, arch=arch)
    constraints = ChainConstraints(bad_chars=bad_chars)

    if goal == SolverGoal.CALL_FUNCTION:
        return solver.solve_call(target, args or [], constraints)
    elif goal == SolverGoal.WRITE_MEMORY:
        return solver.solve_write(what, where, constraints)
    elif goal == SolverGoal.SYSCALL:
        return solver.solve_syscall(args[0] if args else 0, args[1:] if args else [], constraints)

    return None
