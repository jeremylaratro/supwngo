"""
Report generator for multiple output formats.

Supports HTML, Markdown, PDF, and JSON reports.
"""

import json
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Union
import html

from supwngo.reporting.templates import (
    VulnerabilityReport,
    ExploitReport,
    AssessmentReport,
    BinaryInfo,
    VulnerabilityFinding,
)
from supwngo.reporting.cvss import CVSSCalculator
from supwngo.reporting.sarif import SARIFExporter
from supwngo.utils.logging import get_logger

logger = get_logger(__name__)


class ReportFormat(Enum):
    """Supported report formats."""
    HTML = "html"
    MARKDOWN = "md"
    JSON = "json"
    SARIF = "sarif"
    PDF = "pdf"
    TEXT = "txt"


@dataclass
class ReportConfig:
    """Report generation configuration."""
    format: ReportFormat = ReportFormat.HTML
    include_poc: bool = True
    include_payloads: bool = True
    include_cvss: bool = True
    include_recommendations: bool = True
    redact_addresses: bool = False
    template_path: Optional[str] = None
    css_path: Optional[str] = None
    logo_path: Optional[str] = None
    footer_text: str = "Generated by supwngo"


class ReportGenerator:
    """
    Generate reports in multiple formats.

    Example:
        gen = ReportGenerator()

        # Create vulnerability report
        report = VulnerabilityReport(
            title="Security Assessment",
            binary=BinaryInfo(name="target", path="/path/to/target"),
        )

        report.add_finding(VulnerabilityFinding(
            vuln_type="stack_buffer_overflow",
            severity="critical",
            description="Stack buffer overflow in main()",
        ))

        # Generate HTML
        html_content = gen.generate(report, ReportFormat.HTML)

        # Save to file
        gen.save(report, "report.html", ReportFormat.HTML)
    """

    DEFAULT_CSS = """
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
        line-height: 1.6;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        color: #333;
    }
    h1, h2, h3 { color: #2c3e50; }
    .header { border-bottom: 2px solid #3498db; padding-bottom: 10px; margin-bottom: 20px; }
    .severity-critical { color: #c0392b; font-weight: bold; }
    .severity-high { color: #e74c3c; font-weight: bold; }
    .severity-medium { color: #f39c12; font-weight: bold; }
    .severity-low { color: #27ae60; }
    .severity-info { color: #3498db; }
    .finding { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin: 10px 0; }
    .finding-critical { border-left: 4px solid #c0392b; }
    .finding-high { border-left: 4px solid #e74c3c; }
    .finding-medium { border-left: 4px solid #f39c12; }
    .finding-low { border-left: 4px solid #27ae60; }
    .code { background: #f4f4f4; padding: 10px; border-radius: 3px; font-family: monospace; overflow-x: auto; }
    .summary-box { background: #ecf0f1; padding: 15px; border-radius: 5px; margin: 15px 0; }
    .protection { display: inline-block; padding: 3px 8px; margin: 2px; border-radius: 3px; font-size: 0.9em; }
    .protection-enabled { background: #27ae60; color: white; }
    .protection-disabled { background: #e74c3c; color: white; }
    table { width: 100%; border-collapse: collapse; margin: 15px 0; }
    th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
    th { background: #3498db; color: white; }
    tr:nth-child(even) { background: #f9f9f9; }
    .footer { margin-top: 30px; padding-top: 10px; border-top: 1px solid #ddd; font-size: 0.9em; color: #666; }
    """

    def __init__(self, config: Optional[ReportConfig] = None):
        """
        Initialize report generator.

        Args:
            config: Report configuration
        """
        self.config = config or ReportConfig()
        self.cvss_calc = CVSSCalculator()

    def generate(
        self,
        report: Union[VulnerabilityReport, ExploitReport, AssessmentReport],
        format: Optional[ReportFormat] = None,
    ) -> str:
        """
        Generate report content.

        Args:
            report: Report data
            format: Output format (uses config default if not specified)

        Returns:
            Report content as string
        """
        format = format or self.config.format

        if format == ReportFormat.HTML:
            return self._generate_html(report)
        elif format == ReportFormat.MARKDOWN:
            return self._generate_markdown(report)
        elif format == ReportFormat.JSON:
            return self._generate_json(report)
        elif format == ReportFormat.SARIF:
            return self._generate_sarif(report)
        elif format == ReportFormat.TEXT:
            return self._generate_text(report)
        elif format == ReportFormat.PDF:
            return self._generate_pdf_placeholder(report)
        else:
            raise ValueError(f"Unsupported format: {format}")

    def save(
        self,
        report: Union[VulnerabilityReport, ExploitReport, AssessmentReport],
        output_path: str,
        format: Optional[ReportFormat] = None,
    ):
        """
        Generate and save report to file.

        Args:
            report: Report data
            output_path: Output file path
            format: Output format (inferred from extension if not specified)
        """
        # Infer format from extension if not specified
        if format is None:
            ext = Path(output_path).suffix.lower()
            format_map = {
                ".html": ReportFormat.HTML,
                ".htm": ReportFormat.HTML,
                ".md": ReportFormat.MARKDOWN,
                ".json": ReportFormat.JSON,
                ".sarif": ReportFormat.SARIF,
                ".txt": ReportFormat.TEXT,
                ".pdf": ReportFormat.PDF,
            }
            format = format_map.get(ext, self.config.format)

        content = self.generate(report, format)
        Path(output_path).write_text(content)
        logger.info(f"Report saved to {output_path}")

    def _generate_html(
        self,
        report: Union[VulnerabilityReport, ExploitReport, AssessmentReport]
    ) -> str:
        """Generate HTML report."""
        css = self.DEFAULT_CSS

        if isinstance(report, VulnerabilityReport):
            return self._vuln_report_html(report, css)
        elif isinstance(report, ExploitReport):
            return self._exploit_report_html(report, css)
        elif isinstance(report, AssessmentReport):
            return self._assessment_report_html(report, css)
        else:
            raise ValueError(f"Unknown report type: {type(report)}")

    def _vuln_report_html(self, report: VulnerabilityReport, css: str) -> str:
        """Generate vulnerability report HTML."""
        findings_html = ""
        for finding in report.findings:
            sev = finding.severity.lower()
            findings_html += f"""
            <div class="finding finding-{sev}">
                <h3>{html.escape(finding.vuln_type)}</h3>
                <p><strong>Severity:</strong> <span class="severity-{sev}">{finding.severity.upper()}</span></p>
                <p><strong>Description:</strong> {html.escape(finding.description)}</p>
            """
            if finding.location:
                loc = finding.location if not self.config.redact_addresses else "[REDACTED]"
                findings_html += f"<p><strong>Location:</strong> {html.escape(loc)}</p>"
            if finding.address and not self.config.redact_addresses:
                findings_html += f"<p><strong>Address:</strong> 0x{finding.address:x}</p>"
            if finding.cvss_score > 0 and self.config.include_cvss:
                findings_html += f"<p><strong>CVSS:</strong> {finding.cvss_score} ({finding.cvss_vector})</p>"
            if finding.recommendations and self.config.include_recommendations:
                findings_html += "<p><strong>Recommendations:</strong></p><ul>"
                for rec in finding.recommendations:
                    findings_html += f"<li>{html.escape(rec)}</li>"
                findings_html += "</ul>"
            if finding.proof_of_concept and self.config.include_poc:
                findings_html += f'<p><strong>Proof of Concept:</strong></p><pre class="code">{html.escape(finding.proof_of_concept)}</pre>'
            findings_html += "</div>"

        counts = report.get_severity_counts()
        summary_html = f"""
        <div class="summary-box">
            <h3>Summary</h3>
            <p>Total Findings: {len(report.findings)}</p>
            <p>Overall Risk: <strong>{report.get_overall_risk()}</strong></p>
            <table>
                <tr><th>Critical</th><th>High</th><th>Medium</th><th>Low</th><th>Info</th></tr>
                <tr>
                    <td class="severity-critical">{counts['critical']}</td>
                    <td class="severity-high">{counts['high']}</td>
                    <td class="severity-medium">{counts['medium']}</td>
                    <td class="severity-low">{counts['low']}</td>
                    <td class="severity-info">{counts['info']}</td>
                </tr>
            </table>
        </div>
        """

        protections_html = ""
        if report.binary.protections:
            protections_html = "<h3>Binary Protections</h3>"
            for prot, enabled in report.binary.protections.items():
                cls = "protection-enabled" if enabled else "protection-disabled"
                status = "Enabled" if enabled else "Disabled"
                protections_html += f'<span class="protection {cls}">{prot}: {status}</span> '

        return f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{html.escape(report.title)}</title>
    <style>{css}</style>
</head>
<body>
    <div class="header">
        <h1>{html.escape(report.title)}</h1>
        <p>Binary: {html.escape(report.binary.name)} | Date: {report.date}</p>
    </div>

    {summary_html}

    <h2>Binary Information</h2>
    <table>
        <tr><td><strong>Name</strong></td><td>{html.escape(report.binary.name)}</td></tr>
        <tr><td><strong>Architecture</strong></td><td>{report.binary.architecture}</td></tr>
        <tr><td><strong>Bits</strong></td><td>{report.binary.bits}</td></tr>
        <tr><td><strong>File Size</strong></td><td>{report.binary.file_size:,} bytes</td></tr>
    </table>

    {protections_html}

    <h2>Findings</h2>
    {findings_html}

    <div class="footer">
        <p>{self.config.footer_text} | {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
</body>
</html>"""

    def _exploit_report_html(self, report: ExploitReport, css: str) -> str:
        """Generate exploit report HTML."""
        steps_html = ""
        for step in report.steps:
            steps_html += f"""
            <div class="finding">
                <h4>Step {step.step_number}: {html.escape(step.description)}</h4>
            """
            if step.code:
                steps_html += f'<pre class="code">{html.escape(step.code)}</pre>'
            if step.notes:
                steps_html += f"<p><em>{html.escape(step.notes)}</em></p>"
            steps_html += "</div>"

        techniques_html = ", ".join(report.techniques) if report.techniques else "N/A"

        payload_html = ""
        if self.config.include_payloads and (report.payload or report.payload_hex):
            payload_html = "<h3>Payload</h3>"
            if report.payload:
                payload_html += f'<pre class="code">{html.escape(report.payload)}</pre>'
            if report.payload_hex:
                payload_html += f'<p><strong>Hex:</strong> <code>{html.escape(report.payload_hex)}</code></p>'

        script_html = ""
        if self.config.include_poc and report.script:
            script_html = f'<h3>Exploit Script</h3><pre class="code">{html.escape(report.script)}</pre>'

        return f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{html.escape(report.title)}</title>
    <style>{css}</style>
</head>
<body>
    <div class="header">
        <h1>{html.escape(report.title)}</h1>
        <p>Exploit Documentation | Date: {report.date}</p>
    </div>

    <h2>Target</h2>
    <table>
        <tr><td><strong>Binary</strong></td><td>{html.escape(report.binary.name)}</td></tr>
        <tr><td><strong>Vulnerability</strong></td><td>{html.escape(report.vulnerability.vuln_type)}</td></tr>
        <tr><td><strong>Exploit Type</strong></td><td>{html.escape(report.exploit_type)}</td></tr>
        <tr><td><strong>Techniques</strong></td><td>{html.escape(techniques_html)}</td></tr>
        <tr><td><strong>Success Rate</strong></td><td>{report.success_rate:.1%}</td></tr>
    </table>

    <h2>Exploitation Steps</h2>
    {steps_html}

    {payload_html}
    {script_html}

    <div class="footer">
        <p>{self.config.footer_text}</p>
    </div>
</body>
</html>"""

    def _assessment_report_html(self, report: AssessmentReport, css: str) -> str:
        """Generate full assessment report HTML."""
        # Generate executive summary if not provided
        exec_summary = report.executive_summary or report.generate_executive_summary()

        binaries_html = ""
        for binary in report.binaries:
            binaries_html += f"<li>{html.escape(binary.name)} ({binary.architecture}, {binary.bits}-bit)</li>"

        vuln_sections = ""
        for vuln_report in report.vulnerability_reports:
            vuln_sections += f"<h3>{html.escape(vuln_report.binary.name)}</h3>"
            vuln_sections += self._vuln_report_html(vuln_report, "").replace("<!DOCTYPE html>", "").split("<body>")[1].split("</body>")[0]

        recommendations_html = ""
        if report.recommendations:
            recommendations_html = "<h2>Recommendations</h2><ol>"
            for rec in report.recommendations:
                recommendations_html += f"<li>{html.escape(rec)}</li>"
            recommendations_html += "</ol>"

        return f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{html.escape(report.title)}</title>
    <style>{css}</style>
</head>
<body>
    <div class="header">
        <h1>{html.escape(report.title)}</h1>
        <p>Security Assessment Report | {report.date}</p>
        <p>Classification: {report.classification}</p>
    </div>

    <h2>Executive Summary</h2>
    <div class="summary-box">
        <pre style="white-space: pre-wrap;">{html.escape(exec_summary)}</pre>
    </div>

    <h2>Scope</h2>
    <p>{html.escape(report.scope or 'Binary security assessment')}</p>
    <ul>{binaries_html}</ul>

    <h2>Methodology</h2>
    <p>{html.escape(report.methodology or 'Automated static and dynamic analysis using supwngo framework.')}</p>

    <h2>Findings</h2>
    {vuln_sections}

    {recommendations_html}

    <h2>Conclusion</h2>
    <p>{html.escape(report.conclusion or 'See executive summary for overall assessment.')}</p>

    <div class="footer">
        <p>Analyst: {html.escape(report.analyst or 'N/A')} | Organization: {html.escape(report.organization or 'N/A')}</p>
        <p>{self.config.footer_text}</p>
    </div>
</body>
</html>"""

    def _generate_markdown(
        self,
        report: Union[VulnerabilityReport, ExploitReport, AssessmentReport]
    ) -> str:
        """Generate Markdown report."""
        if isinstance(report, VulnerabilityReport):
            return self._vuln_report_md(report)
        elif isinstance(report, ExploitReport):
            return self._exploit_report_md(report)
        elif isinstance(report, AssessmentReport):
            return self._assessment_report_md(report)
        else:
            raise ValueError(f"Unknown report type: {type(report)}")

    def _vuln_report_md(self, report: VulnerabilityReport) -> str:
        """Generate vulnerability report Markdown."""
        counts = report.get_severity_counts()
        md = f"""# {report.title}

**Binary:** {report.binary.name}
**Date:** {report.date}

## Summary

- **Total Findings:** {len(report.findings)}
- **Overall Risk:** {report.get_overall_risk()}

| Critical | High | Medium | Low | Info |
|----------|------|--------|-----|------|
| {counts['critical']} | {counts['high']} | {counts['medium']} | {counts['low']} | {counts['info']} |

## Binary Information

| Property | Value |
|----------|-------|
| Name | {report.binary.name} |
| Architecture | {report.binary.architecture} |
| Bits | {report.binary.bits} |

## Findings

"""
        for i, finding in enumerate(report.findings, 1):
            md += f"""### {i}. {finding.vuln_type}

**Severity:** {finding.severity.upper()}

{finding.description}

"""
            if finding.location:
                md += f"**Location:** {finding.location}\n\n"
            if finding.address and not self.config.redact_addresses:
                md += f"**Address:** 0x{finding.address:x}\n\n"
            if finding.cvss_score > 0 and self.config.include_cvss:
                md += f"**CVSS:** {finding.cvss_score} ({finding.cvss_vector})\n\n"
            if finding.recommendations and self.config.include_recommendations:
                md += "**Recommendations:**\n"
                for rec in finding.recommendations:
                    md += f"- {rec}\n"
                md += "\n"
            if finding.proof_of_concept and self.config.include_poc:
                md += f"**Proof of Concept:**\n```\n{finding.proof_of_concept}\n```\n\n"
            md += "---\n\n"

        md += f"\n*{self.config.footer_text}*\n"
        return md

    def _exploit_report_md(self, report: ExploitReport) -> str:
        """Generate exploit report Markdown."""
        techniques = ", ".join(report.techniques) if report.techniques else "N/A"

        md = f"""# {report.title}

**Date:** {report.date}

## Target

| Property | Value |
|----------|-------|
| Binary | {report.binary.name} |
| Vulnerability | {report.vulnerability.vuln_type} |
| Exploit Type | {report.exploit_type} |
| Techniques | {techniques} |
| Success Rate | {report.success_rate:.1%} |

## Exploitation Steps

"""
        for step in report.steps:
            md += f"### Step {step.step_number}: {step.description}\n\n"
            if step.code:
                md += f"```python\n{step.code}\n```\n\n"
            if step.notes:
                md += f"*{step.notes}*\n\n"

        if self.config.include_payloads and report.payload_hex:
            md += f"## Payload\n\n`{report.payload_hex}`\n\n"

        if self.config.include_poc and report.script:
            md += f"## Exploit Script\n\n```python\n{report.script}\n```\n\n"

        md += f"\n*{self.config.footer_text}*\n"
        return md

    def _assessment_report_md(self, report: AssessmentReport) -> str:
        """Generate assessment report Markdown."""
        exec_summary = report.executive_summary or report.generate_executive_summary()

        md = f"""# {report.title}

**Date:** {report.date}
**Classification:** {report.classification}

## Executive Summary

{exec_summary}

## Scope

{report.scope or 'Binary security assessment'}

**Binaries Analyzed:**
"""
        for binary in report.binaries:
            md += f"- {binary.name} ({binary.architecture}, {binary.bits}-bit)\n"

        md += f"""
## Methodology

{report.methodology or 'Automated static and dynamic analysis using supwngo framework.'}

## Findings

"""
        for vuln_report in report.vulnerability_reports:
            md += f"### {vuln_report.binary.name}\n\n"
            md += self._vuln_report_md(vuln_report)
            md += "\n"

        if report.recommendations:
            md += "## Recommendations\n\n"
            for i, rec in enumerate(report.recommendations, 1):
                md += f"{i}. {rec}\n"
            md += "\n"

        md += f"""## Conclusion

{report.conclusion or 'See executive summary for overall assessment.'}

---
**Analyst:** {report.analyst or 'N/A'}
**Organization:** {report.organization or 'N/A'}

*{self.config.footer_text}*
"""
        return md

    def _generate_json(
        self,
        report: Union[VulnerabilityReport, ExploitReport, AssessmentReport]
    ) -> str:
        """Generate JSON report."""
        def to_dict(obj):
            if hasattr(obj, '__dataclass_fields__'):
                return {k: to_dict(v) for k, v in obj.__dict__.items()}
            elif isinstance(obj, list):
                return [to_dict(item) for item in obj]
            elif isinstance(obj, dict):
                return {k: to_dict(v) for k, v in obj.items()}
            else:
                return obj

        return json.dumps(to_dict(report), indent=2)

    def _generate_sarif(
        self,
        report: Union[VulnerabilityReport, ExploitReport, AssessmentReport]
    ) -> str:
        """Generate SARIF report."""
        exporter = SARIFExporter()

        if isinstance(report, VulnerabilityReport):
            exporter.add_artifact(report.binary.path)
            for finding in report.findings:
                exporter.add_vulnerability(
                    vuln_type=finding.vuln_type,
                    message=finding.description,
                    file_path=report.binary.path,
                    address=finding.address,
                    severity="error" if finding.severity.lower() in ["critical", "high"] else "warning",
                )
        elif isinstance(report, AssessmentReport):
            for vuln_report in report.vulnerability_reports:
                exporter.add_artifact(vuln_report.binary.path)
                for finding in vuln_report.findings:
                    exporter.add_vulnerability(
                        vuln_type=finding.vuln_type,
                        message=finding.description,
                        file_path=vuln_report.binary.path,
                        address=finding.address,
                    )

        return exporter.export_json()

    def _generate_text(
        self,
        report: Union[VulnerabilityReport, ExploitReport, AssessmentReport]
    ) -> str:
        """Generate plain text report."""
        # Convert markdown to plain text (strip formatting)
        md = self._generate_markdown(report)
        # Simple conversion - remove markdown formatting
        text = md.replace("**", "").replace("*", "").replace("`", "")
        text = "\n".join(
            line.lstrip("#").strip() if line.startswith("#") else line
            for line in text.split("\n")
        )
        return text

    def _generate_pdf_placeholder(
        self,
        report: Union[VulnerabilityReport, ExploitReport, AssessmentReport]
    ) -> str:
        """Generate PDF placeholder (requires weasyprint or similar)."""
        logger.warning("PDF generation requires weasyprint. Falling back to HTML.")
        return self._generate_html(report)
