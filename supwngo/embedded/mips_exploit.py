"""
MIPS exploitation support.

Provides MIPS-specific binary analysis and exploitation for routers and IoT.
MIPS is common in embedded devices, especially network equipment.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)

try:
    from pwn import ELF, context
    PWNTOOLS_AVAILABLE = True
except ImportError:
    PWNTOOLS_AVAILABLE = False


@dataclass
class MIPSProtections:
    """MIPS binary protections."""
    nx: bool = False
    pie: bool = False
    stack_canary: bool = False
    relro: str = "No RELRO"


@dataclass
class MIPSGadget:
    """MIPS ROP gadget."""
    address: int
    instructions: str
    delay_slot: str = ""  # MIPS has delay slots
    sets_register: Optional[str] = None
    controls_ra: bool = False  # Controls return address


@dataclass
class MIPSBinary:
    """MIPS binary information."""
    path: Path
    bits: int = 32
    endianness: str = "big"  # MIPS is often big-endian
    entry_point: int = 0
    protections: MIPSProtections = field(default_factory=MIPSProtections)
    symbols: Dict[str, int] = field(default_factory=dict)
    plt: Dict[str, int] = field(default_factory=dict)
    got: Dict[str, int] = field(default_factory=dict)


class MIPSExploit:
    """
    MIPS exploitation techniques.

    MIPS has unique characteristics:
    - Delay slots after branches
    - $ra register for return address
    - $a0-$a3 for first 4 arguments
    - Cache coherency issues (may need sleep gadget)

    Example:
        mips = MIPSExploit("target_mips")

        # Find gadgets
        gadgets = mips.find_gadgets()

        # Build ROP chain
        chain = mips.build_rop_chain(
            target_func="system",
            arg="/bin/sh"
        )
    """

    # MIPS calling convention
    ARG_REGS = ['$a0', '$a1', '$a2', '$a3']
    RETURN_REG = '$ra'
    STACK_REG = '$sp'

    # Common MIPS gadget patterns
    GADGET_PATTERNS = {
        'jalr_t9': 'jalr $t9',  # Common indirect call
        'jr_ra': 'jr $ra',       # Return
        'addiu_sp': 'addiu $sp',  # Stack adjustment
    }

    def __init__(self, path: Union[str, Path]):
        """
        Initialize MIPS exploit.

        Args:
            path: Path to MIPS binary
        """
        self.path = Path(path)

        if not self.path.exists():
            raise FileNotFoundError(f"Binary not found: {path}")

        self._elf = None
        self.binary = MIPSBinary(path=self.path)

        self._load_binary()

    def _load_binary(self):
        """Load and parse MIPS binary."""
        if PWNTOOLS_AVAILABLE:
            try:
                self._elf = ELF(str(self.path))

                # Detect MIPS variant
                machine = self._elf.get_machine_arch()
                if 'mips' in machine.lower():
                    if 'el' in machine.lower():
                        context.arch = 'mipsel'
                        self.binary.endianness = "little"
                    else:
                        context.arch = 'mips'
                        self.binary.endianness = "big"

                context.bits = 32

                self.binary.entry_point = self._elf.entry
                self.binary.symbols = dict(self._elf.symbols)
                self.binary.plt = dict(self._elf.plt)
                self.binary.got = dict(self._elf.got)

                # Parse protections
                self.binary.protections.nx = self._elf.nx
                self.binary.protections.pie = self._elf.pie
                self.binary.protections.stack_canary = self._elf.canary
                self.binary.protections.relro = self._elf.relro or "No RELRO"

            except Exception as e:
                logger.warning(f"Error loading with pwntools: {e}")
                self._load_manual()
        else:
            self._load_manual()

    def _load_manual(self):
        """Manually parse MIPS ELF."""
        try:
            with open(self.path, 'rb') as f:
                magic = f.read(20)

            if magic[:4] != b'\x7fELF':
                raise ValueError("Not an ELF file")

            # Check if MIPS
            ei_data = magic[5]
            self.binary.endianness = "little" if ei_data == 1 else "big"

            e_machine = int.from_bytes(magic[18:20],
                                      'little' if ei_data == 1 else 'big')
            if e_machine != 8:  # EM_MIPS
                raise ValueError("Not a MIPS binary")

        except Exception as e:
            logger.error(f"Error parsing binary: {e}")

    def find_gadgets(self, pattern: Optional[str] = None) -> List[MIPSGadget]:
        """
        Find MIPS ROP gadgets.

        MIPS gadgets typically end with:
        - jr $ra (return)
        - jalr $t9 (indirect call)

        Args:
            pattern: Optional filter pattern

        Returns:
            List of gadgets
        """
        gadgets = []

        try:
            from capstone import Cs, CS_ARCH_MIPS, CS_MODE_MIPS32, CS_MODE_BIG_ENDIAN, CS_MODE_LITTLE_ENDIAN

            mode = CS_MODE_MIPS32
            if self.binary.endianness == "big":
                mode |= CS_MODE_BIG_ENDIAN
            else:
                mode |= CS_MODE_LITTLE_ENDIAN

            md = Cs(CS_ARCH_MIPS, mode)

            if not self._elf:
                return gadgets

            # Search executable sections
            for section in self._elf.sections:
                if not (section.header.sh_flags & 0x4):  # SHF_EXECINSTR
                    continue

                data = self._elf.read(section.header.sh_addr, section.header.sh_size)

                # Find jr $ra instructions (return gadgets)
                # jr $ra = 0x03e00008 (big) or 0x0800e003 (little)
                for i in range(0, len(data) - 4, 4):
                    chunk = data[max(0, i - 32):i + 8]  # Include delay slot
                    addr = section.header.sh_addr + i - (32 if i >= 32 else i)

                    try:
                        insns = list(md.disasm(chunk, addr))
                        if not insns:
                            continue

                        # Look for jr $ra or jalr patterns
                        for j, insn in enumerate(insns):
                            is_gadget_end = False
                            delay_slot = ""

                            if insn.mnemonic == 'jr' and '$ra' in insn.op_str:
                                is_gadget_end = True
                            elif insn.mnemonic == 'jalr':
                                is_gadget_end = True

                            if is_gadget_end:
                                # Include delay slot (instruction after branch)
                                if j + 1 < len(insns):
                                    delay_slot = f"{insns[j+1].mnemonic} {insns[j+1].op_str}"

                                # Get instructions before
                                gadget_insns = insns[max(0, j-4):j+2]
                                disasm = "; ".join(
                                    f"{ins.mnemonic} {ins.op_str}".strip()
                                    for ins in gadget_insns
                                )

                                if pattern and pattern.lower() not in disasm.lower():
                                    continue

                                gadget = MIPSGadget(
                                    address=gadget_insns[0].address if gadget_insns else addr,
                                    instructions=disasm,
                                    delay_slot=delay_slot,
                                    controls_ra=('$ra' in disasm)
                                )

                                gadgets.append(gadget)
                                break

                    except Exception:
                        continue

        except ImportError:
            logger.warning("Capstone not available")
        except Exception as e:
            logger.debug(f"Error finding gadgets: {e}")

        # Remove duplicates
        seen = set()
        unique = []
        for g in gadgets:
            if g.address not in seen:
                seen.add(g.address)
                unique.append(g)

        logger.info(f"Found {len(unique)} MIPS gadgets")
        return unique

    def find_stack_finder(self) -> Optional[MIPSGadget]:
        """
        Find a 'stack finder' gadget.

        In MIPS exploitation, we often need to find where our controlled
        data is on the stack. Common pattern: addiu $reg, $sp, offset
        """
        for gadget in self.find_gadgets("addiu"):
            if "$sp" in gadget.instructions:
                return gadget
        return None

    def find_sleep_gadget(self) -> Optional[int]:
        """
        Find sleep function for cache flush.

        MIPS has instruction cache that needs flushing before
        executing shellcode. Calling sleep() helps with this.
        """
        if 'sleep' in self.binary.plt:
            return self.binary.plt['sleep']
        if 'usleep' in self.binary.plt:
            return self.binary.plt['usleep']
        return None

    def build_rop_chain(
        self,
        target_func: str,
        args: List[int] = None
    ) -> Optional[bytes]:
        """
        Build MIPS ROP chain.

        MIPS calling convention:
        - $a0-$a3: First 4 arguments
        - Stack: Additional arguments (16 bytes from $sp)
        - $ra: Return address
        - $t9: Often used for function address

        Args:
            target_func: Function to call
            args: Arguments

        Returns:
            ROP chain bytes
        """
        args = args or []
        endian = 'big' if self.binary.endianness == 'big' else 'little'
        chain = bytearray()

        # Get function address
        if isinstance(target_func, str):
            if target_func in self.binary.plt:
                func_addr = self.binary.plt[target_func]
            elif target_func in self.binary.symbols:
                func_addr = self.binary.symbols[target_func]
            else:
                logger.warning(f"Function {target_func} not found")
                return None
        else:
            func_addr = target_func

        # Find gadgets to set $a0-$a3
        # This is simplified - real MIPS ROP is more complex
        gadgets = self.find_gadgets()

        # Look for lw $a0, offset($sp) type gadgets
        a0_gadgets = [g for g in gadgets if '$a0' in g.instructions and 'lw' in g.instructions]
        a1_gadgets = [g for g in gadgets if '$a1' in g.instructions and 'lw' in g.instructions]

        # Build chain - this is a simplified example
        # Real MIPS exploitation requires careful gadget chaining

        if a0_gadgets and args:
            # Gadget that loads $a0 from stack
            gadget = a0_gadgets[0]
            chain.extend(gadget.address.to_bytes(4, endian))
            # Stack slot for $a0
            chain.extend(args[0].to_bytes(4, endian))

        # Jump to function
        # Often need: lui $t9, high; ori $t9, low; jalr $t9
        chain.extend(func_addr.to_bytes(4, endian))

        return bytes(chain)

    def build_shellcode_chain(
        self,
        shellcode_addr: int,
        include_sleep: bool = True
    ) -> Optional[bytes]:
        """
        Build chain to execute shellcode.

        For MIPS, we often need to:
        1. Call sleep() to flush instruction cache
        2. Jump to shellcode

        Args:
            shellcode_addr: Address of shellcode
            include_sleep: Include cache-flush sleep

        Returns:
            ROP chain bytes
        """
        endian = 'big' if self.binary.endianness == 'big' else 'little'
        chain = bytearray()

        if include_sleep:
            sleep_addr = self.find_sleep_gadget()
            if sleep_addr:
                # Call sleep(1) to flush cache
                # $a0 = 1
                chain.extend(sleep_addr.to_bytes(4, endian))
                chain.extend((1).to_bytes(4, endian))  # sleep time

        # Jump to shellcode
        chain.extend(shellcode_addr.to_bytes(4, endian))

        return bytes(chain)

    def get_bad_chars(self) -> bytes:
        """
        Get common bad characters for MIPS exploitation.

        MIPS often has null byte issues due to instruction encoding.
        """
        # Common bad chars
        bad = b'\x00'  # Null byte

        # Check if binary uses big or little endian
        # Big-endian MIPS has different bad char patterns
        if self.binary.endianness == 'big':
            bad += b'\x0a\x0d'  # Newline, carriage return

        return bad

    def generate_exploit_template(self) -> str:
        """Generate MIPS exploit template."""
        arch = "mips" if self.binary.endianness == "big" else "mipsel"

        template = f'''#!/usr/bin/env python3
"""
MIPS Exploit Template
Generated by supwngo

Target: {self.path.name}
Architecture: MIPS32 ({self.binary.endianness} endian)
"""

from pwn import *

# Binary setup
binary = ELF("{self.path}")
context.binary = binary
context.arch = "{arch}"

# Useful addresses
'''
        for name, addr in list(self.binary.plt.items())[:10]:
            template += f'{name.upper()}_PLT = {hex(addr)}\n'

        sleep_addr = self.find_sleep_gadget()
        if sleep_addr:
            template += f'SLEEP_PLT = {hex(sleep_addr)}  # For cache flush\n'

        template += '''
# Gadgets
'''
        for gadget in self.find_gadgets()[:10]:
            template += f'# {hex(gadget.address)}: {gadget.instructions}\n'

        template += f'''

# MIPS shellcode (adjust for endianness)
# This is a placeholder - use msfvenom or custom shellcode
SHELLCODE = b"\\x00" * 100

def build_rop():
    """Build MIPS ROP chain."""
    chain = b""

    # MIPS ROP considerations:
    # 1. Delay slots - instruction after branch executes
    # 2. Cache coherency - may need sleep() before shellcode
    # 3. Arguments in $a0-$a3, then stack

    # Example: Call sleep(1) to flush cache
'''
        if sleep_addr:
            template += f'''    # chain += p32({hex(sleep_addr)})  # sleep
    # Set $a0 = 1 for sleep(1)
'''
        template += '''
    # Then jump to shellcode
    # chain += p32(shellcode_addr)

    return chain

def exploit():
    # p = process(binary.path)
    # p = remote("target", 1337)

    payload = b""
    payload += b"A" * 100  # Padding to return address

    # MIPS stack layout note:
    # Return address often at specific offset based on function

    payload += build_rop()
    payload += SHELLCODE

    # p.send(payload)
    # p.interactive()

if __name__ == "__main__":
    exploit()
'''
        return template

    def summary(self) -> str:
        """Get MIPS exploitation summary."""
        lines = [
            "MIPS Exploitation Analysis",
            "=" * 40,
            f"Binary: {self.path.name}",
            f"Endianness: {self.binary.endianness}",
            f"Entry: {hex(self.binary.entry_point)}",
            "",
            "Protections:",
            f"  NX: {self.binary.protections.nx}",
            f"  PIE: {self.binary.protections.pie}",
            f"  Canary: {self.binary.protections.stack_canary}",
            f"  RELRO: {self.binary.protections.relro}",
            "",
            f"PLT entries: {len(self.binary.plt)}",
            f"Symbols: {len(self.binary.symbols)}",
        ]

        sleep = self.find_sleep_gadget()
        if sleep:
            lines.append(f"Sleep gadget (cache flush): {hex(sleep)}")

        gadgets = self.find_gadgets()
        lines.append(f"ROP gadgets: {len(gadgets)}")

        return "\n".join(lines)


def build_mips_rop(binary_path: str, target: str, args: List[int] = None) -> Optional[bytes]:
    """
    Convenience function to build MIPS ROP chain.

    Args:
        binary_path: Path to MIPS binary
        target: Target function
        args: Arguments

    Returns:
        ROP chain bytes
    """
    mips = MIPSExploit(binary_path)
    return mips.build_rop_chain(target, args or [])
