# Modern Binary Exploitation Techniques (2023-2025)
## Comprehensive Research Summary

This document catalogs cutting-edge binary exploitation techniques discovered and refined between 2023-2025, with emphasis on implementation requirements, complexity, and practical applications.

---

## Table of Contents
1. [Modern glibc Heap Exploitation (2.32+)](#1-modern-glibc-heap-exploitation-232)
2. [Linux Kernel Exploitation](#2-linux-kernel-exploitation)
3. [Modern Mitigation Bypasses](#3-modern-mitigation-bypasses)
4. [Browser/V8/JIT Exploitation](#4-browserv8jit-exploitation)
5. [AI/ML-Assisted Vulnerability Discovery](#5-aiml-assisted-vulnerability-discovery)
6. [Container Escape Techniques](#6-container-escape-techniques)
7. [Hardware-Assisted Fuzzing](#7-hardware-assisted-fuzzing)
8. [Windows Modern Heap Exploitation](#8-windows-modern-heap-exploitation)
9. [Novel CTF and Research Techniques](#9-novel-ctf-and-research-techniques)
10. [eBPF Exploitation](#10-ebpf-exploitation)
11. [Side-Channel Attacks](#11-side-channel-attacks)

---

## 1. Modern glibc Heap Exploitation (2.32+)

### 1.1 Safe-Linking Bypass Techniques

**Background**: Safe-Linking was introduced in glibc 2.32 to protect tcache and fastbin fd pointers by XOR'ing them with randomized ASLR bits.

**Implementation**: `PROTECT_PTR` macro XORs pointers: `fd ^ ((heap_base + chunk_offset) >> 12)`

#### Technique A: Heap Address Leak Method
- **Complexity**: Low
- **Requirements**:
  - Ability to print freed chunk after tcache insertion
  - Single read primitive
- **Implementation**:
  ```python
  # Read freed tcache chunk to get XOR'd pointer
  leaked_value = read_chunk(freed_chunk_addr)
  heap_base = leaked_value ^ (freed_chunk_addr >> 12)

  # Encrypt target address for write
  target_encrypted = target_addr ^ ((heap_base + chunk_offset) >> 12)
  ```

#### Technique B: House of Rust (Leakless)
- **Complexity**: High
- **Requirements**:
  - Use-After-Free (UAF) primitive
  - Heap feng shui capabilities
  - No information leaks required
- **Attack Chain**:
  1. Tcache Stashing Unlink+ attack
  2. Standard Tcache Stashing Unlink
  3. Two largebin attacks
  4. FSOP attack on stdout FILE stream
- **Applicable Versions**: glibc 2.32+
- **CTF Usage**: DiceCTF @ HOPE 2022 (catastrophe challenge)

#### Technique C: Buffer Overflow Bypass
- **Complexity**: Medium
- **Requirements**:
  - Single heap buffer overflow
  - Control over allocation/deallocation
  - Ability to read/write object fields
- **Method**: Create overlapping chunks to retain two pointers to same chunk for UAF/double-free

### 1.2 Modern "House of" Techniques

#### House of Botcake (glibc 2.35+)
- **Complexity**: Medium
- **Target**: Tcache poisoning for write-what-where
- **Algorithm**:
  1. Allocate 7 x 0x100 sized chunks
  2. Allocate two additional chunks (prev, a)
  3. Allocate barrier chunk
  4. Fill tcache with 7 chunks
  5. Free chunk 'a' into unsortedbin
  6. Free 'prev' to consolidate with 'a'
  7. Request one chunk from tcache
  8. Free 'a' again → UAF since 'a' is part of large chunk

#### House of Water
- **Complexity**: High
- **Target**: glibc latest versions
- **Requirements**: UAF or double-free
- **Capability**: Leakless control of tcache metadata, enables libc linking in tcache

#### House of Tangerine
- **Complexity**: Medium
- **Target**: glibc >= 2.26
- **Method**: Exploit Top Chunk via tcache freelist abuse
- **Output**: Arbitrary pointer from malloc()
- **CTF Usage**: PicoCTF 2024

#### House of Muney
- **Complexity**: High
- **Target**: mmap chunks in glibc
- **Capability**: Leakless exploitation, full ASLR bypass
- **Method**:
  1. Munmap part of LibC
  2. Rewrite symbol table
  3. Achieve code execution

### 1.3 Implementation Complexity Matrix

| Technique | Complexity | Leak Required | glibc Version | Success Rate |
|-----------|-----------|---------------|---------------|--------------|
| Heap Leak Bypass | Low | Yes | 2.32+ | High |
| House of Rust | High | No | 2.32+ | Medium |
| House of Botcake | Medium | No | 2.35+ | High |
| House of Water | High | No | 2.36+ | Medium |
| House of Tangerine | Medium | Yes | 2.26+ | High |
| House of Muney | High | No | All | Medium |

---

## 2. Linux Kernel Exploitation

### 2.1 msg_msg Exploitation

**Overview**: msg_msg objects are kernel message queue structures that have become a premier exploitation primitive.

#### New msg_msg Technique (2025)
- **Innovation**: Corruption without kernel hang
- **Requirements**:
  - Kernel UAF or OOB write
  - Heap spray capabilities
- **Advantages**:
  - Simpler than traditional approaches
  - Reliable arbitrary R/W primitive
  - Works across kernel versions

#### CVE-2024-50264 (Pwnie Award 2025)
- **Award**: Best Privilege Escalation, Pwnie Awards 2025
- **Technique Combination**:
  1. pipe AARW (Arbitrary Address Read/Write) against `struct cred`
  2. msg_msg OOB read for virtual address leak
  3. 96-byte msg_msg paired with virtio_vsock_sock (same slab size)
  4. UAF write at fixed offset in victim msg_msg

### 2.2 io_uring Exploitation

**Background**: io_uring provides async I/O interface, heavily targeted due to complexity.

#### Key Characteristics
- **Disabled in**: ChromeOS, Google production servers, restricted in Android
- **Attack Surface**: Large due to numerous operations and ring buffer complexity
- **Buffer Registration**: IORING_REGISTER_PBUF_RING (kernel 5.7+)

#### CVE-2024-0582
- **Type**: Use-After-Free in io_uring
- **Exploitation Strategy**:
  - Spray heap with controlled objects
  - Trigger UAF in io_uring operation
  - Overlap with controllable kernel structure
  - Achieve arbitrary R/W

### 2.3 pipe_buffer Exploitation

**Technique**: Linux Kernel Pipe Object for Data-Only Attacks
- **Year**: Pumpkin Chang, 2024
- **Advantages**:
  - No RIP control required
  - Data-only attack primitive
  - Bypasses CFI protections
- **Use Case**: Elevation of privilege via credential structure manipulation

### 2.4 CVE-2025-38236 - Chrome Sandbox to Kernel
- **Severity**: CVSS score varies, critical impact
- **Discoverer**: Jann Horn (Google Project Zero)
- **Vector**: MSG_OOB feature in UNIX domain sockets
- **Affected**: Linux kernels 6.9+
- **Mechanism**:
  1. UAF in oob_skb data structure
  2. Crafted send() and recv() sequences
  3. Memory reuse without cleanup
  4. Chrome renderer sandbox → kernel escalation

### 2.5 modprobe_path Technique
- **Target**: `/proc/sys/kernel/modprobe` path overwrite
- **Requirements**:
  - Arbitrary kernel write
  - Ability to trigger modprobe execution
- **Payload**: Overwrite modprobe path with attacker script
- **Result**: Root command execution when kernel tries to load module

### 2.6 Implementation Requirements

| Technique | Complexity | Prerequisites | Stability | Detection Difficulty |
|-----------|-----------|---------------|-----------|---------------------|
| msg_msg (new) | Medium | UAF/OOB write | High | Medium |
| CVE-2024-50264 | High | Multi-primitive | High | Low |
| io_uring exploits | High | Specific CVE | Medium | Medium |
| pipe_buffer | Medium | Arbitrary write | High | High |
| MSG_OOB (CVE-2025-38236) | High | Chrome sandbox | Medium | Low |
| modprobe_path | Low | Arbitrary write | High | Low |

---

## 3. Modern Mitigation Bypasses

### 3.1 Intel CET (Control-flow Enforcement Technology)

#### Components
1. **Shadow Stack**: Hardware-enforced return address integrity
2. **IBT (Indirect Branch Tracking)**: Validates indirect jump/call targets

#### Bypass Techniques

##### A. COOP (Counterfeit Object-Oriented Programming)
- **Publication**: Offensive Security, 2022-2024
- **Method**:
  - Chain CFG-allowed functions
  - Avoid return address corruption
  - Use vfgadgets (inherently CFG-approved)
- **Effectiveness**: Bypasses both Shadow Stack and IBT
- **Requirements**:
  - Multiple C++ objects with virtual functions
  - Memory corruption primitive
  - No need to corrupt return addresses

##### B. Windows Implementation Gaps (2024-2025)
- **Current Status**:
  - Shadow Stack: Enabled in kernel mode (Windows 11 22H2+)
  - IBT: NOT implemented (CFG used instead)
  - Browser limitation: CET not enforced on renderer processes
- **Exploitation Window**: Renderer processes remain vulnerable

##### C. IBT Weakness
- **Classification**: Weakest form of CFI
- **Issue**: Single class of valid targets (any ENDBR64 instruction)
- **Bypass**: Same as Microsoft CFG bypass - redirect to any valid landing pad
- **CTF Evidence**: IBT provided no additional protection in practice

### 3.2 ARM MTE (Memory Tagging Extension)

#### CVE-2025-0072 - Mali GPU MTE Bypass (May 2025)
- **Target**: ARM Mali GPU driver
- **Impact**: MTE bypass + arbitrary kernel code execution
- **Affected Devices**: Google Pixel 7, 8, 9 series
- **Architecture**: Command Stream Frontend (CSF)
- **Mechanism**:
  - Access freed memory via user-space mappings
  - `mgm_vmf_insert_pfn_prot` inserts page frames directly
  - Bypasses kernel-level dereferencing
  - Evades MTE tag-checking even after buddy allocator return
- **Patched**: Mali driver r54p0 (May 2025)

#### TikTag Attack - Speculative Execution MTE Bypass (Black Hat 2024)
- **Method**: Leak MTE tags through speculative execution
- **Technique**: TikTag gadgets leak tag check results via cache side-channel
- **Variants**:
  - TikTag-v1: Execution gap between tag check and memory access
  - Cache hit rate dropped to ~80% providing side-channel
- **Targets**: Google Chrome, Linux kernel MTE implementations
- **Mitigation**: Speculative execution-aware sandboxing

### 3.3 ARM PAC (Pointer Authentication Code)

#### PACMAN Attack
- **Method**: Forge correct pointer signatures via microarchitectural side channels
- **Target**: Apple M1 CPU (demonstrated)
- **Capability**: Control-flow hijacking on PAC-protected platforms
- **Mechanism**: Speculative execution to guess correct PAC
- **Impact**: Removes primary barrier to CFI attacks
- **Proof of Concept**: Cross-privilege level attacks demonstrated

### 3.4 ARM BTI (Branch Target Identification)

#### Functionality
- Restricts branches to intended locations
- Adds branch target concept to ARM ISA
- Invalid branch target → exception

#### Combined PAC/BTI Effectiveness
- **NSA Finding**: 50x reduction in usable ROP/JOP gadgets
- **Limitation**: Not complete protection, reduced attack surface
- **Bypass**: Via PAC forgery (PACMAN) + gadget hunting

### 3.5 Bypass Complexity Matrix

| Mitigation | Bypass Technique | Complexity | Requirements | Success Rate |
|------------|------------------|-----------|--------------|--------------|
| Intel CET (Shadow Stack) | COOP | High | C++ vtables, CFG | High |
| Intel IBT | Direct redirect | Low | Any ENDBR64 | High |
| ARM MTE | CVE-2025-0072 | Medium | Mali GPU access | High |
| ARM MTE | TikTag | High | Speculation gadgets | Medium |
| ARM PAC | PACMAN | Very High | Microarch access | Medium |
| ARM BTI | Combined with PAC | High | Multiple primitives | Low |

---

## 4. Browser/V8/JIT Exploitation

### 4.1 2025 Chrome Zero-Day Landscape

**Statistics**:
- 8 zero-days patched in 2025
- 4 (50%) in V8 engine
- 3 type confusion vulnerabilities
- 2 sandbox escape vulnerabilities

#### Critical CVEs

##### CVE-2025-6554 (Type Confusion in V8)
- **Type**: Type confusion in V8 JavaScript engine
- **Exploitation Attempts**: 172,000+ globally (June 27 - July 2, 2025)
- **Target**: Credentials, tokens, session data
- **Exploitation Chain**:
  1. Type confusion in object handling
  2. Out-of-bounds read/write
  3. Arbitrary code execution in renderer

##### CVE-2025-2783 (Mojo Sandbox Escape)
- **Component**: Mojo IPC mechanism
- **Campaign**: Operation ForumTroll
- **Targets**: Russian government, media outlets
- **Capability**: Break Chrome isolation → OS access

##### CVE-2024-5830 (Type Confusion)
- **Vector**: Malicious website visit
- **Mechanism**:
  - Flaw in map transition process
  - Incorrect object property handling
  - Out-of-bounds access
- **Result**: Arbitrary code execution

### 4.2 Modern V8 Exploitation Techniques

#### Standard Exploitation Flow
1. **Initial Primitive**: Create OOB array using bug (type confusion, incorrect bounds check)
2. **V8 Sandbox Bypass**: Corrupt API objects (V8-Blink interface)
3. **Renderer Memory Access**: Arbitrary R/W outside V8 sandbox
4. **Code Execution**: Corrupt function pointers or JIT code

#### JIT Spraying Technique
- **Method**: Store shellcode as floating-point numbers in JIT code
- **Mechanism**:
  1. Modify pointer to JIT optimized code in Function object
  2. Use arbitrary R/W to redirect pointer
  3. Jump to middle of JIT code containing shellcode data
  4. Execute arbitrary code

#### V8 Heap Sandbox Bypass
- **Target**: API objects (V8 wrappers for DOM objects)
- **Method**:
  - Corrupt API object to cause type confusion in Blink
  - Gain arbitrary R/W to entire Chrome renderer process
  - Bypass V8 sandbox isolation
- **Next Steps**: Locate and corrupt function pointers or JIT code

### 4.3 Additional 2024 Pwn2Own Vulnerabilities

#### CVE-2024-2887 (WebAssembly Type Confusion)
- **Component**: WebAssembly implementation
- **Exploited By**: Manfred Paul (Pwn2Own winner)
- **Prize**: $202,500
- **Targets**: Chrome and Edge (double-tap RCE)

#### CVE-2024-2886 (WebCodecs UAF)
- **Component**: WebCodecs API
- **Exploited By**: KAIST Hacking Lab (Seunghyun Lee)
- **Capability**: Arbitrary read/write via crafted HTML
- **Targets**: Chrome and Edge

#### CVE-2024-3159 (V8 OOB Access)
- **Type**: Out-of-bounds memory access
- **Event**: Pwn2Own 2024
- **Result**: Memory corruption → code execution

### 4.4 V8 Compiler Pipeline (Exploitation Targets)

**Modern Pipeline**:
1. **Ignition** (Interpreter)
2. **Sparkplug** (Fast baseline compiler)
3. **Maglev** (Mid-tier optimizing compiler) - NEW
4. **TurboFan** (Top-tier optimizing compiler)

**Exploitation Opportunities**: Type confusion in optimization passes, incorrect deoptimization, speculative optimization bugs

### 4.5 Browser Exploitation Complexity

| CVE | Type | Component | Complexity | Sandbox Escape | Prize/Impact |
|-----|------|-----------|-----------|----------------|--------------|
| CVE-2025-6554 | Type Confusion | V8 | Medium | No | 172k attacks |
| CVE-2025-2783 | Sandbox Escape | Mojo | High | Yes | APT usage |
| CVE-2024-5830 | Type Confusion | V8 Maps | Medium | No | High impact |
| CVE-2024-2887 | Type Confusion | Wasm | High | No | $202,500 |
| CVE-2024-2886 | UAF | WebCodecs | Medium | No | RCE |

---

## 5. AI/ML-Assisted Vulnerability Discovery

### 5.1 Google OSS-Fuzz with LLM (2024)

#### Major Achievements
- **Vulnerabilities Found**: 26 new (including critical OpenSSL flaw)
- **CVE-2024-9143**: OpenSSL OOB write (CVSS 4.3)
  - Present for ~20 years
  - Undiscovered by traditional testing
  - Found via AI-generated diverse test cases
- **Code Coverage Improvement**: One project: 77 lines → 5,400 lines (7,000% increase)
- **Total New Coverage**: 370,000+ lines across 272 C/C++ projects

#### Methodology
1. LLM generates improved test harnesses
2. Targets previously untested code paths
3. Dramatically increases fuzzer effectiveness
4. Identifies edge cases missed by humans

### 5.2 AI Agents for Vulnerability Discovery

#### Big Sleep (Google)
- **Type**: Autonomous AI agent
- **Achievement**: Zero-day discovery in SQLite
- **Capability**: Autonomous vulnerability hunting without human guidance
- **Method**: Combines static analysis, fuzzing, and symbolic reasoning

#### Spark (Code Intelligence)
- **Type**: AI-powered fuzzing agent
- **Target**: Open-source projects
- **Capability**: Autonomous discovery of security flaws

### 5.3 AI-Guided Fuzzing Improvements

#### Traditional vs AI-Guided
**Traditional Fuzzing**:
- Blind mutation of inputs
- Random exploration
- Predefined heuristics

**AI-Guided Fuzzing**:
- Learn which input patterns explore deeper paths
- Prioritize regions historically harboring vulnerabilities
- Adapt test case generation intelligently
- Reason about code behavior

#### CodeRover-S Efficacy
- **2024 Vulnerabilities**: 63% fix rate
- **Other Years**: 46-63% range
- **Capability**: Automated vulnerability repair from fuzzing results

### 5.4 Recent Research (2024-2025)

#### Key Papers
1. **"Large Language Model assisted Hybrid Fuzzing"** (December 2024)
   - Combines symbolic execution with LLM-guided input generation

2. **"Harnessing Large Language Models for Seed Generation in Greybox Fuzzing"** (November 2024)
   - LLMs generate high-quality initial seeds

3. **"ChatHTTPFuzz: Large Language Model-Assisted IoT HTTP Fuzzing"** (November 2024)
   - Specialized for IoT protocol fuzzing

4. **"FuzzCoder: Byte-level Fuzzing Test via Large Language Model"** (September 2024)
   - Fine-grained byte-level input generation

### 5.5 AI for Vulnerability Repair

**OSS-Fuzz Integration**:
- Launched by Google in 2016
- Covers 1250+ open-source projects
- Now includes AI-assisted patch generation
- Reduces manual triage time significantly

### 5.6 AI/ML Implementation Matrix

| Tool/Technique | Complexity | Setup Difficulty | Effectiveness | Use Case |
|----------------|-----------|------------------|---------------|----------|
| OSS-Fuzz + LLM | Medium | Medium | Very High | Harness generation |
| Big Sleep | Low (hosted) | Low | High | Autonomous discovery |
| CodeRover-S | Medium | Medium | 46-63% | Automated repair |
| LLM Seed Generation | Low | Low | High | Fuzzing improvement |
| Hybrid Fuzzing + LLM | High | High | Very High | Deep path exploration |

---

## 6. Container Escape Techniques

### 6.1 Recent Critical Vulnerabilities (2024-2025)

#### runC Vulnerabilities (November 2025)
**Impact**: Container isolation bypass → root access on host

##### CVE-2025-31133 (maskedPaths Feature)
- **Target**: Sensitive host file access prevention
- **Mechanism**: Bypass maskedPaths protection
- **Exploitation**: Symbolic link manipulation

##### CVE-2025-52565 (dev/pts Mounting)
- **Target**: /dev/pts/$n → /dev/console mount validation
- **Mechanism**: Mount redirection before security activation
- **Result**: Unauthorized procfs write access

##### CVE-2025-52881 (Shared Mount Race)
- **Target**: Race condition with shared mounts
- **Mechanism**: Redirect runC writes to /proc files
- **Critical Files**: /proc/sysrq-trigger (system crash, escalation)
- **Result**: Container escape via privilege escalation

**Patched Versions**: runC 1.2.8, 1.3.3, 1.4.0-rc.3+

**Organizations Affected**: All using Docker, Kubernetes, or runC-based services

#### CVE-2025-23266 (NVIDIA Container Toolkit)
- **Severity**: CVSS 9.0
- **Affected**: 37% of cloud environments using NVIDIA Container Toolkit
- **Type**: "Confused Deputy" attack
- **Exploit Simplicity**: 3-line exploit
- **Mechanism**: LD_PRELOAD manipulation
- **Result**: Privileged process executes malicious code

#### Leaky Vessels (2024)
**Four Critical Vulnerabilities**:

##### CVE-2024-21626 (runC)
- **Type**: Container breakout via file descriptor leak
- **Exploitation**:
  - Malicious container image
  - Specific workdir options during startup
  - Malicious Dockerfiles
- **Impact**: Host file system access

##### CVE-2024-23651/23652/23653 (BuildKit)
- **Type**: Race conditions in Docker BuildKit
- **Result**: Host access during image build
- **Attack Vector**: Compromised build process

### 6.2 Common Container Escape Vectors

#### 1. Kernel Exploits
- **Target**: Shared kernel between container and host
- **Requirements**: Kernel vulnerability (CVE)
- **Success Rate**: High when CVE available
- **Example**: Dirty Pipe (CVE-2022-0847) for container escape

#### 2. Privilege Escalation
- **Vector**: Excessive container capabilities
- **Key Capabilities**:
  - CAP_SYS_ADMIN: Mount, namespace manipulation
  - CAP_SYS_PTRACE: Process debugging
  - CAP_SYS_MODULE: Kernel module loading
- **Method**: Leverage capability to escape isolation

#### 3. Docker Socket Exposure
- **Vector**: Mounted /var/run/docker.sock
- **Exploitation**:
  ```bash
  docker -H unix:///var/run/docker.sock run -v /:/host -it ubuntu chroot /host bash
  ```
- **Result**: Instant host root access

#### 4. Kubernetes Pod Log Symlink
- **Vector**: kubelet log file reading via symlink manipulation
- **Mechanism**:
  1. Each pod has log file in /var/log (symlinked to container directory)
  2. kubelet reads symlink without validation
  3. Manipulate symlink to point to /etc/shadow or other host files
- **Result**: Host file system read access

#### 5. Poisoned Images
- **Vector**: Compromised CI/CD pipeline or registry account
- **Method**: Backdoors built into container images
- **Distribution**: Public/private registries

### 6.3 Kubernetes-Specific Techniques

#### Privileged Container Abuse
- **Requirement**: Container runs with privileged: true
- **Capabilities**:
  - Full device access
  - Host filesystem mounting
  - Direct hardware access
- **Escape Routes**: Multiple (filesystem, devices, kernel)

#### Host Mount Exploitation
- **Vector**: Sensitive host paths mounted into container
- **Common Mistakes**:
  - /var/run/docker.sock
  - /proc, /sys (writable)
  - /etc (host configuration)
- **Result**: Direct host modification capability

### 6.4 Industry Impact (2024 Data)

**Red Hat Kubernetes Security Report 2024**:
- 66%+ organizations slowed container adoption due to security
- Almost 50% experienced revenue loss or customer defection from container incidents

### 6.5 Mitigation Strategies

#### Runtime Protections
- **SELinux**: Mandatory Access Control
- **AppArmor**: Application security profiles
- **seccomp**: Syscall filtering (blocks eBPF by default in Docker)

#### Configuration Best Practices
- **User Namespaces**: Enable across all containers (runC recommendation)
- **Rootless Containers**: Don't run as root inside container
- **Capability Dropping**: Minimal capabilities only
- **Read-only Root FS**: Prevent runtime modifications

#### Monitoring
- **Track**: Suspicious symlink behavior
- **Detect**: Unexpected host filesystem access
- **Monitor**: Dubious capability usage

### 6.6 Container Escape Complexity Matrix

| CVE/Technique | Complexity | Prerequisites | Detection | Impact |
|---------------|-----------|---------------|-----------|--------|
| CVE-2025-31133 | Medium | runC < 1.2.8 | Medium | Full escape |
| CVE-2025-52565 | Medium | runC < 1.2.8 | Low | Full escape |
| CVE-2025-52881 | Medium | runC < 1.2.8 | Medium | Full escape |
| CVE-2025-23266 | Low | NVIDIA toolkit | Low | Full escape |
| Docker socket mount | Very Low | Socket exposure | High | Full escape |
| Privileged container | Low | Privileged flag | High | Full escape |
| Kernel exploit | High | Vulnerable kernel | Low | Full escape |
| Pod log symlink | Medium | Kubelet access | Medium | File read |

---

## 7. Hardware-Assisted Fuzzing

### 7.1 Intel PT (Processor Trace) Integration

#### Google Summer of Code 2024 - LibAFL Intel PT
**Achievements**:
1. KVM accelerator support in LibAFL QEMU
2. Programmatic QEMU instance setup
3. Intel PT C code ported to Rust (PR 2471)
4. Safe, general-purpose interface (not PoC)
5. Trace decoding: compressed branches → basic block sequence

**Advantages**:
- Hardware-level execution tracing
- Minimal overhead vs software instrumentation
- Captures conditional branch outcomes
- Reconstructs complete execution flow

### 7.2 Nyx Fuzzing Framework

#### Architecture
- **QEMU-Nyx**: Modified QEMU for VM snapshots
- **KVM-Nyx**: Modified KVM hypervisor
- **Key Feature**: Intel PT in nested virtualization

#### Capabilities
- Fast VM snapshot creation/reset
- Hardware tracing with minimal overhead
- Coverage information via Intel PT
- Relatively small performance impact

#### Integration: Nyx + HyperHook + LibAFL
**Component Roles**:
- **LibAFL**: Input generation, mutation, scheduling
- **Nyx**: Snapshot management, instrumentation
- **HyperHook**: Target harnessing, guest-to-host communication

**Result**: High-performance, hardware-assisted fuzzing pipeline

### 7.3 Snapshot Fuzzing

#### Concept
1. Run target to specific point
2. Capture process state snapshot (registers, stack, memory)
3. Restore snapshot after each run
4. Inject fuzz input directly into memory
5. Execute only target code section

**Advantages**:
- Skip initialization/destruction code
- Save CPU cycles on repeated setup
- Focus fuzzing on vulnerability-prone code
- Significantly faster execution

#### Tartiflette Project
- **Description**: Snapshot fuzzing with KVM and LibAFL
- **Status**: Active development
- **Target**: Complex applications requiring state setup

### 7.4 LibAFL Framework

#### Key Features
- **Language**: Rust (performance + safety)
- **Modularity**: Reusable fuzzer components
- **Performance**: 120k exec/sec in frida-mode (mobile, all cores)
- **Scalability**: LLMP (Low Level Message Passing)
  - Nearly linear scaling over cores
  - TCP-based multi-machine fuzzing

#### Platform Support
- Windows, macOS, iOS, Linux, Android
- no_std mode for embedded devices, hypervisors
- Supports QEMU TCG and KVM accelerator

### 7.5 Network Fuzzing Performance (May 2025)

#### Comparison: AFLNet vs LibAFL-based

**AFLNet (Traditional)**:
- ~30 exec/sec (single core)
- No multicore support
- Limited coverage depth

**Custom LibAFL Network Fuzzer**:
- ~1200 exec/sec per core
- Linear multicore scaling
- Hundreds of additional coverage lines
- Multiple bugs in heavily-fuzzed code

**Key Innovation**: libdesock for socket operation interception without network overhead

### 7.6 AFL++ Features

**Enhancements over vanilla AFL**:
- Community patches integration
- QEMU 5.1 upgrade
- Collision-free coverage instrumentation
- Enhanced laf-intel & redqueen
- AFLfast++ power schedules
- MOpt mutators
- unicorn_mode for emulation
- Persistent mode for speed

### 7.7 Hardware-Assisted Fuzzing Complexity

| Technology | Complexity | Setup Difficulty | Performance Gain | Use Case |
|------------|-----------|------------------|------------------|----------|
| Intel PT (LibAFL) | High | High | 10-50x vs software | Complex binaries |
| Nyx + KVM | Very High | Very High | 20-100x | Full system fuzzing |
| Snapshot Fuzzing | Medium | Medium | 5-20x | Post-init fuzzing |
| LibAFL Framework | Medium | Medium | 2-10x | Custom fuzzers |
| AFL++ | Low | Low | 2-5x vs AFL | General purpose |
| Network Fuzzing (LibAFL) | High | High | 40x vs AFLNet | Protocol fuzzing |

---

## 8. Windows Modern Heap Exploitation

### 8.1 Windows Heap Overview

#### Two Main Allocators
1. **NT Heap**: Default memory allocator (Windows 7+)
2. **Segment Heap**: Modern allocator (Windows 10+)
   - Default for UWP apps
   - Microsoft Edge
   - Modern system processes

### 8.2 Segment Heap Allocators

#### VS (Variable Size) Allocator
**Protections**:
- Encrypted block header critical information
- Secure data structures for free block connections
- Strong overflow protection

**Exploitation Requirements**:
- Information leakage necessary
- High exploitation threshold

#### LFH (Low Fragmentation Heap)
**Activation**: Certain block size reaches threshold
**Characteristics**:
- More lenient protection vs VS
- No block headers → uncontrolled overflow into adjacent blocks
- Higher efficiency

**Mitigations**:
- Full randomization of heap block layouts
- Recently freed blocks not reliably reused

**Bypass**: Heap spraying techniques

### 8.3 Real-World Exploitation: MadLicense Vulnerability (2024)

**Dubbed**: "The Maddest Vulnerability of 2024"

**Attack Against Segment Heap**:
1. Unbounded heap overflow
2. Overflow into target heap block despite randomization
3. Fake objects via overflow
4. Arbitrary address read/write/call primitives

**Target**: Windows Server 2025 (latest, all mitigations enabled)

**Significance**:
- Quote from Zhiniang Peng: "Currently, with all the latest mitigations fully enabled on Windows, it is extremely difficult to remotely exploit a memory corruption vulnerability. Many vulnerabilities no longer have exploitable paths, or the paths that remain are very few and very obscure."
- Yet MadLicense was still fully exploitable

### 8.4 LFH Randomization Weaknesses

#### Windows 10 Build 16179 Randomization
**Issue**: Weakness in LFH randomization implementation

**Attacker Goals**:
- Contiguous allocations (heap feng shui)
- malloc() → free() → malloc() returns same chunk (UAF)

**Initial Mitigation**: Randomization of chunk allocation order

**Patch (Build 16179)**: Additional RtlpHeapGenerateRandomValue32() call

**Current Status**: Still bypassable via sufficient heap spraying

### 8.5 Modern Exploitation Trends

#### Shift Away from Heap Spraying
**Old Method**: Spray heap with controlled objects
**New Method**: Information disclosure primitives

**Modern Approach**:
1. Leverage heap-specific vulnerabilities
2. Create information disclosure primitive
3. Obtain offsets and memory addresses
4. Build precise payload
5. Bypass sandbox environment

### 8.6 Windows Heap Versions

#### Windows 7 NT Heap
- More straightforward exploitation
- Better documented techniques
- Fewer inline mitigations

#### Windows 10/11 Segment Heap
- Complex allocation strategies
- Multiple sub-allocators
- Heavy randomization
- Encrypted metadata

### 8.7 Training Resources

**Corelan Heap Masterclass (BruCON 2024)**:
- Windows 7, 10, 11 exploitation
- Generic techniques across versions
- Previously undocumented techniques
- Important exploitation primitives

### 8.8 Windows Heap Exploitation Complexity

| Windows Version | Heap Type | Complexity | Information Leak Required | Success Rate |
|-----------------|-----------|-----------|--------------------------|--------------|
| Windows 7 | NT Heap | Medium | Sometimes | High |
| Windows 10 (NT) | NT Heap | Medium | Yes | Medium |
| Windows 10 (Segment) | VS Allocator | High | Yes | Low |
| Windows 10 (Segment) | LFH | Medium-High | Helpful | Medium |
| Windows 11 | Segment Heap | Very High | Yes | Low |
| Windows Server 2025 | Segment Heap | Very High | Yes | Very Low |

---

## 9. Novel CTF and Research Techniques

### 9.1 Pwn2Own Vancouver 2024

**Overall Statistics**:
- **Total Prize Money**: $1,132,500
- **Zero-Days Demonstrated**: 29 exploits/chains
- **Duration**: 2 days (March 21-22, 2024)
- **Top Winner**: Manfred Paul ($202,500)

#### Notable Exploits

**Browser Targets**: Apple Safari, Google Chrome, Microsoft Edge

##### CVE-2024-2887 (Chrome/Edge WebAssembly)
- **Exploiter**: Manfred Paul
- **Type**: Type confusion in WebAssembly
- **Method**: Double-tap RCE via crafted HTML page
- **Targets**: Both Chrome and Edge with same exploit

##### CVE-2024-2886 (Chrome/Edge WebCodecs)
- **Exploiter**: KAIST Hacking Lab (Seunghyun Lee)
- **Type**: Use-After-Free in WebCodecs API
- **Capability**: Arbitrary read/write via crafted HTML
- **Targets**: Chrome and Edge (single exploit for both)

#### Windows Kernel Exploitation

**CVE-2024-30088**: Windows Kernel Local Privilege Escalation
- **Category**: Windows Local EoP (full win)
- **Key Insight**: Windows does NOT enable SMAP
  - SMAP: Supervisor Mode Access Prevention
  - Buffers in user mode accessible without copying
  - Exploitation simpler than Linux with SMAP

### 9.2 Pwn2Own Berlin 2025

**Results**:
- **Prize Money**: $1 million+
- **Zero-Days Disclosed**: 28
- **Major Targets**: VMware, Firefox

### 9.3 Google CTF and DEF CON CTF

#### DEF CON CTF
- **Status**: Premier hacking event
- **Format**: Intense Capture The Flag competition
- **Participants**: Elite hackers worldwide
- **Prize**: Black badge (lifetime DEF CON access)
- **Notable Team**: PPP (6 black badges won)

#### Google CTF
- **Challenge Categories**:
  - Web security
  - Reverse engineering
  - Cryptography
  - Diverse cybersecurity domains
- **Quality**: High-quality challenges (Google involvement)
- **Participant Range**: Beginners to professionals

### 9.4 Zero-Day Trends (2024)

**Google Threat Intelligence Group (GTIG) Report**:
- **2024 Zero-Days**: 75 identified
- **2023 Zero-Days**: 98 identified
- **Trend**: Slight decrease but still higher than 2022
- **Shift**: Concerning increase in enterprise-targeted attacks
- **Persistence**: Gradual but persistent rise in exploitation

### 9.5 Modern ROP/JOP/SROP Research (2024-2025)

#### ROPGMN - Detection Approach (October 2024)
**Publication**: Future Generation Computer Systems, Volume 164, 2025
**Funding**: Sichuan Science and Technology Program (2024NSFTD0031)

**Variants Addressed**:
- Jump Oriented Programming (JOP)
- Just-In-Time ROP (JIT-ROP)
- Blind ROP (BROP)
- Sigreturn Oriented Programming (SROP)

**Innovation**: Dynamic feature and graph matching network for ROP variant detection

#### Machine Learning for ROP Chain Generation
**Source**: Quarkslab 2024-2025 Internship Program
**Goal**: Automatic ROP chain building via Reinforcement Learning
**Platform**: x86_64
**Approach**: Dataflow graphs as observations for RL agent
**Innovation**: Reduced gadget set requirements

#### Fundamental Techniques Status

##### Return-Oriented Programming (ROP)
- **Status**: Still main exploitation technique
- **Turing Complete**: Can construct arbitrary programs
- **Defense**: DEP + ASLR bypassable in many cases
- **Current State**: Remains highly effective despite protections

##### Jump-Oriented Programming (JOP)
- **Evolution**: Response to ROP mitigations
- **Gadgets**: End in indirect jumps (not returns)
- **Requires**: Dispatcher gadget
- **Effectiveness**: Bypasses return-address protections

##### Call-Oriented Programming (COP)
- **Difference from JOP**: Uses indirect calls
- **Gadgets**: Memory-indirect call instructions
- **Advantage**: No dispatcher gadget required
- **Status**: Less common but effective

##### Sigreturn-Oriented Programming (SROP)
- **Mechanism**: Exploit sigreturn() system call
- **Method**:
  1. Kernel pushes process context to stack (signal handler)
  2. sigreturn() restores context from stack
  3. Attacker controls stack → controls all registers
- **Use Case**: Insufficient ROP gadgets for traditional attacks
- **Requirements**: Execute syscall with rax = rt_sigreturn number

### 9.6 Hardware Defenses (Current State)

#### Intel CET (Control-flow Enforcement Technology)
- **Shadow Stack**: Protected return addresses (MMU-enforced)
- **Validation**: Return address on stack must match shadow stack
- **Exception**: Mismatch raises exception
- **Target**: ROP and JOP exploits
- **Status**: Deployed but bypassable (see COOP attacks)

#### ARM PAC + BTI
- **PAC**: Signed pointers (source validation)
- **BTI**: Branch target identification (destination validation)
- **Combined Effect**: 50x gadget reduction (NSA findings)
- **Status**: Strong but not impenetrable (PACMAN attack)

### 9.7 CTF/Research Complexity Matrix

| Technique/Event | Complexity | Innovation Level | Real-World Applicability |
|-----------------|-----------|------------------|--------------------------|
| Pwn2Own Exploits | Very High | Very High | High (0-day) |
| DEF CON CTF Challenges | Extremely High | High | Medium (educational) |
| Google CTF Challenges | High | Medium | Medium (varied) |
| Modern ROP Variants | High | Medium | High |
| SROP | Medium | Low | High |
| ML-based ROP Generation | Very High | Very High | Low (research) |

---

## 10. eBPF Exploitation

### 10.1 Recent eBPF Vulnerabilities (2024-2025)

#### CVE-2024-56614 (Integer Overflow in XSK map_delete_elem)
- **Type**: Integer overflow → Out-of-bounds
- **Component**: eBPF with AF_XDP sockets
- **Discoverer**: Jordy Zomer
- **Impact**: Memory corruption in kernel

#### CVE-2024-56615 (Integer Overflow in DEVMAP map_delete_elem)
- **Type**: Integer overflow → Out-of-bounds
- **Component**: eBPF DEVMAP
- **Discoverer**: Jordy Zomer
- **Impact**: Kernel memory corruption

### 10.2 Flow Hijacking Technique (2025)

**Publication**: International Journal of Information Security, Springer

#### Concept
Generic eBPF exploitation bypassing kernel code and CFI protections

#### Identified Risks
1. **Interpreter**: Absence of hijacking defenses
2. **JIT Compiler**: Incomplete CFI enforcement

#### Techniques

##### Tailcall Trampoline
- **Target**: eBPF interpreter
- **Method**: Corrupt tailcalls
- **Result**: Redirect to injected code
- **Advantage**: No function pointer modification required

##### JIT-Type Confusion
- **Target**: JIT compiler
- **Method**: Forge trusted pointers in JIT
- **Result**: Execute attacker-controlled code
- **Bypass**: CFI protections

### 10.3 Verifier Vulnerabilities

#### Google Buzzer Discovery
**Discovery Method**: Automated tooling (Google's Buzzer)

**Vulnerability**: Register limit tracking bug
- **Mechanism**: Verifier thinks register has different value than actual
- **Exploitation**:
  1. Bypass verifier checks
  2. Gain arbitrary kernel R/W primitive
  3. Full system compromise

**Notable CVEs**:
- CVE-2020-8835: eBPF verifier bug
- CVE-2021-4204: Input validation issue
- CVE-2021-20268: eBPF privilege escalation
- CVE-2022-23222: eBPF verifier bypass

### 10.4 eBPF-Based Malware

#### BPFDoor
**Significance**: First observed eBPF backdoor in production

**Characteristics**:
- No kernel exploit required
- Uses legitimate eBPF hooks
- Packet filter-based communication channel
- Monitors/manipulates network traffic in kernel
- Commands/responses blend with normal traffic
- No module load, no filesystem artifact, minimal process footprint

**Stealth Techniques**:
- Within verifier-approved rules
- Runs as sanctioned eBPF program
- Uses normal kernel hooks, tracepoints, kprobes
- Doesn't appear in /proc, logs, or audit trails

#### LinkPro Rootkit (2024)
**Discoverer**: Synacktiv (AWS incident response)
**Initial Vector**: CVE-2024-23897 (Jenkins vulnerability)

**Architecture**: Two eBPF modules

##### Hide Module
- **Purpose**: Conceal rootkit activity at kernel level
- **Targets**: Processes, network communications
- **Evasion**: EDR and forensics bypass

##### Knock Module
- **Purpose**: Stealth activation
- **Trigger**: Magic TCP packet monitoring
- **Result**: Initiate rootkit functionality only when needed

**Stealth Level**: Operates beneath view of traditional EDR/forensics

### 10.5 Defensive Challenges

#### eBPF Rootkit Characteristics
- Stays within verifier-approved rules
- No suspicious kernel modules
- Uses normal eBPF mechanisms
- No kernel exploit for initial access
- Requires privilege (but then undetectable)

#### Detection Difficulties
- Doesn't appear in standard process lists
- No system log entries
- No audit trail
- Operates at kernel level
- Legitimate eBPF usage indistinguishable from malicious

### 10.6 Mitigations and Security Improvements (2024-2025)

#### Unprivileged eBPF Restrictions
- Limited to benign program types (packet filters)
- Blocks kernel execution path for attackers
- Requires CAP_BPF or CAP_SYS_ADMIN for most operations

#### Modern Security Applications (2025)

##### BPF Tokens
- **Purpose**: Scope eBPF program privileges
- **Benefit**: Prevent privilege escalation
- **Mechanism**: Fine-grained capability control

##### BPF LSM (Linux Security Module)
- **Purpose**: Mandatory Access Control policies
- **Benefit**: No kernel modifications required
- **Usage**: Security policy enforcement via eBPF

##### Runtime Monitoring
- **Purpose**: Detect anomalous syscall patterns
- **Target**: Exploit attempt indicators
- **Method**: eBPF-based monitoring programs

#### Container Protections
**seccomp Mitigation**:
- Restrict syscall set for userland processes
- Docker default: eBPF syscalls blocked
- Prevents container exploitation via eBPF

#### 2024 Status
- No major eBPF CVEs in the wild
- Quick patching effective
- Ongoing scrutiny continues

### 10.7 eBPF Exploitation Complexity

| Technique/Malware | Complexity | Prerequisites | Stealth Level | Detection Difficulty |
|-------------------|-----------|---------------|---------------|---------------------|
| Verifier Bypass | Very High | Specific CVE | Low | Low (crashes common) |
| Flow Hijacking | Extremely High | Deep eBPF knowledge | High | Medium |
| BPFDoor | High | Root access | Very High | Very High |
| LinkPro | High | Root + CVE | Very High | Very High |
| JIT-Type Confusion | Very High | JIT enabled | Medium | Medium |

---

## 11. Side-Channel Attacks

### 11.1 Spectre and Meltdown Overview

**Disclosure**: January 2018
**Impact**: Fundamental vulnerabilities in CPU speculative execution

#### Meltdown (CVE-2017-5754)
- **Target**: Kernel memory from user space
- **Mechanism**: Out-of-order execution + cache side-channel
- **Affected**: Primarily Intel CPUs
- **Mitigation**: KPTI (Kernel Page Table Isolation)
- **Performance Impact**: 5-30% overhead

#### Spectre
- **Variants**: Multiple (see below)
- **Target**: Process memory via speculative execution
- **Affected**: Nearly all devices (desktops, laptops, servers, smartphones)
- **Mitigation**: Harder to patch (architectural issue)
- **Status**: Partial mitigations only

### 11.2 Catalogued Variants

| CVE | Name | Type | Mitigation Difficulty |
|-----|------|------|----------------------|
| CVE-2017-5753 | Spectre Variant 1 | Bounds Check Bypass (BCB) | Medium |
| CVE-2017-5715 | Spectre Variant 2 | Branch Target Injection (BTI) | High |
| CVE-2017-5754 | Meltdown Variant 3 | Rogue Data Cache Load (RDCL) | Medium (KPTI) |
| CVE-2018-3640 | Spectre Variant 3a | Rogue System Register Read | Medium |
| CVE-2018-3639 | Spectre Variant 4 | Speculative Store Bypass (SSB) | Medium |
| CVE-2018-3665 | Spectre LazyFP | Lazy FP State Restore | Low |
| CVE-2018-3693 | Spectre 1.1 | Bounds Check Bypass Store | Medium |

### 11.3 Notable Subsequent Variants

#### Spectre-STC (July 2020)
- **Full Name**: Spectre Single-Threaded Contention
- **Source**: TU Kaiserslautern, Germany
- **Innovation**: Port contention in shared resources
- **Significance**: Works on single-threaded cores (broader impact)

#### Micro-op Cache Attack (April 2021)
- **Target**: Spectre mitigations themselves
- **Method**: Exploit micro-op cache behavior
- **Result**: Break through security systems designed to mitigate Spectre

### 11.4 Modern Applications (2024-2025)

#### TikTag Attack on ARM MTE (Black Hat 2024)
- **Mechanism**: Leak MTE tags via speculative execution
- **Method**: TikTag gadgets leak tag check results through cache
- **Success Rate**: 80% cache hit rate (sufficient for exploitation)
- **Targets**: Chrome MTE protection, Linux kernel MTE

#### PACMAN Attack on ARM PAC
- **Mechanism**: Forge PAC via speculative execution side-channel
- **Target**: Apple M1 CPU (demonstrated)
- **Capability**: Guess correct PAC without crashes
- **Result**: Control-flow hijacking on PAC-protected platforms

### 11.5 Mitigations and Limitations

#### Microcode Updates
- **Timeline**: Intel added hardware/firmware mitigations (October 2018)
- **Coverage**: Latest processors
- **Limitation**: Older systems remain vulnerable
- **Duration**: Full resistance may take months to years

#### Software Mitigations
- **Retpoline**: Indirect branch isolation (Spectre v2)
- **IBRS**: Indirect Branch Restricted Speculation
- **STIBP**: Single Thread Indirect Branch Predictors
- **SSBD**: Speculative Store Bypass Disable
- **Performance Impact**: 0-50% depending on workload

#### Manufacturer Response
- **Intel**: CPU redesign (2018+)
- **AMD**: Enhanced architecture
- **ARM**: Speculation barriers
- **Status**: Ongoing evolution

### 11.6 Current Status (2024-2025)

#### Remaining Challenges
- Legacy systems permanently vulnerable
- Performance vs security tradeoff
- Spectre harder to patch than Meltdown (architectural)
- Continuous microcode updates required
- New variants still being discovered

#### Exploitation Complexity
- **Academic**: Well-understood
- **Practical**: Difficult to weaponize
- **Real-World Usage**: Limited observed exploitation
- **Risk**: Primarily targeted attacks

### 11.7 Side-Channel Attack Matrix

| Attack | Discovery | Practicality | Mitigation Availability | Performance Impact |
|--------|-----------|--------------|------------------------|-------------------|
| Meltdown | 2018 | Medium | High (KPTI) | 5-30% |
| Spectre v1 | 2018 | Medium | Partial | 0-10% |
| Spectre v2 | 2018 | High | Good | 5-20% |
| Spectre-STC | 2020 | Low | Limited | Variable |
| TikTag (MTE) | 2024 | Medium | Limited | N/A |
| PACMAN (PAC) | Research | Medium | Limited | N/A |

---

## Implementation Priority Matrix

### Quick Wins (Low Complexity, High Impact)
1. **Docker Socket Exploitation** - Instant host access if exposed
2. **modprobe_path Technique** - Simple kernel write → root execution
3. **Safe-Linking Heap Leak Bypass** - Single read primitive sufficient
4. **Privileged Container Escape** - Multiple straightforward escape routes

### Medium Complexity, High Value
1. **House of Botcake** - Reliable tcache poisoning (glibc 2.35+)
2. **msg_msg Exploitation (new 2025 technique)** - Clean AARW primitive
3. **V8 Type Confusion → OOB Array** - Standard browser exploitation flow
4. **Windows LFH Heap Spraying** - Bypass randomization via volume

### Advanced Techniques (High Complexity, Cutting Edge)
1. **House of Rust** - Leakless exploitation with full PIE
2. **Flow Hijacking in eBPF** - Tailcall trampoline, JIT type confusion
3. **COOP Attack on Intel CET** - Bypass shadow stack without return corruption
4. **CVE-2024-50264 (Pwnie Winner)** - Multi-primitive kernel exploitation
5. **AI-Guided Fuzzing with LLMs** - 7000% coverage improvement potential

### Research-Level (Extremely High Complexity)
1. **TikTag MTE Bypass** - Speculative execution side-channel
2. **PACMAN Attack** - Microarchitectural PAC forgery
3. **V8 Heap Sandbox Bypass via Blink** - API object corruption
4. **Windows Segment Heap VS Allocator** - Full leak + precision required
5. **Machine Learning ROP Chain Generation** - RL-based automated exploitation

---

## Recommended Implementation Roadmap for supwngo

### Phase 1: Foundation (Immediate)
- Safe-Linking bypass techniques (heap leak method)
- Modern House of techniques (Botcake, Tangerine)
- Basic container escape detection/exploitation
- Enhanced ROP/JOP/SROP chain building

### Phase 2: Advanced Capabilities
- msg_msg exploitation primitives
- io_uring vulnerability exploitation framework
- V8 type confusion detection and exploitation
- Intel PT integration for hardware-assisted fuzzing

### Phase 3: Cutting Edge
- AI/ML-assisted vulnerability discovery (OSS-Fuzz integration)
- eBPF exploitation and detection
- ARM MTE/PAC/BTI bypass techniques
- Windows Segment Heap exploitation

### Phase 4: Research Integration
- Automatic mitigation bypass strategy selection
- Advanced side-channel attack implementations
- Hybrid fuzzing with symbolic execution + LLM
- Cross-platform exploitation automation

---

## Sources

### Modern glibc Heap Exploitation
- [Bypassing GLIBC 2.32's Safe-Linking: House of Rust](https://c4ebt.github.io/2021/01/22/House-of-Rust.html)
- [shellphish/how2heap Repository](https://github.com/shellphish/how2heap)
- [UAF Exploitation in glibc-2.35: Ulele (crewCTF 2024)](https://n132.github.io/2024/08/07/Ulele.html)
- [Overview of GLIBC heap exploitation techniques](https://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/)

### Linux Kernel Exploitation
- [xairy/linux-kernel-exploitation Repository](https://github.com/xairy/linux-kernel-exploitation)
- [Kernel-hack-drill and CVE-2024-50264](https://a13xp0p0v.github.io/2025/09/02/kernel-hack-drill-and-CVE-2024-50264.html)
- [CVE-2024-0582: io_uring UAF Vulnerability](https://www.openwall.com/lists/oss-security/2024/04/24/3)
- [Critical Linux Kernel Bug: MSG_OOB Exploit CVE-2025-38236](https://linuxsecurity.com/news/security-vulnerabilities/linux-kernel-bug-grants-attackers-full-kernel-level-control)

### Modern Mitigation Bypasses
- [Bypassing Intel CET with Counterfeit Objects](https://www.offsec.com/blog/bypassing-intel-cet-with-counterfeit-objects/)
- [Debugging Intel CET Shadow Stack Bypasses](https://markaicode.com/debugging-intel-cet-shadow-stack-bypasses-gdb/)
- [Intel CET In Action](https://www.offsec.com/blog/intel-cet-in-action/)
- [Bypassing MTE with CVE-2025-0072](https://github.blog/security/vulnerability-research/bypassing-mte-with-cve-2025-0072/)
- [Critical Arm Mali GPU Vulnerability Enables MTE Bypass](https://gbhackers.com/arm-mali-gpu-vulnerability-enables-bypass-of-mte/)

### Browser/V8/JIT Exploitation
- [Getting RCE in Chrome with JIT Compiler Bug](https://github.blog/security/vulnerability-research/getting-rce-in-chrome-with-incorrect-side-effect-in-the-jit-compiler/)
- [Chrome Zero-Day Vulnerabilities Exploited in 2025](https://cybersecuritynews.com/chrome-zero-day-2025/)
- [Chrome V8 Zero-Day: CVE-2025-6554](https://freemindtronic.com/chrome-v8-zero-day-cve-2025-6554-active-exploit/)
- [Chrome Browser Exploitation Part 2: JIT Compilation](https://jhalon.github.io/chrome-browser-exploitation-2/)

### AI/ML-Assisted Vulnerability Discovery
- [Google: Leveling Up Fuzzing with AI](https://security.googleblog.com/2024/11/leveling-up-fuzzing-finding-more.html)
- [Google's AI-Powered OSS-Fuzz Finds 26 Vulnerabilities](https://thehackernews.com/2024/11/googles-ai-powered-oss-fuzz-tool-finds.html)
- [Revolutionizing Vulnerability Discovery with AI-Powered Fuzzing](https://blog.shellnetsecurity.com/posts/2025/revolutionizing-vulnerability-discovery-with-ai-powered-fuzzing/)

### Container Escape Techniques
- [Critical runC Vulnerabilities Allow Container Escape](https://www.gopher.security/news/critical-runc-vulnerabilities-allow-container-escape-in-docker-kubernetes)
- [Leaky Vessels: Deep Dive on Container Escape Vulnerabilities](https://www.wiz.io/blog/leaky-vessels-container-escape-vulnerabilities)
- [Defending Kubernetes Clusters against Container Escape Attacks](https://www.appsecengineer.com/blog/defending-kubernetes-clusters-against-container-escape-attacks)
- [Container Breakouts: Escape Techniques in Cloud Environments](https://unit42.paloaltonetworks.com/container-escape-techniques/)

### Hardware-Assisted Fuzzing
- [Google Summer of Code 2024 Project with AFLplusplus](https://gist.github.com/Marcondiro/7701cc51eeba8ac9ed252b5499fdecaa)
- [Introducing HyperHook: A Harnessing Framework for Nyx](https://neodyme.io/en/blog/hyperhook/)
- [LibAFL GitHub Repository](https://github.com/AFLplusplus/LibAFL)
- [How to Build High-Performance Network Fuzzer with LibAFL](https://lolcads.github.io/posts/2025/05/high_performance_network_fuzzing/)
- [Tartiflette: Snapshot Fuzzing with KVM and LibAFL](https://github.com/Agnoctopus/Tartiflette)

### Windows Modern Heap Exploitation
- [The Maddest Vulnerability of 2024](https://www.darknavy.org/darknavy_insight/the_maddest_vulnerability_of_2024/)
- [Windows Heap Exploitation - From Overflow to Arbitrary R/W](https://mrt4ntr4.github.io/Windows-Heap-Exploitation-dadadb/)
- [Corelan Heap Masterclass – BruCON 2024](https://archive.brucon.org/2024/brucon-2024-training/corelan-heap-masterclass/)

### Novel CTF and Research Techniques
- [CVE-2024-30088 Pwning Windows Kernel @ Pwn2Own Vancouver 2024](https://exploits.forsale/pwn2own-2024/)
- [Google Fixes Chrome Zero-Days Exploited at Pwn2Own 2024](https://www.bleepingcomputer.com/news/security/google-fixes-chrome-zero-days-exploited-at-pwn2own-2024/)
- [Pwn2Own Wikipedia](https://en.wikipedia.org/wiki/Pwn2Own)
- [ROPGMN: Effective ROP and Variants Discovery](https://www.sciencedirect.com/science/article/abs/pii/S0167739X24005314)

### eBPF Exploitation
- [eBPF Ecosystem Progress in 2024-2025](https://eunomia.dev/blog/2025/02/12/ebpf-ecosystem-progress-in-20242025-a-technical-deep-dive/)
- [Flow Hijacking in eBPF: Exploitation and Mitigation](https://link.springer.com/article/10.1007/s10207-025-01124-x)
- [CVE-2024-56614 & CVE-2024-56615: eBPF Vulnerabilities](https://securityonline.info/cve-2024-56614-cve-2024-56615-poc-exploits-released-for-severe-ebpf-vulnerabilities-in-linux-kernel/)
- [Linux Rootkit Conceals Itself with eBPF & Magic Packets](https://dailysecurityreview.com/cyber-security/application-security/linux-rootkit-conceals-itself-with-ebpf-magic-packets-exploiting-cve-2024-23897/)

### Side-Channel Attacks
- [Spectre Wikipedia](https://en.wikipedia.org/wiki/Spectre_(security_vulnerability))
- [CISA: Meltdown and Spectre Guidance](https://www.cisa.gov/news-events/alerts/2018/01/04/meltdown-and-spectre-side-channel-vulnerability-guidance)

---

**Document Version**: 1.0
**Last Updated**: December 18, 2025
**Research Period**: 2023-2025
**Total Techniques Documented**: 50+
**Total CVEs Referenced**: 30+
